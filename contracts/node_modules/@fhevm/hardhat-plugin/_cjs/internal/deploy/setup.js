"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupMockUsingCoreContractsArtifacts = setupMockUsingCoreContractsArtifacts;
const mock_utils_1 = require("@fhevm/mock-utils");
const debug_1 = __importDefault(require("debug"));
const ethers_1 = require("ethers");
const path = __importStar(require("path"));
const picocolors = __importStar(require("picocolors"));
const error_1 = require("../../error");
const constants_1 = __importDefault(require("../constants"));
const error_2 = require("../error");
const ethers_2 = require("../utils/ethers");
const addresses_1 = require("./addresses");
const debug = (0, debug_1.default)("@fhevm/hardhat:setup");
function __logDeploy(contractName, contractAddress, artifactPath) {
    debug(`Deploy ${picocolors.cyanBright(contractName)} at ${contractAddress} using artifact ${artifactPath}`);
}
function __logAlreadyDeployed(contractName, contractAddress, artifactPath) {
    debug(`${picocolors.cyanBright(contractName)} is already deployed at ${contractAddress} using artifact ${artifactPath}`);
}
async function __tryDeploy(mockProvider, contractName, contractAddress, artifactPath, bytecode) {
    try {
        const deployedBytecode = await mockProvider.getCodeAt(contractAddress);
        if (deployedBytecode === bytecode) {
            __logAlreadyDeployed(contractName, contractAddress, artifactPath);
            return {
                deployed: true,
                alreadyDeployed: true,
            };
        }
        else {
            (0, error_2.assertHHFhevm)(deployedBytecode === "0x", `${contractName} contract's bytecode at ${contractAddress} is not empty.`);
            __logDeploy(contractName, contractAddress, artifactPath);
            await mockProvider.setCodeAt(contractAddress, bytecode);
            return {
                deployed: true,
                alreadyDeployed: false,
            };
        }
    }
    catch (e) {
        debug(`Deploy ${contractName} at address ${contractAddress} using artifact at ${artifactPath} failed.`);
        throw e;
    }
}
function __logCallFuncFailed(contractName, contractAddress, funcName) {
    debug(`${picocolors.bgRedBright(picocolors.bold("ERROR"))} invalid deployed ${contractName} contact at ${contractAddress}. Function ${funcName} does not exist.`);
}
async function __tryCallGetFHEVMExecutorAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getFHEVMExecutorAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getFHEVMExecutorAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name} contracts.`);
    }
}
async function __tryCallGetACLAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getACLAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getACLAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name} contracts.`);
    }
}
async function __tryCallGetHCULimitAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getHCULimitAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getHCULimitAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name} contracts.`);
    }
}
async function __tryCallGetInputVerifierAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getInputVerifierAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getInputVerifierAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name} contracts.`);
    }
}
function __requireResolveFhevmCoreContracts() {
    const pkgPath = require.resolve(path.join(constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name, "package.json"), {
        paths: [__dirname],
    });
    const pkgJson = require(pkgPath);
    const pkg = require(path.join(constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name, "package.json"));
    (0, error_2.assertHHFhevm)(pkgJson.version === pkg.version, "__requireResolveFhevmCoreContracts version mismatch");
    return { version: pkg.version, packagePath: pkgPath };
}
function __requireConsumerFhevmCoreContracts(root) {
    const pkgPath = require.resolve(path.join(constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name, "package.json"), {
        paths: [root],
    });
    const pkg = require(pkgPath);
    return { version: pkg.version, packagePath: pkgPath };
}
async function setupMockUsingCoreContractsArtifacts(mockProvider, fhevmAddresses, fhevmSigners, fhevmPaths) {
    const consumerCoreContractsPkg = __requireConsumerFhevmCoreContracts(fhevmPaths.rootDir);
    const hhPluginCoreContractsPkg = __requireResolveFhevmCoreContracts();
    if (consumerCoreContractsPkg.version !== constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.version) {
        throw new error_1.HardhatFhevmError(`Invalid ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name} version. Expecting ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.version}. Got ${consumerCoreContractsPkg.version} instead (at ${consumerCoreContractsPkg.packagePath}).`);
    }
    if (hhPluginCoreContractsPkg.version !== constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.version) {
        throw new error_1.HardhatFhevmError(`Invalid ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name} version. Expecting ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.version}. Got ${hhPluginCoreContractsPkg.version} instead (at ${hhPluginCoreContractsPkg.packagePath}).`);
    }
    const FHEVMExecutorAddress = fhevmAddresses.CoprocessorConfig.CoprocessorAddress;
    const aclAddress = fhevmAddresses.CoprocessorConfig.ACLAddress;
    const kmsVerifierAddress = fhevmAddresses.CoprocessorConfig.KMSVerifierAddress;
    const inputVerifierAddress = fhevmAddresses.InputVerifierAddress;
    const hcuLimitAddress = fhevmAddresses.HCULimitAddress;
    const decryptionOracleAddress = fhevmAddresses.CoprocessorConfig.DecryptionOracleAddress;
    const execArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("FHEVMExecutor");
    const execDeployment = await __tryDeploy(mockProvider, "FHEVMExecutor", FHEVMExecutorAddress, execArtifact.path, execArtifact.artifact.deployedBytecode);
    const fhevmExecutorReadOnly = new ethers_1.ethers.Contract(FHEVMExecutorAddress, execArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const precompiledACLAddress = (await fhevmExecutorReadOnly.getACLAddress());
    const precompiledHCULimitAddress = (await fhevmExecutorReadOnly.getHCULimitAddress());
    const precompiledInputVerifierAddress = (await fhevmExecutorReadOnly.getInputVerifierAddress());
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, precompiledACLAddress, aclAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, precompiledHCULimitAddress, hcuLimitAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, precompiledInputVerifierAddress, inputVerifierAddress);
    const aclArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("ACL");
    const aclDeployment = await __tryDeploy(mockProvider, "ACL", aclAddress, aclArtifact.path, aclArtifact.artifact.deployedBytecode);
    const kmsArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("KMSVerifier");
    const kmsDeployment = await __tryDeploy(mockProvider, "KMSVerifier", kmsVerifierAddress, kmsArtifact.path, kmsArtifact.artifact.deployedBytecode);
    const inputArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("InputVerifier");
    const inputVerifierDeployment = await __tryDeploy(mockProvider, "InputVerifier", inputVerifierAddress, inputArtifact.path, inputArtifact.artifact.deployedBytecode);
    const hcuLimitArtifact = await fhevmPaths.getFhevmCoreContractsArtifact("HCULimit");
    const hcuLimitDeployment = await __tryDeploy(mockProvider, "HCULimit", hcuLimitAddress, hcuLimitArtifact.path, hcuLimitArtifact.artifact.deployedBytecode);
    const decryptionOracleArtifact = await fhevmPaths.getZamaFheOracleSolidityArtifact("DecryptionOracle");
    await __tryDeploy(mockProvider, "DecryptionOracle", decryptionOracleAddress, decryptionOracleArtifact.path, decryptionOracleArtifact.artifact.deployedBytecode);
    const aclReadOnly = new ethers_1.ethers.Contract(aclAddress, aclArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const hcuLimitReadOnly = new ethers_1.ethers.Contract(hcuLimitAddress, hcuLimitArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const inputVerifierReadOnly = new ethers_1.ethers.Contract(inputVerifierAddress, inputArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const kmsVerifierReadOnly = new ethers_1.ethers.Contract(kmsVerifierAddress, kmsArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const decryptionOracleReadOnly = new ethers_1.ethers.Contract(decryptionOracleAddress, decryptionOracleArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const aclFHEVMExecutorAddress = await __tryCallGetFHEVMExecutorAddress(aclReadOnly, "ACL", aclAddress);
    const hcuLimitFHEVMExecutorAddress = await __tryCallGetFHEVMExecutorAddress(hcuLimitReadOnly, "HCULimit", hcuLimitAddress);
    const fhevmExecutorACLAddress = await __tryCallGetACLAddress(fhevmExecutorReadOnly, "FHEVMExecutor", FHEVMExecutorAddress);
    const fhevmExecutorHCULimitAddress = await __tryCallGetHCULimitAddress(fhevmExecutorReadOnly, "FHEVMExecutor", FHEVMExecutorAddress);
    const fhevmExecutorInputVerifierAddress = await __tryCallGetInputVerifierAddress(fhevmExecutorReadOnly, "FHEVMExecutor", FHEVMExecutorAddress);
    __checkHardCodedAddress("ACL", aclAddress, aclFHEVMExecutorAddress, FHEVMExecutorAddress);
    __checkHardCodedAddress("HCULimit", hcuLimitAddress, hcuLimitFHEVMExecutorAddress, FHEVMExecutorAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, fhevmExecutorACLAddress, aclAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, fhevmExecutorHCULimitAddress, hcuLimitAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, fhevmExecutorInputVerifierAddress, inputVerifierAddress);
    const gatewayDecryptionAddress = (0, addresses_1.getGatewayDecryptionAddress)();
    const gatewayChainId = constants_1.default.SEPOLIA.gatewayChainId;
    const kmsInitialThreshold = (0, addresses_1.getKMSThreshold)();
    const kmsSigners = fhevmSigners.kms;
    if (kmsSigners.length !== 1) {
        throw new error_1.HardhatFhevmError(`Expecting 1 KMS Signer. Got ${kmsSigners.length} instead.`);
    }
    const coprocessorSigners = fhevmSigners.coprocessor;
    if (coprocessorSigners.length !== 1) {
        throw new error_1.HardhatFhevmError(`Expecting 1 Coprocessor Signer. Got ${coprocessorSigners.length} instead.`);
    }
    const zero = fhevmSigners.zero;
    const one = fhevmSigners.one;
    const zeroAddress = fhevmSigners.zeroAddress;
    const oneAddress = fhevmSigners.oneAddress;
    await __setContractOwner(mockProvider.minimalProvider, fhevmExecutorReadOnly, "FHEVMExecutor", zero, one, execDeployment.alreadyDeployed);
    await __setContractOwner(mockProvider.minimalProvider, aclReadOnly, "ACL", zero, one, aclDeployment.alreadyDeployed);
    await __setContractOwner(mockProvider.minimalProvider, hcuLimitReadOnly, "HCULimit", zero, one, hcuLimitDeployment.alreadyDeployed);
    const kmsOwner = await kmsVerifierReadOnly.owner();
    if (kmsDeployment.alreadyDeployed) {
        if (kmsOwner !== oneAddress) {
            throw new error_1.HardhatFhevmError(`Wrong KMSVerifier owner address. Got ${kmsOwner}, expected ${oneAddress}`);
        }
    }
    else {
        if (kmsOwner !== zeroAddress) {
            throw new error_1.HardhatFhevmError(`Wrong KMSVerifier owner address. Got ${kmsOwner}, expected ${zeroAddress}`);
        }
    }
    if (kmsOwner !== oneAddress) {
        await (0, mock_utils_1.setOwnableStorage)(mockProvider.minimalProvider, kmsVerifierAddress, oneAddress);
        if ((await kmsVerifierReadOnly.owner()) !== oneAddress) {
            throw new error_1.HardhatFhevmError(`Set KMSVerifier OwnableStorage failed.`);
        }
        await (0, mock_utils_1.setInitializableStorage)(mockProvider.minimalProvider, kmsVerifierAddress, {
            initialized: 1n,
            initializing: false,
        });
        const kmsOne = kmsVerifierReadOnly.connect(one);
        let tx = await kmsOne.initializeFromEmptyProxy(gatewayDecryptionAddress, gatewayChainId, kmsSigners, kmsInitialThreshold);
        await tx.wait();
    }
    (0, error_2.assertHHFhevm)((await kmsVerifierReadOnly.getThreshold()) === BigInt((0, addresses_1.getKMSThreshold)()));
    const _kmsSignersAddresses = await kmsVerifierReadOnly.getKmsSigners();
    await (0, ethers_2.assertSignersMatchAddresses)(kmsSigners, _kmsSignersAddresses);
    const inputVerifierVerifyingContractSource = (0, addresses_1.getGatewayInputVerificationAddress)();
    const inputVerifierOwner = await inputVerifierReadOnly.owner();
    if (inputVerifierDeployment.alreadyDeployed) {
        if (inputVerifierOwner !== oneAddress) {
            throw new error_1.HardhatFhevmError(`Wrong InputVerifier owner address. Got ${inputVerifierOwner}, expected ${oneAddress}`);
        }
    }
    else {
        if (inputVerifierOwner !== zeroAddress) {
            throw new error_1.HardhatFhevmError(`Wrong InputVerifier owner address. Got ${inputVerifierOwner}, expected ${zeroAddress}`);
        }
    }
    if (inputVerifierOwner !== oneAddress) {
        await (0, mock_utils_1.setOwnableStorage)(mockProvider.minimalProvider, inputVerifierAddress, oneAddress);
        if ((await inputVerifierReadOnly.owner()) !== oneAddress) {
            throw new error_1.HardhatFhevmError(`Set InputVerifier OwnableStorage failed.`);
        }
        await (0, mock_utils_1.setInitializableStorage)(mockProvider.minimalProvider, inputVerifierAddress, {
            initialized: 1n,
            initializing: false,
        });
        const inputVerifierOne = inputVerifierReadOnly.connect(one);
        let tx = await inputVerifierOne.initializeFromEmptyProxy(inputVerifierVerifyingContractSource, gatewayChainId, coprocessorSigners);
        await tx.wait();
    }
    const _inputSignersAddresses = await inputVerifierReadOnly.getCoprocessorSigners();
    await (0, ethers_2.assertSignersMatchAddresses)(coprocessorSigners, _inputSignersAddresses);
    const _inputVerifier712Domain = await inputVerifierReadOnly.eip712Domain();
    (0, mock_utils_1.assertIsEIP712Domain)(_inputVerifier712Domain, "InputVerifier", {
        name: mock_utils_1.constants.INPUT_VERIFICATION_EIP712.domain.name,
        version: mock_utils_1.constants.INPUT_VERIFICATION_EIP712.domain.version,
        chainId: BigInt(gatewayChainId),
        verifyingContract: inputVerifierVerifyingContractSource,
    });
    const _kms712Domain = await kmsVerifierReadOnly.eip712Domain();
    (0, mock_utils_1.assertIsEIP712Domain)(_kms712Domain, "KMSVerifier", {
        name: mock_utils_1.constants.PUBLIC_DECRYPT_EIP712.domain.name,
        version: mock_utils_1.constants.PUBLIC_DECRYPT_EIP712.domain.version,
        chainId: BigInt(gatewayChainId),
        verifyingContract: gatewayDecryptionAddress,
    });
    debug(`${picocolors.cyanBright("ACL")} address              : ${aclAddress}`);
    debug(`${picocolors.cyanBright("FHEVMExecutor")} address    : ${FHEVMExecutorAddress}`);
    debug(`${picocolors.cyanBright("InputVerifier")} address    : ${inputVerifierAddress}`);
    debug(`${picocolors.cyanBright("KMSVerifier")} address      : ${kmsVerifierAddress}`);
    debug(`${picocolors.cyanBright("DecryptionOracle")} address : ${decryptionOracleAddress}`);
    debug(`Gateway chainId                         : ${gatewayChainId}`);
    debug(`InputVerifier verifying contract source : ${inputVerifierVerifyingContractSource}`);
    debug(`Gateway Decryption address              : ${gatewayDecryptionAddress}`);
    const repo = await mock_utils_1.contracts.FhevmContractsRepository.create(mockProvider.readonlyEthersProvider, {
        aclContractAddress: aclAddress,
        aclAbi: aclArtifact.artifact.abi,
        aclProperties: {
            fhevmExecutorAddress: aclFHEVMExecutorAddress,
        },
        fhevmExecutorAbi: execArtifact.artifact.abi,
        fhevmExecutorProperties: {
            aclAddress: fhevmExecutorACLAddress,
            hcuLimitAddress: fhevmExecutorHCULimitAddress,
            inputVerifierAddress: fhevmExecutorInputVerifierAddress,
        },
        hcuLimitAbi: hcuLimitArtifact.artifact.abi,
        inputVerifierAbi: inputArtifact.artifact.abi,
        kmsContractAddress: kmsVerifierAddress,
        kmsVerifierAbi: kmsArtifact.artifact.abi,
        zamaFheDecryptionOracleAbi: decryptionOracleArtifact.artifact.abi,
        zamaFheDecryptionOracleAddress: decryptionOracleAddress,
    });
    return {
        contracts: repo,
        config: {
            ACLAddress: aclAddress,
            ACLReadOnly: aclReadOnly,
            FHEVMExecutorAddress: FHEVMExecutorAddress,
            FHEVMExecutorReadOnly: fhevmExecutorReadOnly,
            InputVerifierAddress: inputVerifierAddress,
            InputVerifierReadOnly: inputVerifierReadOnly,
            KMSVerifierAddress: kmsVerifierAddress,
            KMSVerifierReadOnly: kmsVerifierReadOnly,
            DecryptionOracleAddress: decryptionOracleAddress,
            DecryptionOracleReadOnly: decryptionOracleReadOnly,
            gatewayInputVerificationAddress: inputVerifierVerifyingContractSource,
            gatewayChainId,
            gatewayDecryptionAddress: gatewayDecryptionAddress,
        },
        kmsSigners,
        coprocessorSigners,
    };
}
function __checkHardCodedAddress(contractName, contractAddress, hardCodedAddress, expectedHardCodedAddress) {
    if (hardCodedAddress !== expectedHardCodedAddress) {
        debug(`${picocolors.bgRedBright(picocolors.bold("ERROR"))} deployed ${contractName} contact at ${contractAddress} does not use the expected ACL address. Got ${hardCodedAddress}, expecting ${expectedHardCodedAddress}`);
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_CORE_CONTRACTS_PACKAGE.name} contracts.`);
    }
}
async function __setContractOwner(provider, contract, contractName, currentOwnerSigner, newOwnerSigner, alreadyDeployed) {
    const ownerAddress = await contract.owner();
    const contractAddress = await contract.getAddress();
    const currentOwnerAddress = await currentOwnerSigner.getAddress();
    const newOwnerAddress = await newOwnerSigner.getAddress();
    if (alreadyDeployed) {
        if (ownerAddress !== newOwnerAddress) {
            throw new error_1.HardhatFhevmError(`Wrong ${contractName} owner address. Got ${ownerAddress}, expected ${newOwnerAddress}`);
        }
    }
    else {
        if (ownerAddress !== currentOwnerAddress) {
            throw new error_1.HardhatFhevmError(`Wrong ${contractName} owner address. Got ${ownerAddress}, expected ${currentOwnerAddress}`);
        }
    }
    if (ownerAddress === newOwnerAddress) {
        return;
    }
    await (0, mock_utils_1.setOwnableStorage)(provider, contractAddress, newOwnerAddress);
    (0, error_2.assertHHFhevm)((await contract.owner()) === (await newOwnerSigner.getAddress()), `Set ${contractName} owner failed. Unexpected contract owner.`);
}
//# sourceMappingURL=setup.js.map