"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelayerSignerAddress = getRelayerSignerAddress;
exports.getRelayerSigner = getRelayerSigner;
exports.getKMSThreshold = getKMSThreshold;
exports.getGatewayDecryptionAddress = getGatewayDecryptionAddress;
exports.getGatewayInputVerificationAddress = getGatewayInputVerificationAddress;
exports.loadCoprocessorSigners = loadCoprocessorSigners;
exports.loadKMSSigners = loadKMSSigners;
const mock_utils_1 = require("@fhevm/mock-utils");
const debug_1 = __importDefault(require("debug"));
const dotenv = __importStar(require("dotenv"));
const ethers_1 = require("ethers");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const picocolors = __importStar(require("picocolors"));
const error_1 = require("../../error");
const constants_1 = __importDefault(require("../constants"));
const error_2 = require("../error");
const debug = (0, debug_1.default)("@fhevm/hardhat:addresses");
function __isHardhatSignerAddress(hhSigners, address) {
    return hhSigners.findIndex((s) => s.address === address) !== -1;
}
function logDefaultValue(name, defaultValue) {
    debug(`Resolve ${picocolors.magentaBright(name)}=${defaultValue}, using default value.`);
}
function logEnvValue(name, value) {
    debug(`Resolve ${picocolors.yellowBright(name)}=${value}, using env variable ${name}.`);
}
function logDotEnvValue(name, value, dotenvRelPath) {
    debug(`Resolve ${picocolors.greenBright(name)}=${value}, using .env variable stored at ${path.resolve(dotenvRelPath)}`);
}
function __getOptionalStringEnvVar(name) {
    return process.env[name];
}
function __getOptionalUintEnvVar(name) {
    let int = Number.NaN;
    try {
        const str = __getOptionalStringEnvVar(name);
        int = parseInt(str);
    }
    catch {
        int = Number.NaN;
    }
    if (!Number.isNaN(int)) {
        return int;
    }
    return undefined;
}
function __getUintConstant(name, defaultValue) {
    let int = Number.NaN;
    try {
        const str = __getStringConstant(name);
        int = parseInt(str);
    }
    catch {
        int = Number.NaN;
    }
    if (!Number.isNaN(int)) {
        return int;
    }
    if (defaultValue !== undefined) {
        logDefaultValue(name, defaultValue);
        return defaultValue;
    }
    throw new error_1.HardhatFhevmError(`Unable to determine integer constant ${name}`);
}
function __getStringConstant(name, defaultValue, dotenvRelPath) {
    if (defaultValue) {
        (0, error_2.assertHHFhevm)(constants_1.default[name] === defaultValue, `Missing constant ${name} in constants module`);
    }
    if (dotenvRelPath !== undefined && fs.existsSync(dotenvRelPath)) {
        const parsedEnv = dotenv.parse(fs.readFileSync(dotenvRelPath));
        const addr = parsedEnv[name];
        if (addr) {
            logDotEnvValue(name, addr, dotenvRelPath);
            return addr;
        }
    }
    if (name in process.env && process.env[name] !== undefined) {
        const addr = process.env[name];
        logEnvValue(name, addr);
        return addr;
    }
    if (defaultValue) {
        logDefaultValue(name, defaultValue);
        return defaultValue;
    }
    throw new error_1.HardhatFhevmError(`Unable to determine string constant ${name}`);
}
async function getRelayerSignerAddress(hre) {
    const s = await getRelayerSigner(hre);
    const relayerAddress = await s.getAddress();
    return relayerAddress;
}
async function getRelayerSigner(hre) {
    const index = __getRelayerSignerIndex();
    const signers = await hre.ethers.getSigners();
    if (index >= signers.length) {
        throw new error_1.HardhatFhevmError(`Hardhat relayer signer index out of bounds (index=${index}). The total number of signers is ${signers.length}.`);
    }
    return signers[index];
}
function __getRelayerSignerIndex() {
    try {
        const tStr = __getStringConstant("HARDHAT_RELAYER_SIGNER_INDEX");
        const t = parseInt(tStr);
        if (Number.isNaN(t)) {
            throw new error_1.HardhatFhevmError(`Invalid hardhat relayer signer index: ${tStr}`);
        }
        return t;
    }
    catch {
        return constants_1.default["HARDHAT_RELAYER_SIGNER_INDEX"];
    }
}
function getKMSThreshold() {
    return __getUintConstant("KMS_THRESHOLD", constants_1.default["KMS_THRESHOLD"]);
}
function getGatewayDecryptionAddress() {
    try {
        const addr = __getStringConstant("DECRYPTION_ADDRESS");
        if (!ethers_1.ethers.isAddress(addr)) {
            throw new error_1.HardhatFhevmError(`Invalid Decryption contract address: ${addr} (KMS Verifying contract source address)`);
        }
        return addr;
    }
    catch {
        return constants_1.default["DECRYPTION_ADDRESS"];
    }
}
function getGatewayInputVerificationAddress() {
    try {
        const addr = __getStringConstant("INPUT_VERIFICATION_ADDRESS");
        if (!ethers_1.ethers.isAddress(addr)) {
            throw new error_1.HardhatFhevmError(`Invalid InputVerifier verifyingContractSource address: ${addr}`);
        }
        return addr;
    }
    catch {
        return constants_1.default["INPUT_VERIFICATION_ADDRESS"];
    }
}
async function loadCoprocessorSigners(hre, provider) {
    try {
        const hhSigners = await hre.ethers.getSigners();
        const coprocessorSignersAddresses = __envGetHardhatSignersAddresses("NUM_COPROCESSORS", "COPROCESSOR_SIGNER_ADDRESS_", hhSigners);
        const coprocessorSigners = [];
        for (let idx = 0; idx < coprocessorSignersAddresses.length; idx++) {
            const coprocessorSigner = await hre.ethers.getSigner(coprocessorSignersAddresses[idx]);
            coprocessorSigners.push(coprocessorSigner);
        }
        return coprocessorSigners;
    }
    catch {
    }
    const coprocessorSignerKey = __getStringConstant("PRIVATE_KEY_COPROCESSOR_SIGNER", constants_1.default["PRIVATE_KEY_COPROCESSOR_SIGNER"]);
    const signer = new ethers_1.ethers.Wallet(coprocessorSignerKey).connect(provider ?? null);
    return [signer];
}
async function loadKMSSigners(hre, provider) {
    try {
        const hhSigners = await hre.ethers.getSigners();
        const kmsSignersAddresses = __envGetHardhatSignersAddresses("NUM_KMS_NODES", "KMS_SIGNER_ADDRESS_", hhSigners);
        const kmsSigners = [];
        for (let idx = 0; idx < kmsSignersAddresses.length; idx++) {
            const kmsSigner = await hre.ethers.getSigner(kmsSignersAddresses[idx]);
            kmsSigners.push(kmsSigner);
        }
        return kmsSigners;
    }
    catch {
        const kmsSignerKey = __getStringConstant("PRIVATE_KEY_KMS_SIGNER", constants_1.default["PRIVATE_KEY_KMS_SIGNER"]);
        const signer = new ethers_1.ethers.Wallet(kmsSignerKey).connect(provider ?? null);
        return [signer];
    }
}
function envGetList(envVarNamePrefix) {
    envVarNamePrefix = mock_utils_1.utils.ensureSuffix(envVarNamePrefix, "_");
    const list = [];
    for (let idx = 0; idx < 100; idx++) {
        const value = __getOptionalStringEnvVar(`${envVarNamePrefix}${idx}`);
        if (!value) {
            break;
        }
        list.push(value);
    }
    return list;
}
function removeNonHardhatSignerAddresses(addresses, hhSigners, envVarNamePrefix) {
    envVarNamePrefix = mock_utils_1.utils.ensureSuffix(envVarNamePrefix, "_");
    const hardhatAddresses = [];
    for (let i = 0; i < addresses.length; i++) {
        const addr = addresses[i];
        if (!__isHardhatSignerAddress(hhSigners, addr)) {
            console.error(`Ingnoring ${envVarNamePrefix}${i}, not an Hardhat signer address.`);
            break;
        }
        hardhatAddresses.push(addr);
    }
    return hardhatAddresses;
}
function __envGetHardhatSignersAddresses(numEnvVarName, listEnvVarNamePrefix, hhSigners) {
    const num = __getOptionalUintEnvVar(numEnvVarName);
    if (num === undefined) {
        throw new error_1.HardhatFhevmError(`Undefined env var name '${numEnvVarName}'`);
    }
    const envList = envGetList(listEnvVarNamePrefix);
    const addresses = removeNonHardhatSignerAddresses(envList, hhSigners, listEnvVarNamePrefix);
    if (addresses.length < num) {
        throw new error_1.HardhatFhevmError(`Unexpected number of addresses. Got '${addresses.length}', expecting at least ${num}`);
    }
    const res = addresses.slice(0, num - 1);
    (0, error_2.assertHHFhevm)(res.length === num);
    return res;
}
//# sourceMappingURL=addresses.js.map