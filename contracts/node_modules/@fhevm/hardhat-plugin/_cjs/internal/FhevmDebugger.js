"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FhevmDebugger_fhevmEnv;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FhevmDebugger = void 0;
const mock_utils_1 = require("@fhevm/mock-utils");
const mock_utils_2 = require("@fhevm/mock-utils");
const ethers_1 = require("ethers");
const error_1 = require("../error");
const error_2 = require("./error");
class FhevmDebugger {
    constructor(fhevmEnv) {
        _FhevmDebugger_fhevmEnv.set(this, void 0);
        __classPrivateFieldSet(this, _FhevmDebugger_fhevmEnv, fhevmEnv, "f");
    }
    async createDecryptionSignatures(handlesBytes32Hex, clearTextValues) {
        const extraDataV0 = ethers_1.ethers.solidityPacked(["uint8"], [0]);
        const clearTextValuesHex = [];
        for (let i = 0; i < clearTextValues.length; ++i) {
            const ct = clearTextValues[i];
            if (typeof ct === "boolean") {
                clearTextValuesHex.push(ct ? "0x01" : "0x00");
            }
            else if (typeof ct === "bigint") {
                clearTextValuesHex.push("0x" + ct.toString(16));
            }
            else if (typeof ct === "string") {
                clearTextValuesHex.push(ct);
            }
            else {
                throw new error_1.HardhatFhevmError(`Unsupported type ${typeof ct}, expecting bigint | string | boolean`);
            }
        }
        return await mock_utils_1.relayer.requestFhevmCreateDecryptionSignatures(__classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").relayerProvider, {
            handlesBytes32Hex,
            clearTextValuesHex,
            extraData: extraDataV0,
        });
    }
    createHandleCoder() {
        return new mock_utils_1.FhevmHandleCoder(__classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").getACLAddress(), __classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").mockProvider.chainId);
    }
    async decryptEbool(handleBytes32) {
        const handleBytes32Hex = ethers_1.ethers.toBeHex(handleBytes32, 32);
        mock_utils_1.FhevmHandle.verify(handleBytes32Hex, {
            fhevmType: mock_utils_1.FhevmType.ebool,
            chainId: __classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").mockProvider.chainId,
        });
        const clearTextHexList = await mock_utils_1.relayer.requestFhevmGetClearText(__classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").relayerProvider, [
            handleBytes32Hex,
        ]);
        (0, error_2.assertHHFhevm)(clearTextHexList.length === 1);
        const clearTextBigIntList = clearTextHexList.map(ethers_1.ethers.toBigInt);
        return clearTextBigIntList[0] === 1n;
    }
    async decryptEuint(fhevmType, handleBytes32) {
        if (!(0, mock_utils_1.isFhevmEuint)(fhevmType)) {
            throw new error_1.HardhatFhevmError(`Invalid FhevmType argument. Expecting uint type.`);
        }
        const handleBytes32Hex = ethers_1.ethers.toBeHex(handleBytes32, 32);
        mock_utils_1.FhevmHandle.verify(handleBytes32Hex, { fhevmType, chainId: __classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").mockProvider.chainId });
        const clearTextHexList = await mock_utils_1.relayer.requestFhevmGetClearText(__classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").relayerProvider, [
            handleBytes32Hex,
        ]);
        (0, error_2.assertHHFhevm)(clearTextHexList.length === 1);
        const clearTextBigIntList = clearTextHexList.map(ethers_1.ethers.toBigInt);
        return clearTextBigIntList[0];
    }
    async decryptEbytes(fhevmType, handleBytes32) {
        if (!(0, mock_utils_1.isFhevmEbytes)(fhevmType)) {
            throw new error_1.HardhatFhevmError(`Invalid FhevmType argument. Expecting bytes type.`);
        }
        const handleBytes32Hex = ethers_1.ethers.toBeHex(handleBytes32, 32);
        mock_utils_1.FhevmHandle.verify(handleBytes32Hex, { fhevmType, chainId: __classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").mockProvider.chainId });
        const clearTextHexList = await mock_utils_1.relayer.requestFhevmGetClearText(__classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").relayerProvider, [
            handleBytes32Hex,
        ]);
        (0, error_2.assertHHFhevm)(clearTextHexList.length === 1);
        const clearTextBigIntList = clearTextHexList.map(ethers_1.ethers.toBigInt);
        const ebytesBigInt = clearTextBigIntList[0];
        const fhevmTypeInfo = (0, mock_utils_2.getFhevmTypeInfo)(fhevmType);
        (0, error_2.assertHHFhevm)(fhevmTypeInfo.clearTextBitLength % 8 === 0);
        return ethers_1.ethers.toBeHex(ebytesBigInt, fhevmTypeInfo.clearTextBitLength / 8);
    }
    async decryptEaddress(handleBytes32) {
        const handleBytes32Hex = ethers_1.ethers.toBeHex(handleBytes32, 32);
        mock_utils_1.FhevmHandle.verify(handleBytes32Hex, {
            fhevmType: mock_utils_1.FhevmType.eaddress,
            chainId: __classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").mockProvider.chainId,
        });
        const clearTextHexList = await mock_utils_1.relayer.requestFhevmGetClearText(__classPrivateFieldGet(this, _FhevmDebugger_fhevmEnv, "f").relayerProvider, [
            handleBytes32Hex,
        ]);
        (0, error_2.assertHHFhevm)(clearTextHexList.length === 1);
        const clearTextBigIntList = clearTextHexList.map(ethers_1.ethers.toBigInt);
        const eaddressBigInt = clearTextBigIntList[0];
        return ethers_1.ethers.getAddress(ethers_1.ethers.toBeHex(eaddressBigInt, 20));
    }
}
exports.FhevmDebugger = FhevmDebugger;
_FhevmDebugger_fhevmEnv = new WeakMap();
//# sourceMappingURL=FhevmDebugger.js.map