"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FhevmExternalAPI = void 0;
const mock_utils_1 = require("@fhevm/mock-utils");
const mock_utils_2 = require("@fhevm/mock-utils");
const mock_utils_3 = require("@fhevm/mock-utils");
const mock_utils_4 = require("@fhevm/mock-utils");
const ethers_1 = require("ethers");
const error_1 = require("../error");
const constants_1 = __importDefault(require("./constants"));
const FhevmContractError_1 = require("./errors/FhevmContractError");
const log_1 = require("./utils/log");
class FhevmExternalAPI {
    constructor(fhevmEnv) {
        Object.defineProperty(this, "_fhevmEnv", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._fhevmEnv = fhevmEnv;
    }
    async initializeCLIApi() {
        await this._fhevmEnv.initializeCLIApi();
    }
    get isMock() {
        return this._fhevmEnv.mockProvider.isMock;
    }
    get debugger() {
        return this._fhevmEnv.debugger;
    }
    async createInstance() {
        return await this._fhevmEnv.createInstance();
    }
    typeof(handleBytes32) {
        return mock_utils_1.FhevmHandle.fromBytes32Hex(handleBytes32).fhevmTypeInfo.name;
    }
    async tryParseFhevmError(e, options) {
        const err = await (0, FhevmContractError_1.parseFhevmError)(this._fhevmEnv, e, options);
        if (err && options?.out !== undefined) {
            (0, log_1.logBox)(`${err.name} error`, err.longMessage, options);
        }
        return err;
    }
    revertedWithCustomErrorArgs(contractName, customErrorName) {
        const itf = this._fhevmEnv.getContractsRepository().getContractFromName(contractName)?.interface;
        if (!itf) {
            throw new error_1.HardhatFhevmError(`Unable to retrieve FHEVM contrat interface for contract ${contractName}`);
        }
        return [{ interface: itf }, customErrorName];
    }
    parseDecryptionRequestEvents(logs) {
        return (0, mock_utils_2.parseDecryptionRequestEventsFromLogs)(logs);
    }
    parseCoprocessorEvents(logs) {
        return (0, mock_utils_2.parseCoprocessorEventsFromLogs)(logs);
    }
    async getRelayerMetadata() {
        return await mock_utils_3.relayer.requestRelayerMetadata(this._fhevmEnv.relayerProvider);
    }
    async awaitDecryptionOracle() {
        await mock_utils_3.relayer.requestFhevmAwaitDecryptionOracle(this._fhevmEnv.relayerProvider);
    }
    async encryptUint(fhevmType, value, contractAddress, userAddress) {
        const input = this.createEncryptedInput(contractAddress, userAddress);
        switch (fhevmType) {
            case mock_utils_1.FhevmType.euint8:
                input.add8(value);
                break;
            case mock_utils_1.FhevmType.euint16:
                input.add16(value);
                break;
            case mock_utils_1.FhevmType.euint32:
                input.add32(value);
                break;
            case mock_utils_1.FhevmType.euint64:
                input.add64(value);
                break;
            case mock_utils_1.FhevmType.euint128:
                input.add128(value);
                break;
            case mock_utils_1.FhevmType.euint256:
                input.add256(value);
                break;
            default: {
                throw new error_1.HardhatFhevmError(`encryptUint: the fhevmType argument: '${fhevmType}' is not a valid FhevmTypeEuint.`);
            }
        }
        const res = await input.encrypt();
        return { externalEuint: res.handles[0], inputProof: res.inputProof };
    }
    async encryptBool(value, contractAddress, userAddress) {
        const input = this.createEncryptedInput(contractAddress, userAddress);
        input.addBool(value);
        const res = await input.encrypt();
        return { externalEbool: res.handles[0], inputProof: res.inputProof };
    }
    async encryptAddress(value, contractAddress, userAddress) {
        const input = this.createEncryptedInput(contractAddress, userAddress);
        input.addAddress(value);
        const res = await input.encrypt();
        return { externalEaddress: res.handles[0], inputProof: res.inputProof };
    }
    createEncryptedInput(contractAddress, userAddress) {
        if (!ethers_1.ethers.isAddress(contractAddress)) {
            throw new error_1.HardhatFhevmError(`createEncryptedInput: the 'contractAddress' argument is not a valid address. Expecting a valid string address. Got '${contractAddress}' instead.`);
        }
        if (!ethers_1.ethers.isAddress(userAddress)) {
            throw new error_1.HardhatFhevmError(`createEncryptedInput: the 'userAddress' argument is not a valid address. Expecting a valid string address. Got '${userAddress}' instead.`);
        }
        return this._fhevmEnv.instance.createEncryptedInput(contractAddress, userAddress);
    }
    createEIP712(publicKey, contractAddresses, startTimestamp, durationDays) {
        return this._fhevmEnv.instance.createEIP712(publicKey, contractAddresses, startTimestamp, durationDays);
    }
    generateKeypair() {
        return this._fhevmEnv.instance.generateKeypair();
    }
    async userDecrypt(handles, privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) {
        if (this._fhevmEnv.isRunningInHHNode) {
            throw new error_1.HardhatFhevmError(`Cannot call userDecrypt from a 'hardhat node' server.`);
        }
        return await this._fhevmEnv.instance.userDecrypt(handles, privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays);
    }
    async publicDecrypt(handles) {
        if (this._fhevmEnv.isRunningInHHNode) {
            throw new error_1.HardhatFhevmError(`Cannot call publicDecrypt from a 'hardhat node' server.`);
        }
        return await this._fhevmEnv.instance.publicDecrypt(handles);
    }
    async userDecryptEbool(handleBytes32, contractAddress, user, options) {
        const addr = await ethers_1.ethers.resolveAddress(contractAddress);
        const decryptedResults = await (0, mock_utils_4.userDecryptHandleBytes32)(this._fhevmEnv.instance, [{ handleBytes32, contractAddress: addr, fhevmType: mock_utils_1.FhevmType.ebool }], user, options);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for ebool handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "boolean") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of ebool handle '${handleBytes32}': expected a boolean, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        return decryptedResults[handleBytes32];
    }
    async publicDecryptEbool(handleBytes32, options) {
        const instance = options?.instance ?? this._fhevmEnv.instance;
        const decryptedResults = await instance.publicDecrypt([handleBytes32]);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for ebool handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "boolean") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of ebool handle '${handleBytes32}': expected a boolean, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        return decryptedResults[handleBytes32];
    }
    async userDecryptEuint(fhevmType, handleBytes32, contractAddress, user, options) {
        const addr = await ethers_1.ethers.resolveAddress(contractAddress);
        const decryptedResults = await (0, mock_utils_4.userDecryptHandleBytes32)(options?.instance ?? this._fhevmEnv.instance, [{ handleBytes32, contractAddress: addr, fhevmType }], user, options);
        const fhevmTypeInfo = (0, mock_utils_1.getFhevmTypeInfo)(fhevmType);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for ${fhevmTypeInfo.name} handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "bigint") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of ${fhevmTypeInfo.name} handle '${handleBytes32}': expected a bigint, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        return decryptedResults[handleBytes32];
    }
    async publicDecryptEuint(fhevmType, handleBytes32, options) {
        const instance = options?.instance ?? this._fhevmEnv.instance;
        const decryptedResults = await instance.publicDecrypt([handleBytes32]);
        const fhevmTypeInfo = (0, mock_utils_1.getFhevmTypeInfo)(fhevmType);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for ${fhevmTypeInfo.name} handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "bigint") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of ${fhevmTypeInfo.name} handle '${handleBytes32}': expected a bigint, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        return decryptedResults[handleBytes32];
    }
    async userDecryptEaddress(handleBytes32, contractAddress, user, options) {
        const addr = await ethers_1.ethers.resolveAddress(contractAddress);
        const decryptedResults = await (0, mock_utils_4.userDecryptHandleBytes32)(options?.instance ?? this._fhevmEnv.instance, [{ handleBytes32, contractAddress: addr, fhevmType: mock_utils_1.FhevmType.eaddress }], user, options);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for eaddress handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "string") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of eaddress handle '${handleBytes32}': expected a hex string, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        if (!ethers_1.ethers.isAddress(decryptedResults[handleBytes32])) {
            throw new error_1.HardhatFhevmError(`userDecryptEAddress failed. Decrypted value is not a valid address. Got ${decryptedResults[handleBytes32]}.`);
        }
        return decryptedResults[handleBytes32];
    }
    async publicDecryptEaddress(handleBytes32, options) {
        const instance = options?.instance ?? this._fhevmEnv.instance;
        const decryptedResults = await instance.publicDecrypt([handleBytes32]);
        if (!(handleBytes32 in decryptedResults)) {
            throw new error_1.HardhatFhevmError(`Failed to retrieve decrypted value for eaddress handle '${handleBytes32}' from the DecryptedResults response.`);
        }
        if (typeof decryptedResults[handleBytes32] !== "string") {
            throw new error_1.HardhatFhevmError(`Unexpected type for decrypted value of eaddress handle '${handleBytes32}': expected a hex string, but got '${typeof decryptedResults[handleBytes32]}' instead.`);
        }
        if (!ethers_1.ethers.isAddress(decryptedResults[handleBytes32])) {
            throw new error_1.HardhatFhevmError(`publicDecryptEaddress failed. Decrypted value is not a valid address. Got ${decryptedResults[handleBytes32]}.`);
        }
        return decryptedResults[handleBytes32];
    }
    async getCoprocessorConfig(contractAddress) {
        return (0, mock_utils_1.getCoprocessorConfig)(this._fhevmEnv.readonlyEip1193Provider, contractAddress);
    }
    async assertCoprocessorInitialized(contract, contractName) {
        const contractAddress = await this._fhevmEnv.hre.ethers.resolveAddress(contract);
        const expectedACLAddress = this._fhevmEnv.getACLAddress();
        const expectedFHEVMExecutorAddress = this._fhevmEnv.getFHEVMExecutorAddress();
        const expectedDecryptionOracleAddress = this._fhevmEnv.getDecryptionOracleAddress();
        const expectedKMSVerifierAddress = this._fhevmEnv.getKMSVerifierAddress();
        const errorMsgPrefix = contractName === undefined ? `Contract at ${contractAddress}` : `Contract ${contractName} at ${contractAddress}`;
        const coprocessorConfig = await this.getCoprocessorConfig(contractAddress);
        const configFile = `${constants_1.default.FHEVM_SOLIDITY_PACKAGE.name}/${constants_1.default.FHEVM_SOLIDITY_PACKAGE.configFile}`;
        if (coprocessorConfig.ACLAddress === ethers_1.ethers.ZeroAddress ||
            coprocessorConfig.CoprocessorAddress === ethers_1.ethers.ZeroAddress ||
            coprocessorConfig.DecryptionOracleAddress === ethers_1.ethers.ZeroAddress ||
            coprocessorConfig.KMSVerifierAddress === ethers_1.ethers.ZeroAddress) {
            const errorMsg = `${errorMsgPrefix} is not initialized for FHE operations. Make sure it either inherits from ${configFile}:${constants_1.default.FHEVM_SOLIDITY_PACKAGE.configContractName} or explicitly calls FHE.setCoprocessor() in its constructor.`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        const addrMismatchErrorMsg = `${errorMsgPrefix} was initialized with FHEVM contract addresses that do not match the currently deployed FHEVM contracts. This is likely due to incorrect addresses in the file ${configFile}`;
        if (coprocessorConfig.ACLAddress !== expectedACLAddress) {
            const errorMsg = `Coprocessor ACL address mismatch. ${addrMismatchErrorMsg}. ACL address: ${coprocessorConfig.ACLAddress}, expected ACL address: ${expectedACLAddress}`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        if (coprocessorConfig.CoprocessorAddress !== expectedFHEVMExecutorAddress) {
            const errorMsg = `Coprocessor FHEVMExecutor address mismatch. ${addrMismatchErrorMsg}. FHEVMExecutor address: ${coprocessorConfig.CoprocessorAddress}, expected FHEVMExecutor address: ${expectedFHEVMExecutorAddress}`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        if (coprocessorConfig.DecryptionOracleAddress !== expectedDecryptionOracleAddress) {
            const errorMsg = `Coprocessor DecryptionOracle address mismatch. ${addrMismatchErrorMsg}. DecryptionOracle address: ${coprocessorConfig.DecryptionOracleAddress}, expected DecryptionOracle address: ${expectedDecryptionOracleAddress}`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
        if (coprocessorConfig.KMSVerifierAddress !== expectedKMSVerifierAddress) {
            const errorMsg = `Coprocessor KMSVerifier address mismatch. ${addrMismatchErrorMsg}. KMSVerifier address: ${coprocessorConfig.KMSVerifierAddress}, expected KMSVerifier address: ${expectedKMSVerifierAddress}`;
            throw new error_1.HardhatFhevmError(errorMsg);
        }
    }
}
exports.FhevmExternalAPI = FhevmExternalAPI;
//# sourceMappingURL=FhevmExternalAPI.js.map