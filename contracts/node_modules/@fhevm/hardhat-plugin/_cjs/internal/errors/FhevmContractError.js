"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFhevmError = parseFhevmError;
exports.mutateErrorInPlace = mutateErrorInPlace;
exports.mutateProviderErrorInPlace = mutateProviderErrorInPlace;
const mock_utils_1 = require("@fhevm/mock-utils");
const ethers_1 = require("ethers");
const errors_1 = require("hardhat/internal/core/providers/errors");
const error_1 = require("../error");
const ethers_2 = require("../utils/ethers");
const log_1 = require("../utils/log");
const FhevmContractErrorList_1 = require("./FhevmContractErrorList");
function formatInputVerifierErrorMessages(error) {
    let shortMessage = "";
    let longMessage = "";
    if (!error.inputContractAddress || !error.txContractAddress || !error.inputUserAddress || !error.txUserAddress) {
        shortMessage = `The transaction's contract address or signer account differs from the ones originally used to create the encrypted input. Please ensure they match to avoid encryption errors.`;
        longMessage = `You created an encrypted input using createEncryptedInput() with a specific 
contract address and user address.

However, you're now attempting to use this encrypted input in a contract 
transaction involving a different contract address and/or signing account.

Encrypted inputs are bound to both the contract and the user they were 
created for. To ensure proper encryption and execution, the same contract 
address and user address must be used.

For example:
------------
  const input = hre.fhevm.createEncryptedInput(fooContract.target, barAccount);
  await fooContract.connect(barAccount).someFunc(<input arguments>);
`;
    }
    else {
        if (error.inputContractAddress !== error.txContractAddress &&
            error.inputContractAddress &&
            error.txContractAddress) {
            shortMessage += `- contractAddress mismatch. 
  Calling contract ${error.txContractAddress} differs from 
  encrypted input contract address ${error.inputContractAddress}.\n`;
        }
        if (error.inputUserAddress !== error.txUserAddress && error.inputUserAddress && error.txUserAddress) {
            shortMessage += `- userAddress mismatch. 
  Calling account ${error.txContractAddress} differs from 
  encrypted input user address ${error.inputContractAddress}.\n`;
        }
        longMessage = `You created an encrypted input using createEncryptedInput() with contract
address ${error.inputContractAddress} and user address
${error.inputUserAddress}.

However, you are now trying to use this encrypted input in a contract
transaction with contract address ${error.txContractAddress}
and signing account ${error.txUserAddress}.

Please ensure that the encrypted input is used with the same contract and
user address it was created for.

Error:
${shortMessage}

For example:
------------
  const input = hre.fhevm.createEncryptedInput(fooContract.target, barAccount);
  await fooContract.connect(barAccount).someFunc(<input arguments>);
`;
    }
    error.shortMessage = shortMessage;
    error.longMessage = longMessage;
    return error;
}
async function parseFhevmError(fhevmEnv, e, options) {
    const errData = (0, ethers_2.extractEVMErrorData)(e);
    if (!errData) {
        return undefined;
    }
    const tx = await fhevmEnv.mockProvider.readonlyEthersProvider.getTransaction(errData.txHash);
    const txFrom = tx ? tx.from : undefined;
    const txContract = tx && tx.to ? tx.to : undefined;
    const kmsVerifierError = fhevmEnv.getKMSVerifierReadOnly().interface.parseError(errData.data);
    if (kmsVerifierError) {
        return undefined;
    }
    const aclError = fhevmEnv.getACLReadOnly().interface.parseError(errData.data);
    if (aclError) {
        return undefined;
    }
    const execError = fhevmEnv.getFHEVMExecutorReadOnly().interface.parseError(errData.data);
    if (execError) {
        return undefined;
    }
    const inputVerifierError = fhevmEnv.getInputVerifierReadOnly().interface.parseError(errData.data);
    if (inputVerifierError) {
        if (inputVerifierError.name === "InvalidSigner") {
            const err = {
                type: "InputVerifier",
                name: "InvalidSigner",
                ...(txContract && { txContractAddress: txContract }),
                ...(txFrom && { txUserAddress: txFrom }),
                shortMessage: "",
                longMessage: "",
            };
            if (options?.encryptedInput instanceof mock_utils_1.MockRelayerEncryptedInput) {
                err.inputContractAddress = options.encryptedInput.contractAddress;
                err.inputUserAddress = options.encryptedInput.userAddress;
            }
            return formatInputVerifierErrorMessages(err);
        }
    }
    return undefined;
}
function _hasBytesLikeData(e) {
    return e instanceof Error && "data" in e && typeof e.data === "string" && ethers_1.ethers.isBytesLike(e.data);
}
function _hasStackString(e) {
    return e instanceof Error && "stack" in e && typeof e.stack === "string";
}
function _parseEdrError(fhevmEnv, e) {
    if (!(e instanceof Error)) {
        return undefined;
    }
    if (!_hasBytesLikeData(e)) {
        return undefined;
    }
    if (!_hasStackString(e)) {
        return undefined;
    }
    const dataBytesLike = e.data;
    if (!("stackTrace" in e)) {
        return undefined;
    }
    const stackTrace = e.stackTrace;
    if (!(stackTrace && Array.isArray(stackTrace) && stackTrace.length > 0)) {
        return undefined;
    }
    const lastCall = stackTrace[stackTrace.length - 1];
    if (!("address" in lastCall)) {
        return undefined;
    }
    const addr = lastCall.address;
    if (!ethers_1.ethers.isBytesLike(addr)) {
        return undefined;
    }
    const lastCallContractAddress = ethers_1.ethers.toBeHex(ethers_1.ethers.toBigInt(addr));
    if (!ethers_1.ethers.isAddress(lastCallContractAddress)) {
        return undefined;
    }
    const fhevmContractEntry = fhevmEnv
        .getContractsRepository()
        .getContractFromAddress(lastCallContractAddress)?.properties;
    if (!fhevmContractEntry) {
        return undefined;
    }
    const errorDesc = fhevmContractEntry.contract.interface.parseError(dataBytesLike);
    if (!errorDesc) {
        return undefined;
    }
    const expectedMessage = `VM Exception while processing transaction: reverted with an unrecognized custom error (return data: ${e.data})`;
    if (e.message !== expectedMessage) {
        return undefined;
    }
    if (!e.stack.startsWith("Error: " + expectedMessage)) {
        return undefined;
    }
    return { e, fhevmContractEntry, errorDesc, dataBytesLike };
}
async function mutateErrorInPlace(fhevmEnv, e, args) {
    const parsedErr = _parseEdrError(fhevmEnv, e);
    if (!parsedErr) {
        return;
    }
    (0, error_1.assertHHFhevm)(e === parsedErr.e);
    const err = parsedErr.e;
    if (!(args.params && Array.isArray(args.params) && args.params.length === 1)) {
        return;
    }
    const tx = args.params[0];
    if (!("from" in tx && typeof tx.from === "string" && ethers_1.ethers.isAddress(tx.from))) {
        return;
    }
    if (!("to" in tx && typeof tx.to === "string" && ethers_1.ethers.isAddress(tx.to))) {
        return;
    }
    err.message = `VM Exception while processing transaction: reverted with FHEVM ${parsedErr.fhevmContractEntry.contractName} custom error '${parsedErr.errorDesc.name}'`;
    await __mutateFhevmErrorAndPrintBox(fhevmEnv, err, parsedErr.dataBytesLike, undefined, tx);
    const i = err.stack.indexOf("\n");
    err.stack = "Error: " + err.message + err.stack.substring(i);
    const map = fhevmEnv.getContractsRepository().addressToContractMap();
    Object.keys(map).forEach((contractAddress) => {
        err.stack = err.stack?.replaceAll(`at <UnrecognizedContract>.<unknown> (${contractAddress})`, `at ${map[contractAddress].name}.<unknown> (${contractAddress}, ${map[contractAddress].package}/contracts/${map[contractAddress].name}.sol:0:0)`);
    });
}
async function mutateProviderErrorInPlace(fhevmEnv, e, txFromTo) {
    if (!errors_1.ProviderError.isProviderError(e)) {
        return;
    }
    if (!("data" in e)) {
        return;
    }
    if (e.data === undefined || e.data === null) {
        return;
    }
    let dataBytesLike;
    let txHash = undefined;
    if (typeof e.data === "string") {
        dataBytesLike = e.data;
    }
    else {
        if (typeof e.data !== "object") {
            return;
        }
        const providerErrorData = e.data;
        if (!("message" in providerErrorData && "txHash" in providerErrorData && "data" in providerErrorData)) {
            return;
        }
        if (typeof providerErrorData.data !== "string" ||
            typeof providerErrorData.message !== "string" ||
            typeof providerErrorData.txHash !== "string") {
            return;
        }
        dataBytesLike = providerErrorData.data;
        if (!(ethers_1.ethers.isBytesLike(dataBytesLike) && ethers_1.ethers.isHexString(providerErrorData.txHash))) {
            return;
        }
        if (providerErrorData.message !==
            `Error: VM Exception while processing transaction: reverted with an unrecognized custom error (return data: ${providerErrorData.data})`) {
            return;
        }
        txHash = providerErrorData.txHash;
    }
    await __mutateFhevmErrorAndPrintBox(fhevmEnv, e, dataBytesLike, txHash, txFromTo);
}
async function __mutateFhevmErrorAndPrintBox(fhevmEnv, e, dataBytesLike, txHash, txFromTo) {
    const msgs = await __formatFhevmErrorMessages(fhevmEnv, dataBytesLike, txHash, txFromTo);
    if (!msgs) {
        return;
    }
    e.message = msgs.message;
    const showErrorBox = fhevmEnv.hre.hardhatArguments.verbose;
    if (msgs && showErrorBox && msgs.title && msgs.longMessage) {
        (0, log_1.logBox)(msgs.title, msgs.longMessage, { titleColor: "yellow", textColor: "red", out: "stderr" });
    }
}
async function __formatFhevmErrorMessages(fhevmEnv, dataBytesLike, txHash, txFromTo) {
    const map = fhevmEnv.getContractsRepository().addressToContractMap();
    const res = [];
    Object.keys(map).forEach((contractAddress) => {
        try {
            const errorDesc = map[contractAddress].interface.parseError(dataBytesLike);
            if (errorDesc) {
                res.push({
                    contractWrapper: map[contractAddress],
                    errorDesc,
                });
            }
        }
        catch {
        }
    });
    if (res.length !== 1) {
        return undefined;
    }
    const resolvedTx = {};
    if (txHash) {
        const _tx = await fhevmEnv.mockProvider.readonlyEthersProvider.getTransaction(txHash);
        if (_tx?.from) {
            resolvedTx.from = _tx.from;
        }
        if (_tx?.to) {
            resolvedTx.to = _tx.to;
        }
    }
    else {
        if (txFromTo?.from) {
            resolvedTx.from = txFromTo.from;
        }
        if (txFromTo?.to) {
            resolvedTx.to = txFromTo.to;
        }
    }
    if (resolvedTx.from) {
        resolvedTx.from = ethers_1.ethers.getAddress(resolvedTx.from);
    }
    if (resolvedTx.to) {
        resolvedTx.to = ethers_1.ethers.getAddress(resolvedTx.to);
    }
    let msgs = undefined;
    const info = res[0];
    switch (info.contractWrapper.name) {
        case "ACL": {
            msgs = _formatACLErrorMessages({ ...info, tx: resolvedTx });
            break;
        }
        case "FHEVMExecutor": {
            msgs = _formatFHEVMExecutorErrorMessages({ ...info, tx: resolvedTx });
            break;
        }
        case "InputVerifier": {
            msgs = _formatInputVerifierErrorMessages({ ...info, tx: resolvedTx });
            break;
        }
        case "KMSVerifier": {
            msgs = _formatKMSVerifierErrorMessages({ ...info, tx: resolvedTx });
            break;
        }
        case "HCULimit": {
            msgs = _formatHCULimitErrorMessages({ ...info, tx: resolvedTx });
            break;
        }
        case "DecryptionOracle": {
            msgs = _formatDecryptionOracleErrorMessages({ ...info, tx: resolvedTx });
            break;
        }
        default: {
            break;
        }
    }
    return msgs;
}
function _formatACLErrorMessages(infos) {
    let values = undefined;
    switch (infos.errorDesc.name) {
        case "SenderNotAllowed": {
            values = {
                address: infos.errorDesc.args[0],
            };
            break;
        }
    }
    return _applyErrorTemplates(infos, values);
}
function _formatFHEVMExecutorErrorMessages(infos) {
    const abiError = infos.contractWrapper.interface.getError(infos.errorDesc.name);
    let values = undefined;
    if (abiError) {
        const inputs = abiError.inputs;
        (0, error_1.assertHHFhevm)(inputs.length === infos.errorDesc.args.length);
        if (inputs.length > 0) {
            values = {};
            for (let i = 0; i < inputs.length; ++i) {
                values[inputs[i].name] = infos.errorDesc.args[i];
            }
        }
    }
    return _applyErrorTemplates(infos, values);
}
function _formatInputVerifierErrorMessages(infos) {
    switch (infos.errorDesc.name) {
        case "InvalidSigner": {
            const msgs = formatInputVerifierInvalidSignerErrorMessages(infos);
            return { ...msgs, message: `${msgs.title}: ${msgs.shortMessage}` };
        }
        default: {
            return {
                message: `VM Exception while processing transaction: reverted with FHEVM ${infos.contractWrapper.name} custom error '${infos.errorDesc.name}'`,
            };
        }
    }
}
function _formatKMSVerifierErrorMessages(infos) {
    return _applyErrorTemplates(infos);
}
function _formatHCULimitErrorMessages(infos) {
    return _applyErrorTemplates(infos);
}
function _formatDecryptionOracleErrorMessages(infos) {
    return _applyErrorTemplates(infos);
}
function formatInputVerifierInvalidSignerErrorMessages(infos) {
    let shortMessage = "";
    let longMessage = "";
    const txContractAddress = infos.tx?.to;
    const txUserAddress = infos.tx?.from;
    if (txContractAddress && txUserAddress) {
        shortMessage = (0, FhevmContractErrorList_1.applyErrorTemplate)(FhevmContractErrorList_1.ERRORS.InputVerifier.InvalidSigner.shortMessage, {
            txContractAddress,
            txUserAddress,
        });
        longMessage = (0, FhevmContractErrorList_1.applyErrorTemplate)(FhevmContractErrorList_1.ERRORS.InputVerifier.InvalidSigner.longMessage, {
            txContractAddress,
            txUserAddress,
        });
    }
    return { title: FhevmContractErrorList_1.ERRORS.InputVerifier.InvalidSigner.title, shortMessage, longMessage };
}
function _applyErrorTemplates(infos, values) {
    let shortMessage = undefined;
    let longMessage = undefined;
    let title = undefined;
    let message = (0, FhevmContractErrorList_1.applyErrorTemplate)(FhevmContractErrorList_1.ERRORS.CustomError.default, { customError: `${infos.errorDesc.name}()` });
    if (infos.contractWrapper.name in FhevmContractErrorList_1.ERRORS) {
        const error = FhevmContractErrorList_1.ERRORS[infos.contractWrapper.name];
        if (infos.errorDesc.name in error) {
            const templates = error[infos.errorDesc.name];
            if ("shortMessage" in templates && typeof templates.shortMessage === "string") {
                shortMessage = (0, FhevmContractErrorList_1.applyErrorTemplate)(templates.shortMessage, values);
            }
            if ("longMessage" in templates && typeof templates.longMessage === "string") {
                longMessage = (0, FhevmContractErrorList_1.applyErrorTemplate)(templates.longMessage, values);
            }
            if ("title" in templates && typeof templates.title === "string") {
                title = (0, FhevmContractErrorList_1.applyErrorTemplate)(templates.title, values);
            }
            if ("message" in templates && typeof templates.message === "string") {
                message = (0, FhevmContractErrorList_1.applyErrorTemplate)(templates.message, values);
            }
            else if (title && shortMessage) {
                message = `${title}: ${shortMessage}`;
            }
        }
    }
    return {
        message,
        ...(title && { title }),
        ...(shortMessage && { shortMessage }),
        ...(longMessage && { longMessage }),
    };
}
//# sourceMappingURL=FhevmContractError.js.map