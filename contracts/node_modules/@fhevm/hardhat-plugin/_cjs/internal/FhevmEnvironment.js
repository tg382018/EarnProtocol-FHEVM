"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FhevmEnvironment = void 0;
const mock_utils_1 = require("@fhevm/mock-utils");
const node_1 = require("@zama-fhe/relayer-sdk/node");
const debug_1 = __importDefault(require("debug"));
const ethers_1 = require("ethers");
const path = __importStar(require("path"));
const error_1 = require("../error");
const task_names_1 = require("../task-names");
const FhevmDebugger_1 = require("./FhevmDebugger");
const FhevmEnvironmentPaths_1 = require("./FhevmEnvironmentPaths");
const FhevmExternalAPI_1 = require("./FhevmExternalAPI");
const constants_1 = __importDefault(require("./constants"));
const PrecompiledFhevmCoreContracts_1 = require("./deploy/PrecompiledFhevmCoreContracts");
const ZamaConfigDotSol_1 = require("./deploy/ZamaConfigDotSol");
const ZamaOracleAddressDotSol_1 = require("./deploy/ZamaOracleAddressDotSol");
const addresses_1 = require("./deploy/addresses");
const setup_1 = require("./deploy/setup");
const error_2 = require("./error");
const hh_1 = require("./utils/hh");
const debugProvider = (0, debug_1.default)("@fhevm/hardhat:provider");
const debugInstance = (0, debug_1.default)("@fhevm/hardhat:instance");
class FhevmEnvironment {
    constructor(hre) {
        Object.defineProperty(this, "_hre", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_runningInHHNode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_runningInHHTest", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_runningInHHFHEVMInstallSolidity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_paths", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_deployRunning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_deployCompleted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_cliAPIInitializing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_cliAPIInitialized", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_setupAddressesRunning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_setupAddressesCompleted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_addresses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_fhevmMockProvider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_minimalInitPromise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_initializeCLIApiPromise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_contractsRepository", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_instance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_fhevmAPI", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_fhevmDebugger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_mockDecryptionOracle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_mockCoprocessor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_relayerSignerAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: -1
        });
        FhevmEnvironment._idCount++;
        this._id = FhevmEnvironment._idCount;
        this._hre = hre;
        this._fhevmAPI = new FhevmExternalAPI_1.FhevmExternalAPI(this);
        this._fhevmDebugger = new FhevmDebugger_1.FhevmDebugger(this);
        this._paths = new FhevmEnvironmentPaths_1.FhevmEnvironmentPaths(hre.config.paths.root);
        (0, hh_1.checkHardhatRuntimeEnvironment)(hre);
    }
    setRunningInHHFHEVMInstallSolidity() {
        (0, error_2.assertHHFhevm)(this._hre.network.name === "hardhat", `Expecting network 'hardhat'. Got '${this._hre.network.name}' instead.`);
        if (this._runningInHHFHEVMInstallSolidity !== undefined) {
            throw new error_1.HardhatFhevmError(`The fhevm hardhat plugin is already running inside a 'hardhat ${task_names_1.SCOPE_FHEVM} ${task_names_1.SCOPE_FHEVM_TASK_INSTALL_SOLIDITY}' command.`);
        }
        this._runningInHHFHEVMInstallSolidity = true;
    }
    unsetRunningInHHFHEVMInstallSolidity() {
        (0, error_2.assertHHFhevm)(this._hre.network.name === "hardhat", `Expecting network 'hardhat'. Got '${this._hre.network.name}' instead.`);
        if (this._runningInHHFHEVMInstallSolidity !== true) {
            throw new error_1.HardhatFhevmError(`The fhevm hardhat plugin is not running inside a 'hardhat ${task_names_1.SCOPE_FHEVM} ${task_names_1.SCOPE_FHEVM_TASK_INSTALL_SOLIDITY}' command.`);
        }
        this._runningInHHFHEVMInstallSolidity = undefined;
    }
    setRunningInHHTest() {
        if (this._runningInHHTest !== undefined) {
            throw new error_1.HardhatFhevmError(`The fhevm hardhat plugin is already running inside a hardhat test command.`);
        }
        if (this._runningInHHNode !== undefined) {
            throw new error_1.HardhatFhevmError(`The fhevm hardhat plugin is already running inside a hardhat node command.`);
        }
        this._runningInHHTest = true;
    }
    setRunningInHHNode() {
        (0, error_2.assertHHFhevm)(this._hre.network.name === "hardhat", `Expecting network 'hardhat'. Got '${this._hre.network.name}' instead.`);
        if (this._runningInHHTest !== undefined) {
            throw new error_1.HardhatFhevmError(`The fhevm hardhat plugin is already running inside a hardhat test command.`);
        }
        if (this._runningInHHNode !== undefined) {
            throw new error_1.HardhatFhevmError(`The fhevm hardhat plugin is already running inside a hardhat node command.`);
        }
        this._runningInHHNode = true;
    }
    get isRunningInHHTest() {
        return this._runningInHHTest === true;
    }
    get isRunningInHHNode() {
        return this._runningInHHNode === true;
    }
    get isRunningInHHFHEVMInstallSolidity() {
        return this._runningInHHFHEVMInstallSolidity === true;
    }
    get useEmbeddedMockEngine() {
        return this.mockProvider.info.type !== mock_utils_1.FhevmMockProviderType.HardhatNode;
    }
    get hre() {
        if (!this._hre) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._hre;
    }
    get relayerProvider() {
        return this.hre.ethers.provider;
    }
    get readonlyEthersProvider() {
        return this.hre.ethers.provider;
    }
    get readonlyEip1193Provider() {
        return this.hre.network.provider;
    }
    get mockProvider() {
        if (!this._fhevmMockProvider) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._fhevmMockProvider;
    }
    get paths() {
        return this._paths;
    }
    get debugger() {
        if (!this._fhevmDebugger) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._fhevmDebugger;
    }
    get coprocessor() {
        if (!this._mockCoprocessor) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._mockCoprocessor;
    }
    get decryptionOracle() {
        if (!this._mockDecryptionOracle) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._mockDecryptionOracle;
    }
    getInstanceOrUndefined() {
        return this._instance;
    }
    get instance() {
        if (!this._instance) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._instance;
    }
    getACLAddress() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.acl.address;
    }
    getFHEVMExecutorAddress() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.fhevmExecutor.address;
    }
    getInputVerifierAddress() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository?.inputVerifier.address;
    }
    getKMSVerifierAddress() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.kmsVerifier.address;
    }
    getDecryptionOracleAddress() {
        if (!this._contractsRepository || !this._contractsRepository.zamaFheDecryptionOracle) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.zamaFheDecryptionOracle.address;
    }
    getGatewayInputVerificationAddress() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.inputVerifier.gatewayInputVerificationAddress;
    }
    getGatewayDecryptionAddress() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.kmsVerifier.gatewayDecryptionAddress;
    }
    getACLReadOnly() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.acl.readonlyContract;
    }
    getFHEVMExecutorReadOnly() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.fhevmExecutor.readonlyContract;
    }
    getInputVerifierReadOnly() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.inputVerifier.readonlyContract;
    }
    getDecryptionOracleReadOnly() {
        if (!this._contractsRepository || !this._contractsRepository.zamaFheDecryptionOracle) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository?.zamaFheDecryptionOracle.readonlyContract;
    }
    getKMSVerifierReadOnly() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository.kmsVerifier.readonlyContract;
    }
    getGatewayChainId() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return Number(this._contractsRepository.kmsVerifier.gatewayChainId);
    }
    get chainId() {
        if (!this._fhevmMockProvider) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._fhevmMockProvider.chainId;
    }
    getRelayerSignerAddress() {
        if (!this._relayerSignerAddress) {
            throw new error_1.HardhatFhevmError(`Relayer signer address is not defined. Ensure that the Fhevm environment has been properly initialized by calling runSetup() (${this._id}/${FhevmEnvironment._idCount})`);
        }
        return this._relayerSignerAddress;
    }
    get externalFhevmAPI() {
        if (this.isRunningInHHNode) {
            throw new error_1.HardhatFhevmError(`the HardhatFhevmRuntimeEnvironment 'fhevm' is not accessible from the 'hardhat node' server`);
        }
        return this._fhevmAPI;
    }
    getContractsRepository() {
        if (!this._contractsRepository) {
            throw new error_1.HardhatFhevmError(`The Hardhat Fhevm plugin is not initialized.`);
        }
        return this._contractsRepository;
    }
    get isDeployed() {
        return this._deployCompleted;
    }
    async initializeCLIApi() {
        if (this._initializeCLIApiPromise !== undefined) {
            return this._initializeCLIApiPromise;
        }
        this._initializeCLIApiPromise = (async () => {
            try {
                await this.__initializeCLIApi();
            }
            finally {
                this._initializeCLIApiPromise = undefined;
            }
        })();
        return this._initializeCLIApiPromise;
    }
    async __initializeCLIApi() {
        if (this._cliAPIInitialized) {
            return;
        }
        if (this._cliAPIInitializing) {
            throw new error_1.HardhatFhevmError(`The Fhevm CLI initialization is already in progress.`);
        }
        this._cliAPIInitializing = true;
        try {
            if (this.isDeployed) {
                return;
            }
            if (this.hre.network.name === "hardhat") {
                throw new error_1.HardhatFhevmError(`The Fhevm CLI only supports the Hardhat Node (--network localhost) or Sepolia (--network sepolia) networks.`);
            }
            await this.minimalInit();
            if (this.mockProvider.info.type !== mock_utils_1.FhevmMockProviderType.HardhatNode &&
                this.mockProvider.info.type !== mock_utils_1.FhevmMockProviderType.SepoliaEthereum) {
                throw new error_1.HardhatFhevmError(`The Fhevm CLI only supports the Hardhat Node (--network localhost) or Sepolia (--network sepolia) networks.`);
            }
            await this.deploy();
            this._cliAPIInitialized = true;
        }
        finally {
            this._cliAPIInitializing = false;
        }
    }
    async deploy() {
        if (this._deployCompleted) {
            throw new error_1.HardhatFhevmError("The Fhevm environment is already initialized.");
        }
        if (this._deployRunning) {
            throw new error_1.HardhatFhevmError(`The Fhevm environment initialization is already in progress.`);
        }
        this._deployRunning = true;
        try {
            await this._deployCore();
            this._deployCompleted = true;
        }
        finally {
            this._deployRunning = false;
        }
    }
    _guessDefaultProvider() {
        const url = "url" in this.hre.network.config ? this.hre.network.config.url : undefined;
        if (this.hre.network.name === "hardhat") {
            (0, error_2.assertHHFhevm)(url === undefined);
            return {
                networkName: this.hre.network.name,
                type: mock_utils_1.FhevmMockProviderType.Hardhat,
                chainId: this.hre.network.config.chainId,
                url,
            };
        }
        if (!url) {
            throw new error_1.HardhatFhevmError(`Missing network url`);
        }
        const urlObj = new URL(url);
        if (this.hre.network.name === "localhost") {
            (0, error_2.assertHHFhevm)(urlObj.port === "8545");
            return {
                networkName: "localhost",
                type: mock_utils_1.FhevmMockProviderType.HardhatNode,
                chainId: 31337,
                url,
            };
        }
        if (this.hre.network.name === "anvil") {
            return {
                networkName: this.hre.network.name,
                type: mock_utils_1.FhevmMockProviderType.Anvil,
                chainId: this.hre.network.config.chainId,
                url,
            };
        }
        return {
            networkName: this.hre.network.name,
            type: mock_utils_1.FhevmMockProviderType.Unknown,
            chainId: this.hre.network.config.chainId,
            url,
        };
    }
    async __minimalInit() {
        if (this._fhevmMockProvider === undefined) {
            const defaults = this._guessDefaultProvider();
            debugProvider("Resolving provider...");
            this._fhevmMockProvider = await mock_utils_1.FhevmMockProvider.fromReadonlyProvider(this.hre.ethers.provider, this.hre.network.name, defaults.type, defaults.chainId, defaults.url);
            debugProvider(`Provider name: ${this._fhevmMockProvider.info.networkName} chainId: ${this._fhevmMockProvider.info.chainId} type: ${this._fhevmMockProvider.info.type}`);
        }
    }
    async minimalInit() {
        if (this._minimalInitPromise !== undefined) {
            return this._minimalInitPromise;
        }
        this._minimalInitPromise = (async () => {
            try {
                await this.__minimalInit();
            }
            finally {
                this._minimalInitPromise = undefined;
            }
        })();
        return this._minimalInitPromise;
    }
    async _createSigners() {
        const kmsSigners = await (0, addresses_1.loadKMSSigners)(this.hre, this.mockProvider.readonlyEthersProvider);
        const coprocessorSigners = await (0, addresses_1.loadCoprocessorSigners)(this.hre, this.mockProvider.readonlyEthersProvider);
        const oneAddress = "0x0000000000000000000000000000000000000001";
        const balance = ethers_1.ethers.parseEther("10000");
        let zero = await this.mockProvider.impersonateAddressAndSetBalance(ethers_1.ethers.ZeroAddress, balance);
        if (zero === undefined) {
            zero = await this.hre.ethers.getSigner(ethers_1.ethers.ZeroAddress);
        }
        let one = await this.mockProvider.impersonateAddressAndSetBalance(oneAddress, balance);
        if (one === undefined) {
            one = await this.hre.ethers.getSigner(oneAddress);
        }
        return {
            coprocessor: coprocessorSigners,
            kms: kmsSigners,
            oneAddress,
            zeroAddress: ethers_1.ethers.ZeroAddress,
            zero,
            one,
        };
    }
    async _deployCore() {
        await this.minimalInit();
        if (!this.mockProvider.isMock && !this.mockProvider.isSepoliaEthereum) {
            throw new error_1.HardhatFhevmError("The current version of the fhevm hardhat plugin only supports the 'hardhat' network, 'localhost' hardhat node, anvil or sepolia.");
        }
        const fhevmAddresses = await this.initializeAddresses(false);
        if (!this.mockProvider.isSepoliaEthereum) {
            const fhevmSigners = await this._createSigners();
            let coprocessorSigners;
            let kmsSigners;
            await this.mockProvider.setTemporaryMinimumBlockGasLimit(0x1fffffffffffffn);
            try {
                const setup = await (0, setup_1.setupMockUsingCoreContractsArtifacts)(this.mockProvider, fhevmAddresses, fhevmSigners, this.paths);
                this._contractsRepository = setup.contracts;
                coprocessorSigners = setup.coprocessorSigners;
                kmsSigners = setup.kmsSigners;
            }
            finally {
                await this.mockProvider.unsetTemporaryMinimumBlockGasLimit();
            }
            if (this.useEmbeddedMockEngine) {
                const readonlyEthersProvider = this.mockProvider.readonlyEthersProvider;
                if (!readonlyEthersProvider) {
                    throw new error_1.HardhatFhevmError(`Missing ethers.Provider. The FhevmMockProvider instance does not have a valid ethers.Provider.`);
                }
                const blockNumber = await this.mockProvider.getBlockNumber();
                const db = new mock_utils_1.FhevmDBMap();
                await db.init(blockNumber);
                this._relayerSignerAddress = await (0, addresses_1.getRelayerSignerAddress)(this.hre);
                const relayerSigner = await (0, addresses_1.getRelayerSigner)(this.hre);
                this._mockCoprocessor = await mock_utils_1.MockCoprocessor.create(readonlyEthersProvider, {
                    coprocessorContractAddress: this.getFHEVMExecutorAddress(),
                    coprocessorSigners,
                    inputVerifierContractAddress: this.getInputVerifierAddress(),
                    db,
                });
                this._mockDecryptionOracle = await mock_utils_1.MockDecryptionOracle.create(readonlyEthersProvider, {
                    decryptionOracleContractAddress: this.getDecryptionOracleAddress(),
                    aclContractAddress: this.getACLAddress(),
                    kmsVerifierContractAddress: this.getKMSVerifierAddress(),
                    coprocessor: this._mockCoprocessor,
                    kmsSigners,
                    relayerSigner,
                });
            }
        }
        else {
            const repo = await mock_utils_1.contracts.FhevmContractsRepository.create(this.readonlyEthersProvider, {
                aclContractAddress: fhevmAddresses.CoprocessorConfig.ACLAddress,
                kmsContractAddress: fhevmAddresses.CoprocessorConfig.KMSVerifierAddress,
            });
            this._contractsRepository = repo;
        }
        if (!this.isRunningInHHNode) {
            this._instance = await this.createInstance();
        }
    }
    async createInstance() {
        (0, error_2.assertHHFhevm)(!this.isRunningInHHNode, "Cannot create a MockFhevmInstance object in the 'hardhat node' server");
        if (this.mockProvider.isMock) {
            return mock_utils_1.MockFhevmInstance.create(this.hre.ethers.provider, this.hre.ethers.provider, {
                verifyingContractAddressDecryption: this.getGatewayDecryptionAddress(),
                verifyingContractAddressInputVerification: this.getGatewayInputVerificationAddress(),
                kmsContractAddress: this.getKMSVerifierAddress(),
                inputVerifierContractAddress: this.getInputVerifierAddress(),
                aclContractAddress: this.getACLAddress(),
                chainId: this.chainId,
                gatewayChainId: this.getGatewayChainId(),
            });
        }
        else if (this.mockProvider.isSepoliaEthereum) {
            debugInstance("Creating @zama-fhe/relayer-sdk instance (might take some time)...");
            const instance = await (0, node_1.createInstance)({
                ...this.getContractsRepository().getFhevmInstanceConfig({
                    chainId: this.mockProvider.chainId,
                    relayerUrl: constants_1.default.SEPOLIA.relayerUrl,
                }),
                network: this.hre.network.provider,
            });
            debugInstance("@zama-fhe/relayer-sdk instance created.");
            return instance;
        }
        else {
            throw new error_1.HardhatFhevmError(`Unsupported network.`);
        }
    }
    async initializeAddresses(ignoreCache) {
        if (this._addresses !== undefined) {
            return this._addresses;
        }
        if (this._setupAddressesCompleted) {
            throw new error_1.HardhatFhevmError("The Fhevm environment addresses are already initialized.");
        }
        if (this._setupAddressesRunning) {
            throw new error_1.HardhatFhevmError("The Fhevm environment addresses are already being initialized.");
        }
        this._setupAddressesRunning = true;
        {
            let addresses;
            if (this.mockProvider.isSepoliaEthereum) {
                addresses = await this._initializeAddressesCoreSepolia();
            }
            else {
                addresses = await this._initializeAddressesCoreMock(ignoreCache);
            }
            Object.freeze(addresses);
            Object.freeze(addresses.CoprocessorConfig);
            this._addresses = addresses;
        }
        this._setupAddressesCompleted = true;
        this._setupAddressesRunning = false;
        return this._addresses;
    }
    async _initializeAddressesCoreSepolia() {
        const sepoliaCoprocessorConfig = {
            ACLAddress: constants_1.default.SEPOLIA.ACLAddress,
            CoprocessorAddress: constants_1.default.SEPOLIA.CoprocessorAddress,
            DecryptionOracleAddress: constants_1.default.SEPOLIA.DecryptionOracleAddress,
            KMSVerifierAddress: constants_1.default.SEPOLIA.KMSVerifierAddress,
        };
        const coprocessorConfigDotSolPath = (0, ZamaConfigDotSol_1.generateZamaConfigDotSol)(this.paths, sepoliaCoprocessorConfig);
        const zamaOracleAddressDotSolPath = (0, ZamaOracleAddressDotSol_1.generateZamaOracleAddressDotSol)(this.paths, constants_1.default.SEPOLIA.DecryptionOracleAddress);
        (0, error_2.assertHHFhevm)(path.isAbsolute(coprocessorConfigDotSolPath));
        (0, error_2.assertHHFhevm)(path.isAbsolute(zamaOracleAddressDotSolPath));
        return {
            CoprocessorConfig: sepoliaCoprocessorConfig,
            InputVerifierAddress: constants_1.default.SEPOLIA.InputVerifierAddress,
            HCULimitAddress: constants_1.default.SEPOLIA.HCULimitAddress,
            CoprocessorConfigDotSolPath: coprocessorConfigDotSolPath,
            ZamaOracleAddressDotSolPath: zamaOracleAddressDotSolPath,
        };
    }
    async _initializeAddressesCoreMock(ignoreCache) {
        const hardcodedAddresses = await (0, PrecompiledFhevmCoreContracts_1.loadPrecompiledFhevmCoreContractsAddresses)(this.mockProvider, this.paths, ignoreCache, this.isRunningInHHFHEVMInstallSolidity);
        const mockCoprocessorConfig = {
            ACLAddress: hardcodedAddresses.ACLAddress,
            CoprocessorAddress: hardcodedAddresses.CoprocessorAddress,
            DecryptionOracleAddress: constants_1.default.SEPOLIA.DecryptionOracleAddress,
            KMSVerifierAddress: constants_1.default.SEPOLIA.KMSVerifierAddress,
        };
        const coprocessorConfigDotSolPath = (0, ZamaConfigDotSol_1.generateZamaConfigDotSol)(this.paths, mockCoprocessorConfig);
        const zamaOracleAddressDotSolPath = (0, ZamaOracleAddressDotSol_1.generateZamaOracleAddressDotSol)(this.paths, mockCoprocessorConfig.DecryptionOracleAddress);
        (0, error_2.assertHHFhevm)(path.isAbsolute(coprocessorConfigDotSolPath));
        (0, error_2.assertHHFhevm)(path.isAbsolute(zamaOracleAddressDotSolPath));
        return {
            CoprocessorConfig: mockCoprocessorConfig,
            InputVerifierAddress: hardcodedAddresses.InputVerifierAddress,
            HCULimitAddress: hardcodedAddresses.HCULimitAddress,
            CoprocessorConfigDotSolPath: coprocessorConfigDotSolPath,
            ZamaOracleAddressDotSolPath: zamaOracleAddressDotSolPath,
        };
    }
    getRemappings() {
        if (!this.mockProvider.isMock && !this.mockProvider.isSepoliaEthereum) {
            throw new error_1.HardhatFhevmError(`This network configuration is not yet supported by the FHEVM hardhat plugin`);
        }
        return {
            "@fhevm/solidity/config": this.paths.relCacheFhevmSolidityConfigDirUnix,
            "@zama-fhe/oracle-solidity/address": this.paths.relCacheZamaFheOracleSolidityAddressDirUnix,
        };
    }
    getSoliditySourcePaths() {
        return [];
    }
}
exports.FhevmEnvironment = FhevmEnvironment;
Object.defineProperty(FhevmEnvironment, "_idCount", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -1
});
//# sourceMappingURL=FhevmEnvironment.js.map