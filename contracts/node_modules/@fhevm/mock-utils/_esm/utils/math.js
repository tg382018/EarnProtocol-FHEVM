import { ethers as EthersT } from "ethers";
import { FhevmError, assertFhevm } from "./error.js";
export const MAX_UINT8 = 0xffn;
export const MAX_UINT16 = 0xffffn;
export const MAX_UINT32 = 0xffffffffn;
export const MAX_UINT64 = 0xffffffffffffffffn;
export const MAX_UINT128 = 0xffffffffffffffffffffffffffffffffn;
export const MAX_UINT160 = 0xffffffffffffffffffffffffffffffffffffffffn;
export const MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;
export const MAX_UINT512 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;
export function toUIntNumber(value, name) {
    try {
        const bn = EthersT.getUint(value, name);
        return EthersT.getNumber(bn);
    }
    catch {
        throw new FhevmError(`${name} is not a positive integer`);
    }
}
export function isInt(value) {
    if (typeof value === "bigint") {
        return true;
    }
    if (typeof value === "number") {
        return Number.isInteger(value);
    }
    return false;
}
export function isUInt(value) {
    if (!isInt(value)) {
        return false;
    }
    return value >= 0;
}
export function isEvenUInt(value) {
    if (!isUInt(value)) {
        return false;
    }
    return typeof value === "bigint" ? value % 2n === 0n : value % 2 === 0;
}
export function boolToBigInt(value) {
    if (value === null || value === undefined) {
        throw new FhevmError("Missing value");
    }
    let zeroOrOne = 0n;
    // Must be 0 or 1
    if (typeof value === "bigint") {
        if (value !== 1n && value !== 0n) {
            throw new FhevmError("The value must be 1 or 0.");
        }
        zeroOrOne = value;
    }
    else if (typeof value === "number") {
        if (value !== 1 && value !== 0) {
            throw new FhevmError("The value must be 1 or 0.");
        }
        zeroOrOne = value === 0 ? 0n : 1n;
    }
    else if (typeof value === "boolean") {
        zeroOrOne = value === true ? 1n : 0n;
    }
    else {
        throw new FhevmError("The value must be a boolean, a number or a bigint.");
    }
    return zeroOrOne;
}
export function bitwiseNotUIntBits(value, numBits) {
    if (typeof value !== "bigint") {
        throw new FhevmError("The input value must be a BigInt.");
    }
    if (!isUInt(numBits)) {
        throw new FhevmError("The numBits parameter must be a positive integer.");
    }
    // Create the mask with numBits bits set to 1
    const BIT_MASK = (BigInt(1) << BigInt(numBits)) - BigInt(1);
    return ~value & BIT_MASK;
}
export function getMaxBigInt(bitLength) {
    if (!isUInt(bitLength)) {
        throw new FhevmError(`Invalid bitLength argument (${bitLength}), expecting a positive integer value.`);
    }
    return (1n << BigInt(bitLength)) - 1n;
}
export function log2BigInt(x) {
    const n = x.toString(2).length - 1;
    return x <= 0n ? 0n : BigInt(n);
}
export function getRandomBigInt(numBits) {
    if (numBits <= 0) {
        throw new TypeError("Number of bits must be greater than 0");
    }
    const numBytes = Math.ceil(numBits / 8);
    const randomBytes = EthersT.randomBytes(numBytes);
    let randomBigInt = BigInt(0);
    for (let i = 0; i < numBytes; i++) {
        randomBigInt = (randomBigInt << BigInt(8)) | BigInt(randomBytes[i]);
    }
    const mask = (BigInt(1) << BigInt(numBits)) - BigInt(1);
    randomBigInt = randomBigInt & mask;
    return randomBigInt;
}
export function assertIsUintNumber(value, valueName) {
    assertFhevm(typeof value === "number", `${valueName ?? "value"} is not of type number, got ${typeof value} instead`);
    assertFhevm(isUInt(value), `${valueName ?? "value"} is not an uint, got ${typeof value} instead`);
}
/*

  BigInt assertions

*/
export function assertIsBigUint8(value, valueName) {
    _assertIsBigUint(value, 8, MAX_UINT8, valueName);
}
export function assertIsBigUint16(value, valueName) {
    _assertIsBigUint(value, 16, MAX_UINT16, valueName);
}
export function assertIsBigUint32(value, valueName) {
    _assertIsBigUint(value, 32, MAX_UINT32, valueName);
}
export function assertIsBigUint64(value, valueName) {
    _assertIsBigUint(value, 64, MAX_UINT64, valueName);
}
export function assertIsBigUint128(value, valueName) {
    _assertIsBigUint(value, 128, MAX_UINT128, valueName);
}
export function assertIsBigUint160(value, valueName) {
    _assertIsBigUint(value, 128, MAX_UINT160, valueName);
}
export function assertIsBigUint256(value, valueName) {
    _assertIsBigUint(value, 256, MAX_UINT256, valueName);
}
export function assertIsBigUint512(value, valueName) {
    _assertIsBigUint(value, 512, MAX_UINT512, valueName);
}
export function assertIsBigUint1024(value, valueName) {
    _assertIsBigUint(value, 1024, getMaxBigInt(1024), valueName);
}
export function assertIsBigUint2048(value, valueName) {
    _assertIsBigUint(value, 2048, getMaxBigInt(2048), valueName);
}
function _assertIsBigUint(value, bitLen, max, valueName) {
    assertFhevm(typeof value === "bigint", `${valueName ?? "value"} is not of type bigint, got ${typeof value} instead`);
    assertFhevm(value >= 0 && value <= max, `${valueName ?? "value"} is larger than uint${bitLen} maximum value, got ${value} > ${max}`);
}
export function assertIsBoolean(value, valueName) {
    assertFhevm(typeof value === "boolean", `${valueName ?? "value"} is not of type boolean, got ${typeof value} instead`);
}
export function assertIsNumber(value, valueName) {
    assertFhevm(typeof value === "number", `${valueName ?? "value"} is not of type number, got ${typeof value} instead`);
}
//# sourceMappingURL=math.js.map