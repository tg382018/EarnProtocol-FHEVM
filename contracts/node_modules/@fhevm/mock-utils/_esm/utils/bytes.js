import { ethers as EthersT } from "ethers";
import { assertFhevm } from "./error.js";
import { assertIsString } from "./string.js";
export function assertIsUint8Array(value, valueName) {
    assertFhevm(value instanceof Uint8Array, `${valueName ?? "value"} is not of type Uint8Array`);
}
export function assertIsBytesLike(value, valueName) {
    assertFhevm(EthersT.isBytesLike(value), `${valueName ?? "value"} is not bytes-like (expected a hex string or Uint8Array)`);
}
export function assertIsBytes32String(value, valueName) {
    assertIsBytesString(value, 32, valueName);
}
export function assertIsBytesString(value, width, valueName) {
    assertIsString(value, valueName);
    if (width === undefined) {
        assertFhevm(EthersT.isBytesLike(value), `${valueName ?? "value"} : ${value} is not a valid bytes string`);
    }
    else {
        assertFhevm(value === EthersT.toBeHex(value, width), `${valueName ?? "value"} : ${value} is not a valid bytes${width} string`);
    }
}
export function assertIsBytes1(value, valueName) {
    assertIsBytes(value, 1, valueName);
}
export function assertIsBytes8(value, valueName) {
    assertIsBytes(value, 8, valueName);
}
export function assertIsBytes20(value, valueName) {
    assertIsBytes(value, 20, valueName);
}
export function assertIsBytes32(value, valueName) {
    assertIsBytes(value, 32, valueName);
}
export function assertIsBytes(value, width, valueName) {
    assertIsUint8Array(value, valueName);
    if (width === undefined) {
        assertFhevm(EthersT.isBytesLike(value), `${valueName ?? "value"} : ${value} is not a valid bytes string`);
    }
    else {
        assertFhevm(value.length === width, `${valueName ?? "value"} : ${value} is not a valid bytes${width} Uint8Array. Expecting length ${width}, got ${value.length} instead`);
    }
}
export function bytesToBigInt(byteArray) {
    if (!byteArray || byteArray.length === 0) {
        return BigInt(0);
    }
    /*
    
      Equivalent to:
      ==============
  
      // faster: using C/C++ lib bigint-buffer
      import { toBigIntBE } from "bigint-buffer";
      // Buffer: Node only
      const buffer = Buffer.from(byteArray);
      const result = toBigIntBE(buffer);
      return new Uint8Array(toBufferBE(value, 64));
  
    */
    return EthersT.toBigInt(byteArray);
}
export function uintToBytes(value, width) {
    // May be using EthersT.toBeArray(value) is more efficient.
    return EthersT.getBytes(EthersT.toBeHex(value, width));
}
export function concatBytes(...arrays) {
    const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
//# sourceMappingURL=bytes.js.map