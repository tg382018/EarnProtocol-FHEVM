var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _KMSVerifier_kmsVerifierContract, _KMSVerifier_kmsVerifierContractAddress, _KMSVerifier_signersAddresses, _KMSVerifier_threshold, _KMSVerifier_eip712Domain;
import { ethers as EthersT } from "ethers";
import constants from "../../constants.js";
import { multiSignEIP712 } from "../../ethers/eip712.js";
import { assertIsAddress, assertIsAddressArray } from "../../utils/address.js";
import { assertIsBytes32String } from "../../utils/bytes.js";
import { FhevmError, assertFhevm, assertIsArray } from "../../utils/error.js";
import { assertIsBigUint8, assertIsBigUint256 } from "../../utils/math.js";
import { assertIsString } from "../../utils/string.js";
import { FhevmHandle } from "../FhevmHandle.js";
import { FhevmType } from "../FhevmType.js";
import { FhevmCoprocessorContractWrapper } from "./FhevmContractWrapper.js";
import { KMSVerifierPartialInterface } from "./interfaces/KMSVerifier.itf.js";
// Shareable
export class KMSVerifier extends FhevmCoprocessorContractWrapper {
    constructor() {
        super("KMSVerifier");
        _KMSVerifier_kmsVerifierContract.set(this, void 0);
        _KMSVerifier_kmsVerifierContractAddress.set(this, void 0);
        _KMSVerifier_signersAddresses.set(this, void 0);
        _KMSVerifier_threshold.set(this, void 0);
        _KMSVerifier_eip712Domain.set(this, void 0);
    }
    static async create(runner, kmsVerifierContractAddress, abi, properties) {
        assertIsAddress(kmsVerifierContractAddress, "kmsVerifierContractAddress");
        if (properties !== undefined) {
            throw new FhevmError("Not yet implemented");
        }
        const kmsVerifier = new KMSVerifier();
        __classPrivateFieldSet(kmsVerifier, _KMSVerifier_kmsVerifierContractAddress, kmsVerifierContractAddress, "f");
        __classPrivateFieldSet(kmsVerifier, _KMSVerifier_kmsVerifierContract, new EthersT.Contract(kmsVerifierContractAddress, abi ?? KMSVerifierPartialInterface, runner), "f");
        await kmsVerifier._initialize();
        return kmsVerifier;
    }
    get readonlyContract() {
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContract, "f") !== undefined, `KMSVerifier wrapper is not initialized`);
        return __classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContract, "f");
    }
    get interface() {
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContract, "f") !== undefined, `KMSVerifier wrapper is not yet initialized`);
        return __classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContract, "f").interface;
    }
    async _initialize() {
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContract, "f") !== undefined, `KMSVerifier wrapper is not initialized`);
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_signersAddresses, "f") === undefined, `KMSVerifier wrapper already initialized`);
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_threshold, "f") === undefined, `KMSVerifier wrapper already initialized`);
        const signers = await __classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContract, "f").getKmsSigners();
        assertIsAddressArray(signers);
        __classPrivateFieldSet(this, _KMSVerifier_signersAddresses, signers, "f");
        const threshold = await __classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContract, "f").getThreshold();
        assertIsBigUint8(threshold);
        __classPrivateFieldSet(this, _KMSVerifier_threshold, Number(threshold), "f");
        if (__classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f") === undefined) {
            // ignore extensions
            const eip712Domain = await __classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContract, "f").eip712Domain();
            assertFhevm(eip712Domain.length === 7);
            assertIsString(eip712Domain[0], "eip712Domain[0]");
            assertIsString(eip712Domain[1], "eip712Domain[1]");
            assertIsString(eip712Domain[2], "eip712Domain[2]");
            assertIsBigUint256(eip712Domain[3], "eip712Domain[3]");
            assertIsAddress(eip712Domain[4], "eip712Domain[4]");
            assertIsBytes32String(eip712Domain[5], "eip712Domain[5]");
            __classPrivateFieldSet(this, _KMSVerifier_eip712Domain, {
                fields: Number(BigInt(eip712Domain[0])),
                name: eip712Domain[1],
                version: eip712Domain[2],
                chainId: eip712Domain[3],
                verifyingContract: eip712Domain[4],
                salt: eip712Domain[5],
                // last field is ignored
            }, "f");
        }
        // Add extra checks (in case EIP712 are chanbging)
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f").fields === Number(0x0f));
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f").salt === EthersT.ZeroHash);
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f").name === constants.PUBLIC_DECRYPT_EIP712.domain.name);
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f").version === constants.PUBLIC_DECRYPT_EIP712.domain.version);
    }
    get address() {
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContractAddress, "f") !== undefined, `KMSVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _KMSVerifier_kmsVerifierContractAddress, "f");
    }
    // The KMSVerifier is always using the gatewayChainId in its eip712 domain
    get gatewayChainId() {
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f") !== undefined, `KMSVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f").chainId;
    }
    // The KMSVerifier is always using the address of the "Decryption.sol" contract deployed
    // on the gateway chainId in its eip712 domain
    get gatewayDecryptionAddress() {
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f") !== undefined, `KMSVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f").verifyingContract;
    }
    get eip712Domain() {
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f") !== undefined, `KMSVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _KMSVerifier_eip712Domain, "f");
    }
    getKmsSignersAddresses() {
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_signersAddresses, "f") !== undefined, `KMSVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _KMSVerifier_signersAddresses, "f");
    }
    async assertMatchKmsSigners(signers) {
        const addresses = this.getKmsSignersAddresses();
        assertIsArray(signers, "signers");
        assertFhevm(signers.length === addresses.length, "signers.length === addresses.length");
        for (let i = 0; i < addresses.length; ++i) {
            const s = await signers[i].getAddress();
            assertFhevm(addresses[i] === s, `addresses[${i}] === await signers[${i}].getAddress()`);
        }
    }
    getThreshold() {
        assertFhevm(__classPrivateFieldGet(this, _KMSVerifier_threshold, "f") !== undefined, `KMSVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _KMSVerifier_threshold, "f");
    }
    createPublicDecryptVerificationEIP712(handlesBytes32List, decryptedResult, extraData) {
        const domain = this.eip712Domain;
        const eip712 = {
            domain: {
                chainId: domain.chainId,
                name: domain.name,
                version: domain.version,
                verifyingContract: domain.verifyingContract,
            },
            types: constants.PUBLIC_DECRYPT_EIP712.types,
            message: {
                ctHandles: handlesBytes32List,
                decryptedResult: decryptedResult,
                extraData,
            },
        };
        return eip712;
    }
}
_KMSVerifier_kmsVerifierContract = new WeakMap(), _KMSVerifier_kmsVerifierContractAddress = new WeakMap(), _KMSVerifier_signersAddresses = new WeakMap(), _KMSVerifier_threshold = new WeakMap(), _KMSVerifier_eip712Domain = new WeakMap();
export async function computeDecryptionSignatures(handlesBytes32Hex, clearTextValues, extraData, abiCoder, kmsVerifier, kmsSigners) {
    const fhevmHandles = handlesBytes32Hex.map((handleBytes32Hex) => FhevmHandle.fromBytes32Hex(handleBytes32Hex));
    assertFhevm(handlesBytes32Hex.length === clearTextValues.length);
    const abiTypes = [];
    const abiValues = [];
    for (let i = 0; i < handlesBytes32Hex.length; ++i) {
        let clearTextValue = clearTextValues[i];
        if (typeof clearTextValue === "boolean") {
            clearTextValue = clearTextValue ? "0x01" : "0x00";
        }
        const clearTextValueBigInt = BigInt(clearTextValue);
        const fhevmTypeInfo = fhevmHandles[i].fhevmTypeInfo;
        abiTypes.push(fhevmTypeInfo.solidityTypeName);
        switch (fhevmTypeInfo.type) {
            case FhevmType.eaddress: {
                // string
                abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(40, "0")}`);
                break;
            }
            case FhevmType.ebool: {
                // bigint (0 or 1)
                abiValues.push(clearTextValueBigInt);
                break;
            }
            case FhevmType.euint4:
            case FhevmType.euint8:
            case FhevmType.euint16:
            case FhevmType.euint32:
            case FhevmType.euint64:
            case FhevmType.euint128:
            case FhevmType.euint256: {
                // bigint
                abiValues.push(clearTextValueBigInt);
                break;
            }
            case FhevmType.ebytes64: {
                // string
                abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(128, "0")}`);
                break;
            }
            case FhevmType.ebytes128: {
                // string
                abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(256, "0")}`);
                break;
            }
            case FhevmType.ebytes256: {
                // string
                abiValues.push(`0x${clearTextValueBigInt.toString(16).padStart(512, "0")}`);
                break;
            }
            default: {
                throw new FhevmError(`Unsupported Fhevm primitive type id: ${fhevmTypeInfo.type}, name: ${fhevmTypeInfo.name}, solidity: ${fhevmTypeInfo.solidityTypeName}`);
            }
        }
    }
    // 1. 31 is just a dummy uint256 requestID to get correct abi encoding for the remaining arguments
    //    (i.e everything except the requestID)
    // 2. Adding also a dummy empty array of bytes for correct abi-encoding when used with signatures
    const encodedData = abiCoder.encode(["uint256", ...abiTypes, "bytes[]"], [31, ...abiValues, []]);
    // 1. We pop the dummy requestID to get the correct value to pass for `decryptedCts`
    // 2. We also pop the last 32 bytes (empty bytes[])
    const decryptedResult = "0x" + encodedData.slice(66).slice(0, -64);
    assertFhevm(decryptedResult === "0x" + encodedData.slice(66, -64), "decryptedResult === '0x' + encodedData.slice(66, -64)");
    const eip712 = kmsVerifier.createPublicDecryptVerificationEIP712(handlesBytes32Hex, decryptedResult, extraData);
    const decryptResultsEIP712signatures = await multiSignEIP712(kmsSigners, eip712.domain, eip712.types, eip712.message);
    return { signatures: decryptResultsEIP712signatures, types: abiTypes, values: abiValues, decryptedResult };
}
export async function computeDecryptionCallbackSignaturesAndCalldata(handlesBytes32Hex, clearTextValuesString, extraData, requestID, callbackSelectorBytes4Hex, abiCoder, kmsVerifier, kmsSigners) {
    assertFhevm(extraData === EthersT.solidityPacked(["uint8"], [0]), "extraData must be 0x00");
    const { signatures, types, values } = await computeDecryptionSignatures(handlesBytes32Hex, clearTextValuesString, extraData, abiCoder, kmsVerifier, kmsSigners);
    // Build the decryptionProof as numSigners + KMS signatures + extraData
    const packedNumSigners = EthersT.solidityPacked(["uint8"], [signatures.length]);
    const packedSignatures = EthersT.solidityPacked(Array(signatures.length).fill("bytes"), signatures);
    const decryptionProof = EthersT.concat([packedNumSigners, packedSignatures, extraData]);
    // ABI encode the list of values in order to pass them in the callback
    const encodedCleartexts = abiCoder.encode([...types], [...values]);
    const calldata = callbackSelectorBytes4Hex +
        abiCoder.encode(["uint256", "bytes", "bytes"], [requestID, encodedCleartexts, decryptionProof]).slice(2);
    return { calldata };
}
//# sourceMappingURL=KMSVerifier.js.map