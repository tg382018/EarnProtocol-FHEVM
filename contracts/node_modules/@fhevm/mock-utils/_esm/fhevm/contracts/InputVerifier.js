var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InputVerifier_inputVerifierReadonlyContract, _InputVerifier_inputVerifierContractAddress, _InputVerifier_signersAddresses, _InputVerifier_threshold, _InputVerifier_eip712Domain;
import { ethers as EthersT } from "ethers";
import constants from "../../constants.js";
import { isThresholdReached } from "../../ethers/eip712.js";
import { assertIsAddress, assertIsAddressArray } from "../../utils/address.js";
import { assertIsBytes32String } from "../../utils/bytes.js";
import { FhevmError, assertFhevm, assertIsArray } from "../../utils/error.js";
import { numberToHexNoPrefix } from "../../utils/hex.js";
import { assertIsBigUint8, assertIsBigUint256 } from "../../utils/math.js";
import { assertIsString, ensure0x, removePrefix } from "../../utils/string.js";
import { FhevmCoprocessorContractWrapper } from "./FhevmContractWrapper.js";
import { InputVerifierPartialInterface } from "./interfaces/InputVerifier.itf.js";
// Shareable
export class InputVerifier extends FhevmCoprocessorContractWrapper {
    constructor() {
        super("InputVerifier");
        _InputVerifier_inputVerifierReadonlyContract.set(this, void 0);
        _InputVerifier_inputVerifierContractAddress.set(this, void 0);
        _InputVerifier_signersAddresses.set(this, void 0);
        _InputVerifier_threshold.set(this, void 0);
        _InputVerifier_eip712Domain.set(this, void 0);
    }
    static async create(runner, inputVerifierContractAddress, abi, properties) {
        assertIsAddress(inputVerifierContractAddress, "inputVerifierContractAddress");
        const inputVerifier = new InputVerifier();
        __classPrivateFieldSet(inputVerifier, _InputVerifier_inputVerifierContractAddress, inputVerifierContractAddress, "f");
        __classPrivateFieldSet(inputVerifier, _InputVerifier_inputVerifierReadonlyContract, new EthersT.Contract(inputVerifierContractAddress, abi ?? InputVerifierPartialInterface, runner), "f");
        __classPrivateFieldSet(inputVerifier, _InputVerifier_eip712Domain, properties?.eip712Domain, "f");
        __classPrivateFieldSet(inputVerifier, _InputVerifier_signersAddresses, properties?.signersAddresses, "f");
        __classPrivateFieldSet(inputVerifier, _InputVerifier_threshold, properties?.threshold, "f");
        await inputVerifier._initialize();
        return inputVerifier;
    }
    get readonlyContract() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f") !== undefined, `InputVerifier wrapper is not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f");
    }
    get interface() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f") !== undefined, `InputVerifier wrapper is not yet initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f").interface;
    }
    async _initialize() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f") !== undefined, `InputVerifier wrapper is not initialized`);
        if (!__classPrivateFieldGet(this, _InputVerifier_signersAddresses, "f")) {
            const signers = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f").getCoprocessorSigners();
            __classPrivateFieldSet(this, _InputVerifier_signersAddresses, signers, "f");
        }
        assertIsAddressArray(__classPrivateFieldGet(this, _InputVerifier_signersAddresses, "f"));
        if (__classPrivateFieldGet(this, _InputVerifier_threshold, "f") === undefined) {
            const threshold = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f").getThreshold();
            assertIsBigUint8(threshold);
            __classPrivateFieldSet(this, _InputVerifier_threshold, Number(threshold), "f");
        }
        if (__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") === undefined) {
            // ignore extensions
            const eip712Domain = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f").eip712Domain();
            // Add extra checks (in case EIP712 are changing)
            assertFhevm(eip712Domain.length === 7);
            assertIsString(eip712Domain[0], "eip712Domain[0]");
            assertIsString(eip712Domain[1], "eip712Domain[1]");
            assertIsString(eip712Domain[2], "eip712Domain[2]");
            assertIsBigUint256(eip712Domain[3], "eip712Domain[3]");
            assertIsAddress(eip712Domain[4], "eip712Domain[4]");
            assertIsBytes32String(eip712Domain[5], "eip712Domain[5]");
            assertFhevm(Array.isArray(eip712Domain[6]) && eip712Domain[6].length === 0, "eip712Domain[6]");
            __classPrivateFieldSet(this, _InputVerifier_eip712Domain, {
                fields: Number(BigInt(eip712Domain[0])),
                name: eip712Domain[1],
                version: eip712Domain[2],
                chainId: eip712Domain[3],
                verifyingContract: eip712Domain[4],
                salt: eip712Domain[5],
                // last field is ignored
            }, "f");
        }
        // Add extra checks (in case EIP712 are chanbging)
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").fields === Number(0x0f));
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").salt === EthersT.ZeroHash);
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").name === constants.INPUT_VERIFICATION_EIP712.domain.name);
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").version === constants.INPUT_VERIFICATION_EIP712.domain.version);
    }
    get address() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_inputVerifierContractAddress, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierContractAddress, "f");
    }
    // The InputVerifier is always using the gatewayChainId in its eip712 domain
    get gatewayChainId() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").chainId;
    }
    // The InputVerifier is always using the address of the "InputVerification.sol" contract deployed
    // on the gateway chainId in its eip712 domain
    get gatewayInputVerificationAddress() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").verifyingContract;
    }
    get eip712Domain() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f");
    }
    getCoprocessorSigners() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_signersAddresses, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_signersAddresses, "f");
    }
    getThreshold() {
        assertFhevm(__classPrivateFieldGet(this, _InputVerifier_threshold, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_threshold, "f");
    }
    async assertMatchCoprocessorSigners(signers) {
        const addresses = this.getCoprocessorSigners();
        assertIsArray(signers, "signers");
        assertFhevm(signers.length === addresses.length, "signers.length === addresses.length");
        for (let i = 0; i < addresses.length; ++i) {
            const s = await signers[i].getAddress();
            assertFhevm(addresses[i] === s, `addresses[${i}] === await signers[${i}].getAddress()`);
        }
    }
    verifySignatures(handlesBytes32List, userAddress, contractAddress, contractChainId, extraData, signatures) {
        assertIsArray(signatures);
        const domain = this.eip712Domain;
        const recoveredAddresses = signatures.map((signature) => {
            const sig = ensure0x(signature);
            const recoveredAddress = EthersT.verifyTypedData({
                name: domain.name,
                version: domain.version,
                chainId: domain.chainId,
                verifyingContract: domain.verifyingContract,
            }, constants.INPUT_VERIFICATION_EIP712.types, {
                ctHandles: handlesBytes32List,
                userAddress,
                contractAddress,
                contractChainId,
                extraData,
            }, sig);
            return recoveredAddress;
        });
        if (!isThresholdReached(this.getCoprocessorSigners(), recoveredAddresses, this.getThreshold(), "coprocessor")) {
            throw new FhevmError("Coprocessor signers threshold is not reached");
        }
    }
    // See: fhevm-gateway/contracts/InputVerification.sol
    createCiphertextVerificationEIP712(handlesBytes32List, contractChainId, contractAddress, userAddress, extraData) {
        assertIsAddress(userAddress, "userAddress");
        assertIsAddress(contractAddress, "contractAddress");
        const domain = this.eip712Domain;
        const eip712 = {
            domain: {
                chainId: domain.chainId,
                name: domain.name,
                version: domain.version,
                verifyingContract: domain.verifyingContract,
            },
            types: constants.INPUT_VERIFICATION_EIP712.types,
            message: {
                ctHandles: handlesBytes32List.map((handle) => EthersT.zeroPadValue(EthersT.toBeHex(handle), 32)),
                userAddress: userAddress,
                contractAddress: contractAddress,
                contractChainId: contractChainId,
                extraData,
            },
        };
        return eip712;
    }
}
_InputVerifier_inputVerifierReadonlyContract = new WeakMap(), _InputVerifier_inputVerifierContractAddress = new WeakMap(), _InputVerifier_signersAddresses = new WeakMap(), _InputVerifier_threshold = new WeakMap(), _InputVerifier_eip712Domain = new WeakMap();
export function computeInputProofHex(handlesBytes32Hex, coprocessorsSignaturesHex, extraData) {
    const numHandles = handlesBytes32Hex.length;
    const numCoprocessorSigners = coprocessorsSignaturesHex.length;
    const numHandlesHexByte1 = numberToHexNoPrefix(numHandles);
    assertFhevm(numHandlesHexByte1.length === 2); // 1 byte
    const numCoprocessorSignersHexByte1 = numberToHexNoPrefix(numCoprocessorSigners);
    assertFhevm(numCoprocessorSignersHexByte1.length === 2); // 1 byte
    // Compute inputProof
    let inputProofHex = "0x" + numHandlesHexByte1 + numCoprocessorSignersHexByte1;
    // Append the list of handles
    for (let i = 0; i < numHandles; ++i) {
        const handlesBytes32HexNoPrefix = removePrefix(handlesBytes32Hex[i], "0x");
        assertFhevm(handlesBytes32HexNoPrefix.length === 2 * 32);
        inputProofHex += handlesBytes32HexNoPrefix;
    }
    // Append list of coprocessor signatures
    coprocessorsSignaturesHex.map((signatureHex) => {
        const signatureBytes65HexNoPrefix = removePrefix(signatureHex, "0x");
        if (signatureBytes65HexNoPrefix.length !== 2 * 65) {
            throw new FhevmError(`Invalid coprocessor signature: ${signatureBytes65HexNoPrefix}. Invalid length.`);
        }
        inputProofHex += signatureBytes65HexNoPrefix;
    });
    // Append the extra data to the input proof
    inputProofHex = EthersT.concat([inputProofHex, extraData]);
    return inputProofHex;
}
//# sourceMappingURL=InputVerifier.js.map