var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockFhevmInstance_relayerProvider, _MockFhevmInstance_readonlyEthersProvider, _MockFhevmInstance_chainId, _MockFhevmInstance_gatewayChainId, _MockFhevmInstance_verifyingContractAddressInputVerification, _MockFhevmInstance_verifyingContractAddressDecryption, _MockFhevmInstance_contractsChainId, _MockFhevmInstance_aclContractAddress, _MockFhevmInstance_kmsVerifier, _MockFhevmInstance_inputVerifier, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc;
/*
    WARNING : Never import the "hardhat" package!
*/
import { ethers as EthersT } from "ethers";
import constants from "../constants.js";
import { isThresholdReached } from "../ethers/eip712.js";
import { checkEncryptedBits } from "../relayer-sdk/relayer/decryptUtils.js";
import { deserializeDecryptedResult } from "../relayer-sdk/relayer/publicDecrypt.js";
import { buildUserDecryptedResult, checkDeadlineValidity, checkMaxContractAddresses, } from "../relayer-sdk/relayer/userDecrypt.js";
import { createEIP712 as fhevmSdkCreateEIP712ForDecryption, generateKeypair as fhevmSdkGenerateKeypair, } from "../relayer-sdk/types.js";
import { assertIsAddress, assertIsAddressArray } from "../utils/address.js";
import { FhevmError, assertFhevm } from "../utils/error.js";
import { fromHexString, toHexString } from "../utils/hex.js";
import { assertIsNumber } from "../utils/math.js";
import { ensure0x, remove0x } from "../utils/string.js";
import { MockRelayerEncryptedInput } from "./MockRelayerEncryptedInput.js";
import { InputVerifier } from "./contracts/InputVerifier.js";
import { KMSVerifier } from "./contracts/KMSVerifier.js";
import * as relayer from "./relayer/MockRelayer.js";
/*
  Only one instance is created for the whole HH session (including tests)
*/
export class MockFhevmInstance {
    constructor(config, extra) {
        _MockFhevmInstance_relayerProvider.set(this, void 0);
        _MockFhevmInstance_readonlyEthersProvider.set(this, void 0);
        _MockFhevmInstance_chainId.set(this, void 0); //provider's chainId
        _MockFhevmInstance_gatewayChainId.set(this, void 0);
        _MockFhevmInstance_verifyingContractAddressInputVerification.set(this, void 0);
        _MockFhevmInstance_verifyingContractAddressDecryption.set(this, void 0);
        _MockFhevmInstance_contractsChainId.set(this, void 0);
        _MockFhevmInstance_aclContractAddress.set(this, void 0);
        _MockFhevmInstance_kmsVerifier.set(this, void 0);
        _MockFhevmInstance_inputVerifier.set(this, void 0);
        _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc.set(this, void 0);
        assertIsAddress(config.verifyingContractAddressInputVerification, "config.verifyingContractAddressInputVerification");
        assertIsAddress(config.verifyingContractAddressDecryption, "config.verifyingContractAddressDecryption");
        assertIsNumber(config.gatewayChainId, "config.gatewayChainId");
        __classPrivateFieldSet(this, _MockFhevmInstance_relayerProvider, extra.relayerProvider, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_readonlyEthersProvider, extra.readonlyEthersProvider, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_chainId, config.chainId, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_gatewayChainId, config.gatewayChainId, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_verifyingContractAddressInputVerification, config.verifyingContractAddressInputVerification, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_verifyingContractAddressDecryption, config.verifyingContractAddressDecryption, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_contractsChainId, config.chainId, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_aclContractAddress, config.aclContractAddress, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_kmsVerifier, extra.kmsVerifier, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_inputVerifier, extra.inputVerifier, "f");
        __classPrivateFieldSet(this, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc, fhevmSdkCreateEIP712ForDecryption(__classPrivateFieldGet(this, _MockFhevmInstance_verifyingContractAddressDecryption, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_contractsChainId, "f")), "f");
    }
    get chainId() {
        return __classPrivateFieldGet(this, _MockFhevmInstance_chainId, "f");
    }
    static async create(relayerProvider, readonlyEthersProvider, config) {
        const kmsVerifier = await KMSVerifier.create(readonlyEthersProvider, config.kmsContractAddress);
        const inputVerifier = await InputVerifier.create(readonlyEthersProvider, config.inputVerifierContractAddress);
        const instance = new MockFhevmInstance(config, {
            relayerProvider,
            readonlyEthersProvider,
            inputVerifier,
            kmsVerifier,
        });
        return instance;
    }
    static createEIP712(publicKey, contractAddresses, startTimestamp, durationDays, verifyingContractAddressDecryption, contractsChainId) {
        assertIsAddressArray(contractAddresses, "contractAddresses");
        const eip712Func = fhevmSdkCreateEIP712ForDecryption(verifyingContractAddressDecryption, contractsChainId);
        const eip712 = eip712Func(publicKey, contractAddresses, startTimestamp, durationDays);
        //Debug Make sure we are in sync with KMSVerifier.sol
        assertFhevm(eip712.domain.version === constants.PUBLIC_DECRYPT_EIP712.domain.version.toString());
        assertFhevm(eip712.domain.name === constants.PUBLIC_DECRYPT_EIP712.domain.name);
        return eip712;
    }
    // Create EIP712 for decryption
    createEIP712(publicKey, contractAddresses, startTimestamp, durationDays) {
        assertIsAddressArray(contractAddresses, "contractAddresses");
        const eip712 = __classPrivateFieldGet(this, _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc, "f").call(this, publicKey, contractAddresses, startTimestamp, durationDays);
        //Debug Make sure we are in sync with KMSVerifier.sol
        assertFhevm(BigInt(__classPrivateFieldGet(this, _MockFhevmInstance_gatewayChainId, "f")) === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.chainId);
        assertFhevm(eip712.domain.verifyingContract === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.verifyingContract);
        assertFhevm(eip712.domain.version === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.version);
        assertFhevm(eip712.domain.name === __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").eip712Domain.name);
        assertFhevm(BigInt(eip712.domain.chainId) === BigInt(__classPrivateFieldGet(this, _MockFhevmInstance_contractsChainId, "f")));
        return eip712;
    }
    createEncryptedInput(contractAddress, userAddress) {
        //Debug Make sure we are in sync with InputVerifier.sol
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstance_verifyingContractAddressInputVerification, "f") === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.verifyingContract);
        assertFhevm(BigInt(__classPrivateFieldGet(this, _MockFhevmInstance_gatewayChainId, "f")) === __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f").eip712Domain.chainId);
        return new MockRelayerEncryptedInput(__classPrivateFieldGet(this, _MockFhevmInstance_relayerProvider, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_chainId, "f"), contractAddress, userAddress, __classPrivateFieldGet(this, _MockFhevmInstance_aclContractAddress, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_inputVerifier, "f"));
    }
    generateKeypair() {
        return fhevmSdkGenerateKeypair();
    }
    getPublicKey() {
        throw new FhevmError("Not supported in mock mode");
    }
    getPublicParams(_bits) {
        throw new FhevmError("Not supported in mock mode");
    }
    async publicDecrypt(handles) {
        const extraData = "0x00";
        // Intercept future type change...
        for (let i = 0; i < handles.length; ++i) {
            assertFhevm(typeof handles[i] === "string" || handles[i] instanceof Uint8Array, "handle is not a string or a Uint8Array");
        }
        // Casting handles if string
        const relayerHandles = handles.map((h) => typeof h === "string" ? toHexString(fromHexString(h)) : toHexString(h));
        // relayer-sdk
        checkEncryptedBits(relayerHandles);
        await MockFhevmInstance.verifyPublicACLPermissions(__classPrivateFieldGet(this, _MockFhevmInstance_readonlyEthersProvider, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_aclContractAddress, "f"), relayerHandles);
        // relayer-sdk
        const payloadForRequest = {
            ciphertextHandles: relayerHandles,
            extraData,
        };
        // Return a json object basically following the @zama-fhe/relayer-sdk format
        const json = await relayer.requestRelayerV1PublicDecrypt(__classPrivateFieldGet(this, _MockFhevmInstance_relayerProvider, "f"), payloadForRequest);
        const result = json.response[0];
        // Add "0x" prefix if needed
        const decryptedResult = ensure0x(result.decrypted_value);
        const signatures = result.signatures.map(ensure0x);
        // verify signatures on decryption:
        const domain = {
            name: constants.PUBLIC_DECRYPT_EIP712.domain.name,
            version: constants.PUBLIC_DECRYPT_EIP712.domain.version,
            chainId: __classPrivateFieldGet(this, _MockFhevmInstance_gatewayChainId, "f"),
            verifyingContract: __classPrivateFieldGet(this, _MockFhevmInstance_verifyingContractAddressDecryption, "f"),
        };
        const types = constants.PUBLIC_DECRYPT_EIP712.types;
        // The `signedExtraData` variable is following the @zama-fhe/relayer-sdk implementation
        // TODO: in relayer-sdk, signedExtraData === "0x". However, here, we use "0x00".
        const signedExtraData = "0x00";
        const recoveredAddresses = signatures.map((signature) => {
            assertFhevm(signature.startsWith("0x"));
            const recoveredAddress = EthersT.verifyTypedData(domain, types, { ctHandles: handles, decryptedResult, extraData: signedExtraData }, signature);
            return recoveredAddress;
        });
        const thresholdReached = isThresholdReached(__classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").getKmsSignersAddresses(), recoveredAddresses, __classPrivateFieldGet(this, _MockFhevmInstance_kmsVerifier, "f").getThreshold(), "KMS");
        if (!thresholdReached) {
            throw Error("KMS signers threshold is not reached");
        }
        const results = deserializeDecryptedResult(relayerHandles, decryptedResult);
        return results;
    }
    async userDecrypt(handles, _privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) {
        const extraData = "0x00";
        // Intercept future type change...
        for (let i = 0; i < handles.length; ++i) {
            assertFhevm(typeof handles[i].handle === "string" || handles[i].handle instanceof Uint8Array, "handle is not a string or a Uint8Array");
        }
        // Casting handles if string
        const relayerHandles = handles.map((h) => ({
            handle: typeof h.handle === "string" ? toHexString(fromHexString(h.handle)) : toHexString(h.handle),
            contractAddress: h.contractAddress,
        }));
        // relayer-sdk
        checkEncryptedBits(relayerHandles.map((h) => h.handle));
        // relayer-sdk
        checkDeadlineValidity(BigInt(startTimestamp), BigInt(durationDays));
        await MockFhevmInstance.verifyUserACLPermissions(__classPrivateFieldGet(this, _MockFhevmInstance_readonlyEthersProvider, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_aclContractAddress, "f"), relayerHandles, userAddress);
        // relayer-sdk
        checkMaxContractAddresses(contractAddresses);
        MockFhevmInstance.verifyHandleContractAddresses(relayerHandles, contractAddresses);
        // Redundant: the mock relayer already performs this check, so it could be removed
        await MockFhevmInstance.verifyUserDecryptSignature(publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays, __classPrivateFieldGet(this, _MockFhevmInstance_verifyingContractAddressDecryption, "f"), __classPrivateFieldGet(this, _MockFhevmInstance_contractsChainId, "f"));
        // relayer-sdk
        const payloadForRequest = {
            handleContractPairs: relayerHandles,
            requestValidity: {
                startTimestamp: startTimestamp.toString(), // Convert to string
                durationDays: durationDays.toString(), // Convert to string
            },
            contractsChainId: __classPrivateFieldGet(this, _MockFhevmInstance_chainId, "f").toString(), // Convert to string
            contractAddresses: contractAddresses.map((c) => EthersT.getAddress(c)),
            userAddress: EthersT.getAddress(userAddress),
            signature: remove0x(signature),
            publicKey: remove0x(publicKey),
            extraData,
        };
        // Return a json object basically following the @zama-fhe/relayer-sdk format
        const json = await relayer.requestRelayerV1UserDecrypt(__classPrivateFieldGet(this, _MockFhevmInstance_relayerProvider, "f"), payloadForRequest);
        const result = json.response[0];
        // The `decrypted_values` field is specific to the mock relayer.
        const clearTextHexList = result.payload.decrypted_values;
        const listBigIntDecryptions = clearTextHexList.map(EthersT.toBigInt);
        const results = buildUserDecryptedResult(relayerHandles.map((h) => h.handle), listBigIntDecryptions);
        return results;
    }
    // Static function called by:
    // - MockFhevmInstance.userDecrypt()
    // - packages/hardhat-plugin/src/internal/provider/FhevmProviderExtender._handleFhevmRelayerV1UserDecrypt()
    static async verifyUserDecryptSignature(publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays, verifyingContractAddressDecryption, contractsChainId) {
        publicKey = ensure0x(publicKey);
        signature = ensure0x(signature);
        const eip712 = MockFhevmInstance.createEIP712(publicKey, contractAddresses, startTimestamp, durationDays, verifyingContractAddressDecryption, contractsChainId);
        const types = {};
        types[eip712.primaryType] = eip712.types[eip712.primaryType];
        const signerAddress = EthersT.verifyTypedData(eip712.domain, types, eip712.message, signature);
        const normalizedSignerAddress = EthersT.getAddress(signerAddress);
        const normalizedUserAddress = EthersT.getAddress(userAddress);
        if (normalizedSignerAddress !== normalizedUserAddress) {
            throw new FhevmError("Invalid EIP-712 signature!");
        }
    }
    static async verifyPublicACLPermissions(readonlyEthersProvider, aclContractAddress, handles) {
        const aclABI = ["function isAllowedForDecryption(bytes32 handle) view returns (bool)"];
        const acl = new EthersT.Contract(aclContractAddress, aclABI, readonlyEthersProvider);
        const verifications = handles.map(async (h) => {
            const ctHandleHex = EthersT.toBeHex(EthersT.toBigInt(h), 32);
            const allowed = await acl.isAllowedForDecryption(ctHandleHex);
            if (!allowed) {
                throw new FhevmError(`Handle ${h} is not allowed for public decryption!`);
            }
        });
        return Promise.all(verifications).catch((e) => {
            throw e;
        });
    }
    // (Duplicated code) Should be imported from @zama-fhe/relayer-sdk
    static async verifyUserACLPermissions(readonlyEthersProvider, aclContractAddress, handles, userAddress) {
        const aclABI = ["function persistAllowed(bytes32 handle, address account) view returns (bool)"];
        const acl = new EthersT.Contract(aclContractAddress, aclABI, readonlyEthersProvider);
        const verifications = handles.map(async ({ handle, contractAddress }) => {
            const ctHandleHex = EthersT.toBeHex(EthersT.toBigInt(handle), 32);
            const userAllowed = await acl.persistAllowed(ctHandleHex, userAddress);
            const contractAllowed = await acl.persistAllowed(ctHandleHex, contractAddress);
            if (!userAllowed) {
                throw new FhevmError(`User ${userAddress} is not authorized to user decrypt handle ${handle}!`);
            }
            if (!contractAllowed) {
                throw new FhevmError(`dapp contract ${contractAddress} is not authorized to user decrypt handle ${handle}!`);
            }
            if (userAddress === contractAddress) {
                throw new FhevmError(`userAddress ${userAddress} should not be equal to contractAddress when requesting decryption!`);
            }
        });
        return Promise.all(verifications).catch((e) => {
            throw e;
        });
    }
    static verifyHandleContractAddresses(handles, contractAddresses) {
        const set = new Set();
        // Build a list of unique allowed contact addresses.
        for (let i = 0; i < contractAddresses.length; ++i) {
            const add = contractAddresses[i].toLowerCase();
            if (!set.has(add)) {
                set.add(add);
            }
        }
        // Check that every handle contract (in HandleContractPair) is actually listed in the contractAddresses argument.
        for (let i = 0; i < handles.length; ++i) {
            if (!set.has(handles[i].contractAddress.toLowerCase())) {
                throw new FhevmError(`Contract address ${handles[i].contractAddress} associated to handle ${handles[i].handle} is not listed in the contractAddresses array argument.`);
            }
        }
    }
}
_MockFhevmInstance_relayerProvider = new WeakMap(), _MockFhevmInstance_readonlyEthersProvider = new WeakMap(), _MockFhevmInstance_chainId = new WeakMap(), _MockFhevmInstance_gatewayChainId = new WeakMap(), _MockFhevmInstance_verifyingContractAddressInputVerification = new WeakMap(), _MockFhevmInstance_verifyingContractAddressDecryption = new WeakMap(), _MockFhevmInstance_contractsChainId = new WeakMap(), _MockFhevmInstance_aclContractAddress = new WeakMap(), _MockFhevmInstance_kmsVerifier = new WeakMap(), _MockFhevmInstance_inputVerifier = new WeakMap(), _MockFhevmInstance_fhevmSdkCreateEIP712ForDecryptionFunc = new WeakMap();
//# sourceMappingURL=MockFhevmInstance.js.map