var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockRelayerEncryptedInput_clearTextValues, _MockRelayerEncryptedInput_fhevmTypes, _MockRelayerEncryptedInput_fheTypes, _MockRelayerEncryptedInput_totalFheBits, _MockRelayerEncryptedInput_contractChainId, _MockRelayerEncryptedInput_contractAddress, _MockRelayerEncryptedInput_userAddress, _MockRelayerEncryptedInput_relayerProvider, _MockRelayerEncryptedInput_aclContractAddress, _MockRelayerEncryptedInput_inputVerifier;
import { ethers as EthersT } from "ethers";
import constants from "../constants.js";
import { ENCRYPTION_TYPES } from "../relayer-sdk/types.js";
import { concatBytes, uintToBytes } from "../utils/bytes.js";
import { FhevmError, assertFhevm } from "../utils/error.js";
import { MAX_UINT64, boolToBigInt, getMaxBigInt } from "../utils/math.js";
import { FheType, getFheTypeBitLength, getFheTypeByteLength } from "./FheType.js";
import { FhevmHandle } from "./FhevmHandle.js";
import { FhevmType, FhevmTypeToFheType, getFhevmTypeInfo, isFhevmEbytes, isFhevmEuint } from "./FhevmType.js";
import { InputVerifier, computeInputProofHex } from "./contracts/InputVerifier.js";
import * as relayer from "./relayer/index.js";
export class MockRelayerEncryptedInput {
    constructor(relayerProvider, contractChainId, contractAddress, userAddress, aclContractAddress, inputVerifier) {
        _MockRelayerEncryptedInput_clearTextValues.set(this, []);
        _MockRelayerEncryptedInput_fhevmTypes.set(this, []);
        _MockRelayerEncryptedInput_fheTypes.set(this, []);
        _MockRelayerEncryptedInput_totalFheBits.set(this, 0);
        _MockRelayerEncryptedInput_contractChainId.set(this, void 0);
        _MockRelayerEncryptedInput_contractAddress.set(this, void 0);
        _MockRelayerEncryptedInput_userAddress.set(this, void 0);
        _MockRelayerEncryptedInput_relayerProvider.set(this, void 0);
        _MockRelayerEncryptedInput_aclContractAddress.set(this, void 0);
        _MockRelayerEncryptedInput_inputVerifier.set(this, void 0);
        // Check if chainId exceeds 8 bytes
        if (BigInt(contractChainId) > MAX_UINT64) {
            throw new Error("ChainId exceeds maximum allowed value (8 bytes)"); // fhevm assumes chainID is only taking up to 8 bytes
        }
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_relayerProvider, relayerProvider, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_contractChainId, contractChainId, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_contractAddress, contractAddress, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_userAddress, userAddress, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_aclContractAddress, aclContractAddress, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_inputVerifier, inputVerifier, "f");
    }
    get userAddress() {
        return __classPrivateFieldGet(this, _MockRelayerEncryptedInput_userAddress, "f");
    }
    get contractAddress() {
        return __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractAddress, "f");
    }
    _checkAddFheBits(fheBitLen) {
        assertFhevm(fheBitLen >= 0);
        if (__classPrivateFieldGet(this, _MockRelayerEncryptedInput_totalFheBits, "f") + fheBitLen > MockRelayerEncryptedInput.MAX_FHE_BITS) {
            throw Error("Packing more than 2048 bits in a single input ciphertext is unsupported");
        }
        if (__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length + 1 > MockRelayerEncryptedInput.MAX_VAR_COUNT) {
            throw Error("Packing more than 256 variables in a single input ciphertext is unsupported");
        }
    }
    _addClearTextValueFheBitsPair(clearTextValue, fhevmType) {
        // Bool = 2
        const fheType = FhevmTypeToFheType(fhevmType);
        const fheBitLen = getFheTypeBitLength(fheType);
        this._checkAddFheBits(fheBitLen);
        __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fhevmTypes, "f").push(fhevmType);
        __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fheTypes, "f").push(fheType);
        __classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").push(clearTextValue);
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_totalFheBits, __classPrivateFieldGet(this, _MockRelayerEncryptedInput_totalFheBits, "f") + fheBitLen, "f");
        assertFhevm(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length <= MockRelayerEncryptedInput.MAX_VAR_COUNT);
        assertFhevm(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_totalFheBits, "f") <= MockRelayerEncryptedInput.MAX_FHE_BITS);
        assertFhevm(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length === __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fheTypes, "f").length);
        assertFhevm(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length === __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fhevmTypes, "f").length);
    }
    _addBytes(clearTextValue, fhevmType) {
        assertFhevm(isFhevmEbytes(fhevmType));
        const fhevmTypeInfo = getFhevmTypeInfo(fhevmType);
        const fheBitLen = getFheTypeBitLength(fhevmTypeInfo.fheType);
        const clearTextBitLen = fhevmTypeInfo.clearTextBitLength;
        // For bytes, cleatText bit length and cypherText bit length are the same
        assertFhevm(clearTextBitLen === fheBitLen);
        assertFhevm(fheBitLen % 8 === 0);
        const fheByteLen = fheBitLen / 8;
        if (clearTextValue.length > fheByteLen) {
            throw new FhevmError(`Uncorrect length of input Uint8Array, should be ${fheByteLen} for an ${fhevmTypeInfo.name}`);
        }
        const clearTextValueBigInt = EthersT.toBigInt(clearTextValue);
        const maxClearTextValueBigInt = getMaxBigInt(clearTextBitLen);
        //const clearTextValueBigInt : bigint = bytesToBigInt(clearTextValue);
        assertFhevm(clearTextValue.length * 8 === fheBitLen);
        assertFhevm(clearTextValueBigInt <= maxClearTextValueBigInt);
        this._addClearTextValueFheBitsPair(clearTextValueBigInt, fhevmType);
        return this;
    }
    _addUint(clearTextValue, fhevmzType) {
        assertFhevm(isFhevmEuint(fhevmzType));
        const fhevmTypeInfo = getFhevmTypeInfo(fhevmzType);
        const clearTextBitLen = fhevmTypeInfo.clearTextBitLength;
        if (clearTextValue < 0) {
            throw new FhevmError(`Invalid unsigned integer value ${clearTextValue}`);
        }
        const clearTextValueBigInt = BigInt(clearTextValue);
        const maxClearTextValueBigInt = getMaxBigInt(clearTextBitLen);
        if (clearTextValueBigInt > maxClearTextValueBigInt) {
            throw new FhevmError(`Invalid ${fhevmTypeInfo.solidityTypeName} value: ${clearTextValue}, it exceeds the maximum allowed value of ${maxClearTextValueBigInt}.`);
        }
        this._addClearTextValueFheBitsPair(clearTextValueBigInt, fhevmzType);
        return this;
    }
    // Accepts : 0, 1, true, false
    addBool(value) {
        const zeroOrOneBigInt = boolToBigInt(value);
        this._addClearTextValueFheBitsPair(zeroOrOneBigInt, FhevmType.ebool);
        return this;
    }
    add8(value) {
        return this._addUint(value, FhevmType.euint8);
    }
    add16(value) {
        return this._addUint(value, FhevmType.euint16);
    }
    add32(value) {
        return this._addUint(value, FhevmType.euint32);
    }
    add64(value) {
        return this._addUint(value, FhevmType.euint64);
    }
    add128(value) {
        return this._addUint(value, FhevmType.euint128);
    }
    addAddress(value) {
        if (!EthersT.isAddress(value)) {
            throw new Error("Invalid address value: ${value}.");
        }
        const clearTextValue = EthersT.getAddress(value);
        this._addClearTextValueFheBitsPair(clearTextValue, FhevmType.eaddress);
        return this;
    }
    add256(value) {
        return this._addUint(value, FhevmType.euint256);
    }
    addBytes64(value) {
        return this._addBytes(value, FhevmType.ebytes64);
    }
    addBytes128(value) {
        return this._addBytes(value, FhevmType.ebytes128);
    }
    addBytes256(value) {
        return this._addBytes(value, FhevmType.ebytes256);
    }
    _toMockFhevmRelayerV1InputProofPayload(extraData) {
        const numHandles = __classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length;
        const clearTextValuesBigIntHex = [];
        const clearTextValuesBigInt = [];
        const rand32BufferList = [];
        const metadatas = [];
        //const randomBytes = EthersT.getBytes("0xd3f33f613ae8521e98fe2aa43bd0c6ad37d81c388c93460b78683e692602b981");
        for (let i = 0; i < numHandles; ++i) {
            const clearTextValueBigInt = BigInt(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f")[i]);
            clearTextValuesBigInt.push(clearTextValueBigInt);
            clearTextValuesBigIntHex.push(EthersT.toBeHex(clearTextValueBigInt));
            rand32BufferList.push(EthersT.randomBytes(32));
            //rand32BufferList.push(randomBytes);
            metadatas.push({
                blockNumber: 0,
                index: 0,
                transactionHash: EthersT.ZeroHash,
            });
        }
        const mockCiphertextWithInputVerification = MockRelayerEncryptedInput._computeMockCiphertextWithZKProof(clearTextValuesBigInt, __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fheTypes, "f"), rand32BufferList);
        const mockData = {
            clearTextValuesBigIntHex,
            metadatas,
            fheTypes: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fheTypes, "f"),
            fhevmTypes: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fhevmTypes, "f"),
            aclContractAddress: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_aclContractAddress, "f"),
            random32List: rand32BufferList.map(EthersT.hexlify),
        };
        const mockPayload = {
            contractAddress: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractAddress, "f"),
            userAddress: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_userAddress, "f"),
            ciphertextWithInputVerification: EthersT.hexlify(mockCiphertextWithInputVerification),
            contractChainId: "0x" + __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractChainId, "f").toString(16),
            extraData,
            mockData,
        };
        return mockPayload;
    }
    static _computeMockCiphertextWithZKProof(clearTextValuesBigInt, fheTypes, rand32BufferList) {
        let encrypted = new Uint8Array(0);
        const numHandles = clearTextValuesBigInt.length;
        assertFhevm(rand32BufferList.length === numHandles);
        assertFhevm(fheTypes.length === numHandles);
        // 1. Build the typed values hash
        for (let i = 0; i < numHandles; ++i) {
            /*
              type + value as bigint + random(32)
            */
            const clearTextValueBigInt = clearTextValuesBigInt[i];
            const fheByteLen = getFheTypeByteLength(fheTypes[i]);
            const fheType1Byte = new Uint8Array([fheTypes[i]]);
            const clearTextValueXXBytes = uintToBytes(clearTextValueBigInt, fheByteLen);
            const rand32Buffer = rand32BufferList[i];
            // concatenate 32 random bytes at the end of buffer to simulate encryption noise
            encrypted = concatBytes(encrypted, fheType1Byte, clearTextValueXXBytes, rand32Buffer);
        }
        return EthersT.getBytes(EthersT.keccak256(encrypted));
    }
    async encrypt() {
        const extraData = "0x00";
        /*
          Mock equivalent to https://github.com/zama-ai/fhevm-js/blob/main/src/relayer/sendEncryption.ts
    
          From sendEncryption.ts:
          =======================
    
            const bits = input.getBits();
            const ciphertext = input.encrypt();
            const payload = {
              contractAddress: getAddress(contractAddress),
              userAddress: getAddress(userAddress),
              ciphertextWithInputVerification: toHexString(ciphertext),
              contractChainId: '0x' + chainId.toString(16),
            };
    
        */
        const payload = this._toMockFhevmRelayerV1InputProofPayload(extraData);
        const mockCiphertextWithZKProof = EthersT.getBytes(payload.ciphertextWithInputVerification);
        /*
          Mock equivalent to https://github.com/zama-ai/fhevm-js/blob/main/src/relayer/sendEncryption.ts
    
            const url = `${relayerUrl}/v1/input-proof`;
            ...
            const response = await fetch(url, options);
            ...
    
          Will add the clear values to the mock database.
        */
        /*
          const payload = {
              contractAddress: getAddress(contractAddress),
              userAddress: getAddress(userAddress),
              ciphertextWithInputVerification: toHexString(ciphertext),
              contractChainId: '0x' + chainId.toString(16),
            };
            const options = {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(payload),
            };
        */
        const response = await relayer.requestRelayerV1InputProof(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_relayerProvider, "f"), payload);
        const handlesBytes32List = FhevmHandle.computeHandles(mockCiphertextWithZKProof, __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fhevmTypes, "f"), __classPrivateFieldGet(this, _MockRelayerEncryptedInput_aclContractAddress, "f"), __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractChainId, "f"), constants.FHEVM_HANDLE_VERSION);
        __classPrivateFieldGet(this, _MockRelayerEncryptedInput_inputVerifier, "f").verifySignatures(handlesBytes32List, __classPrivateFieldGet(this, _MockRelayerEncryptedInput_userAddress, "f"), __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractAddress, "f"), __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractChainId, "f"), extraData, response.signatures);
        const inputProofHex = computeInputProofHex(response.handles, response.signatures, extraData);
        return {
            handles: handlesBytes32List,
            inputProof: EthersT.toBeArray(inputProofHex),
        };
    }
    getBits() {
        throw new FhevmError("ZKInput interface method: Not supported in mock mode");
    }
}
_MockRelayerEncryptedInput_clearTextValues = new WeakMap(), _MockRelayerEncryptedInput_fhevmTypes = new WeakMap(), _MockRelayerEncryptedInput_fheTypes = new WeakMap(), _MockRelayerEncryptedInput_totalFheBits = new WeakMap(), _MockRelayerEncryptedInput_contractChainId = new WeakMap(), _MockRelayerEncryptedInput_contractAddress = new WeakMap(), _MockRelayerEncryptedInput_userAddress = new WeakMap(), _MockRelayerEncryptedInput_relayerProvider = new WeakMap(), _MockRelayerEncryptedInput_aclContractAddress = new WeakMap(), _MockRelayerEncryptedInput_inputVerifier = new WeakMap();
Object.defineProperty(MockRelayerEncryptedInput, "MAX_FHE_BITS", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 2048
});
Object.defineProperty(MockRelayerEncryptedInput, "MAX_VAR_COUNT", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 256
});
//# sourceMappingURL=MockRelayerEncryptedInput.js.map