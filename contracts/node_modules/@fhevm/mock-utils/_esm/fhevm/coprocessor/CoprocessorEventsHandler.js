var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CoprocessorEventsHandler_db, _CoprocessorEventsHandler_counterRand;
import { assertEventArgIsAddress, assertEventArgIsBigUint8, assertEventArgIsBigUint256, assertEventArgIsBytes1String, assertEventArgIsBytes16String, assertEventArgIsBytes32String, assertEventArgIsBytesString, } from "../../ethers/event.js";
import { FhevmError, assertFhevm } from "../../utils/error.js";
import { bitwiseNotUIntBits, getRandomBigInt, log2BigInt } from "../../utils/math.js";
import { FheType } from "../FheType.js";
import { FhevmHandle } from "../FhevmHandle.js";
export class CoprocessorEventsHandler {
    constructor(db) {
        _CoprocessorEventsHandler_db.set(this, void 0);
        _CoprocessorEventsHandler_counterRand.set(this, void 0);
        __classPrivateFieldSet(this, _CoprocessorEventsHandler_db, db, "f");
        __classPrivateFieldSet(this, _CoprocessorEventsHandler_counterRand, 0, "f");
    }
    get counterRand() {
        return __classPrivateFieldGet(this, _CoprocessorEventsHandler_counterRand, "f");
    }
    async handleEvent(coprocessorEvent) {
        var _a;
        // Should be properly handled by the event iterator
        assertFhevm(coprocessorEvent.blockNumber >= __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").fromBlockNumber, "coprocessorEvent.blockNumber < this.#db.fromBlockNumber");
        // if (coprocessorEvent.blockNumber < this.#db.fromBlockNumber) {
        //   // ignore, the db exclusively contains handles generated from `firstBlockNumber` and above.
        //   console.log(
        //     `coprocessorEvent.blockNumber=${coprocessorEvent.blockNumber} < db.firstBlockNumber=${this.#db.fromBlockNumber}`,
        //   );
        //   return;
        // }
        if (coprocessorEvent.eventName === "VerifyCiphertext") {
            await this.verifyCipherText(coprocessorEvent.args);
        }
        else {
            const res = await this.executeCoprocessorEvent(coprocessorEvent);
            if (res) {
                await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").insertHandleBytes32(res.resultBytes32, res.clearText, {
                    index: coprocessorEvent.index,
                    blockNumber: coprocessorEvent.blockNumber,
                    transactionHash: coprocessorEvent.transactionHash,
                }, res.replace !== undefined ? { replace: res.replace } : undefined);
                if (coprocessorEvent.eventName === "FheRandBounded" || coprocessorEvent.eventName === "FheRand") {
                    __classPrivateFieldSet(this, _CoprocessorEventsHandler_counterRand, (_a = __classPrivateFieldGet(this, _CoprocessorEventsHandler_counterRand, "f"), _a++, _a), "f");
                }
            }
        }
    }
    async executeCoprocessorEvent(event) {
        switch (event.eventName) {
            case "TrivialEncrypt": {
                // event TrivialEncrypt(address indexed caller, uint256 pt, FheType toType, bytes32 result);
                const ptUint256 = event.args[1];
                const fheType = event.args[2];
                const resultBytes32 = event.args[3];
                assertEventArgIsBigUint256(ptUint256, "TrivialEncrypt", 1);
                assertEventArgIsBigUint256(fheType, "TrivialEncrypt", 2);
                assertEventArgIsBytes32String(resultBytes32, "TrivialEncrypt", 3);
                return {
                    resultBytes32,
                    clearText: ptUint256,
                };
            }
            case "TrivialEncryptBytes": {
                // event TrivialEncryptBytes(address indexed caller, bytes pt, FheType toType, bytes32 result);
                const ptBytes = event.args[1];
                const resultBytes32 = event.args[3];
                assertEventArgIsBytesString(ptBytes, "TrivialEncryptBytes", 1);
                assertEventArgIsBytes32String(resultBytes32, "TrivialEncrypt", 3);
                return {
                    resultBytes32,
                    clearText: ptBytes,
                };
            }
            case "FheAdd": {
                // event FheAdd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt + binaryOp.clearTextRhsBigInt;
                // Clamp
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheSub": {
                // event FheSub(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt - binaryOp.clearTextRhsBigInt;
                // Clamp
                if (clearText < 0n)
                    clearText = clearText + 2n ** binaryOp.clearTextBitLength;
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheMul": {
                // event FheMul(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt * binaryOp.clearTextRhsBigInt;
                // Clamp
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheDiv": {
                // event FheDiv(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                if (!binaryOp.scalar) {
                    throw new Error("Non-scalar div not implemented yet");
                }
                // Check division by zero ?
                const clearText = binaryOp.clearTextLhsBigInt / binaryOp.clearTextRhsBigInt;
                // No Clamp needed
                // clearText = clearText % 2n ** binaryOp.numBits;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheRem": {
                //event FheRem(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                if (!binaryOp.scalar) {
                    throw new Error("Non-scalar rem not implemented yet");
                }
                // Check division by zero ?
                const clearText = binaryOp.clearTextLhsBigInt % binaryOp.clearTextRhsBigInt;
                // No Clamp needed
                // clearText = clearText % 2n ** binaryOp.numBits;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheBitAnd": {
                // event FheBitAnd(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt & binaryOp.clearTextRhsBigInt;
                // Clamp
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheBitOr": {
                // event FheBitOr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt | binaryOp.clearTextRhsBigInt;
                // Clamp
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheBitXor": {
                // event FheBitXor(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt ^ binaryOp.clearTextRhsBigInt;
                // Clamp
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheShl": {
                // event FheShl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt << binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
                // Clamp
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheShr": {
                // event FheShr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result);
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt >> binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
                // Clamp
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheRotl": {
                // "event FheRotl(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const shift = binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
                let clearText = (binaryOp.clearTextLhsBigInt << shift) |
                    (binaryOp.clearTextLhsBigInt >> (binaryOp.clearTextBitLength - shift));
                // Clamp
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheRotr": {
                // "event FheRotr(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const shift = binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
                let clearText = (binaryOp.clearTextLhsBigInt >> shift) |
                    (binaryOp.clearTextLhsBigInt << (binaryOp.clearTextBitLength - shift));
                // Clamp
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheEq": {
                // "event FheEq(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheEqBytes": {
                // "event FheEqBytes(address indexed caller, bytes32 lhs, bytes rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryBytesOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheNe": {
                // "event FheNe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 0n : 1n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheNeBytes": {
                // "event FheNeBytes(address indexed caller, bytes32 lhs, bytes rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryBytesOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt !== binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheGe": {
                // "event FheGe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt >= binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheGt": {
                // "event FheGt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt > binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheLe": {
                // "event FheLe(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt <= binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheLt": {
                // "event FheLt(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt < binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheMin": {
                // "event FheMin(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt < binaryOp.clearTextRhsBigInt
                    ? binaryOp.clearTextLhsBigInt
                    : binaryOp.clearTextRhsBigInt;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheMax": {
                // "event FheMax(address indexed caller, bytes32 lhs, bytes32 rhs, bytes1 scalarByte, bytes32 result)",
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt > binaryOp.clearTextRhsBigInt
                    ? binaryOp.clearTextLhsBigInt
                    : binaryOp.clearTextRhsBigInt;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheNot": {
                // "event FheNot(address indexed caller, bytes32 ct, bytes32 result)",
                const unaryOp = await this.parseUnaryOpEvent(event);
                const clearText = bitwiseNotUIntBits(unaryOp.clearTextBigInt, unaryOp.clearTextBitLength);
                return {
                    resultBytes32: unaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheNeg": {
                // "event FheNeg(address indexed caller, bytes32 ct, bytes32 result)",
                const unaryOp = await this.parseUnaryOpEvent(event);
                let clearText = bitwiseNotUIntBits(unaryOp.clearTextBigInt, unaryOp.clearTextBitLength);
                // Clamp
                clearText = (clearText + 1n) % 2n ** unaryOp.clearTextBitLength;
                return {
                    resultBytes32: unaryOp.resultBytes32,
                    clearText,
                };
            }
            case "Cast": {
                // "event Cast(address indexed caller, bytes32 ct, uint8 toType, bytes32 result)",
                const ctBytes32 = event.args[1];
                const toTypeUint8 = event.args[2];
                const resultBytes32 = event.args[3];
                assertEventArgIsBytes32String(ctBytes32, event.eventName, 1);
                assertEventArgIsBigUint8(toTypeUint8, event.eventName, 2);
                assertEventArgIsBytes32String(resultBytes32, event.eventName, 3);
                const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
                const resultType = resultFhevmHandle.fheType;
                const clearTextBitLength = BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength);
                assertFhevm(BigInt(resultType) === toTypeUint8, `Cast type mismatch, (resultType:${resultType}) !== (toTypeUint8:${toTypeUint8})`);
                const ct = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ctBytes32)).clearTextHex);
                const clearText = ct % 2n ** clearTextBitLength;
                return {
                    resultBytes32,
                    clearText,
                };
            }
            case "FheIfThenElse": {
                // "event FheIfThenElse(address indexed caller, bytes32 control, bytes32 ifTrue, bytes32 ifFalse, bytes32 result)",
                const controlBytes32 = event.args[1];
                const ifTrueBytes32 = event.args[2];
                const ifFalseBytes32 = event.args[3];
                const resultBytes32 = event.args[4];
                assertEventArgIsBytes32String(controlBytes32, event.eventName, 1);
                assertEventArgIsBytes32String(ifTrueBytes32, event.eventName, 2);
                assertEventArgIsBytes32String(ifFalseBytes32, event.eventName, 3);
                assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);
                const control = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(controlBytes32)).clearTextHex);
                const ifTrue = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ifTrueBytes32)).clearTextHex);
                const ifFalse = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ifFalseBytes32)).clearTextHex);
                assertFhevm(control === 0n || control === 1n, `Unexpected FheIfThenElse control value. Got ${control}, expecting 0 or 1`);
                const clearText = control === 1n ? ifTrue : ifFalse;
                return {
                    resultBytes32,
                    clearText,
                };
            }
            case "FheRand": {
                // "event FheRand(address indexed caller, uint8 randType, bytes16 seed, bytes32 result)",
                const randTypeUint8 = event.args[1];
                const seedBytes16 = event.args[2];
                const resultBytes32 = event.args[3];
                assertEventArgIsBigUint8(randTypeUint8, event.eventName, 1);
                assertEventArgIsBytes16String(seedBytes16, event.eventName, 2);
                assertEventArgIsBytes32String(resultBytes32, event.eventName, 3);
                const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
                const resultType = resultFhevmHandle.fheType;
                const clearTextBitLength = resultFhevmHandle.fhevmTypeInfo.clearTextBitLength;
                assertFhevm(BigInt(resultType) === randTypeUint8, `Rand type mismatch, (resultType:${resultType}) !== (randTypeUint8:${randTypeUint8})`);
                //EthersT.randomBytes
                const clearText = getRandomBigInt(clearTextBitLength);
                return {
                    resultBytes32,
                    clearText,
                    replace: true,
                };
            }
            case "FheRandBounded": {
                // "event FheRandBounded(address indexed caller, uint256 upperBound, uint8 randType, bytes16 seed, bytes32 result)",
                const upperBoundUint256 = event.args[1];
                const randTypeUint8 = event.args[2];
                const seedBytes16 = event.args[3];
                const resultBytes32 = event.args[4];
                assertEventArgIsBigUint256(upperBoundUint256, event.eventName, 1);
                assertEventArgIsBigUint8(randTypeUint8, event.eventName, 2);
                assertEventArgIsBytes16String(seedBytes16, event.eventName, 3);
                assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);
                const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
                const resultType = resultFhevmHandle.fheType;
                assertFhevm(BigInt(resultType) === randTypeUint8, `Rand type mismatch, (resultType:${resultType}) !== (randTypeUint8:${randTypeUint8})`);
                const clearText = getRandomBigInt(Number(log2BigInt(upperBoundUint256)));
                return {
                    resultBytes32,
                    clearText,
                    replace: true,
                };
            }
        }
        throw new FhevmError(`Unknown fhevm coprocessor event: ${event.eventName}`);
    }
    async verifyCipherText(eventArgs) {
        /*
          event VerifyCiphertext(
              address indexed caller,
              bytes32 inputHandle,
              address userAddress,
              bytes inputProof,
              FheType inputType,
              bytes32 result
          );
        */
        const inputHandleBytes32 = eventArgs[1];
        const userAddress = eventArgs[2];
        const inputProofBytes = eventArgs[3];
        const fheType = eventArgs[4];
        const resultBytes32 = eventArgs[5];
        assertEventArgIsBytes32String(inputHandleBytes32, "VerifyCipherText", 1);
        assertEventArgIsAddress(userAddress, "VerifyCipherText", 2);
        assertEventArgIsBytesString(inputProofBytes, "VerifyCipherText", 3);
        assertEventArgIsBigUint256(fheType, "VerifyCipherText", 4);
        assertEventArgIsBytes32String(resultBytes32, "VerifyCipherText", 5);
        // At this point 'inputHandle' equals 'result'
        // See FHEVMExectuorNoEvents.sol + InputVerifier.sol
        assertFhevm(inputHandleBytes32 === resultBytes32, `VerifyCipherText: inputHandleBytes32=${inputHandleBytes32} differs from resultBytes32=${resultBytes32}`);
        try {
            await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(inputHandleBytes32);
        }
        catch {
            throw new FhevmError(`User input was not found in DB inputHandle=${inputHandleBytes32}`);
        }
    }
    async parseUnaryOpEvent(event) {
        const ctBytes32 = event.args[1];
        const resultBytes32 = event.args[2];
        assertEventArgIsBytes32String(ctBytes32, event.eventName, 1);
        assertEventArgIsBytes32String(resultBytes32, event.eventName, 2);
        const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
        const clearTextBigInt = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ctBytes32)).clearTextHex);
        return {
            resultBytes32,
            clearTextBigInt,
            clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength),
        };
    }
    async parseBinaryOpEvent(event) {
        const lhsBytes32 = event.args[1];
        const rhsBytes32 = event.args[2];
        const scalarBytes1 = event.args[3];
        const resultBytes32 = event.args[4];
        assertEventArgIsBytes32String(lhsBytes32, event.eventName, 1);
        assertEventArgIsBytes32String(rhsBytes32, event.eventName, 2);
        assertEventArgIsBytes1String(scalarBytes1, event.eventName, 3);
        assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);
        const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
        const scalar = scalarBytes1 === "0x01";
        const clearTextLhsBigInt = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(lhsBytes32)).clearTextHex);
        const clearTextRhsBigInt = scalar
            ? BigInt(rhsBytes32)
            : BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(rhsBytes32)).clearTextHex);
        return {
            resultBytes32,
            clearTextLhsBigInt,
            clearTextRhsBigInt,
            scalar,
            clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength),
        };
    }
    async parseBinaryBytesOpEvent(event) {
        const lhsBytes32 = event.args[1];
        const rhsBytes = event.args[2];
        const scalarBytes1 = event.args[3];
        const resultBytes32 = event.args[4];
        assertEventArgIsBytes32String(lhsBytes32, event.eventName, 1);
        assertEventArgIsBytesString(rhsBytes, event.eventName, 2);
        assertEventArgIsBytes1String(scalarBytes1, event.eventName, 3);
        assertEventArgIsBytes32String(resultBytes32, event.eventName, 4);
        const resultFhevmHandle = FhevmHandle.fromBytes32Hex(resultBytes32);
        const scalar = scalarBytes1 === "0x01";
        const clearTextLhsBigInt = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(lhsBytes32)).clearTextHex);
        const clearTextRhsBigInt = scalar
            ? BigInt(rhsBytes)
            : BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(rhsBytes)).clearTextHex);
        return {
            resultBytes32,
            clearTextLhsBigInt,
            clearTextRhsBigInt,
            scalar,
            clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength),
        };
    }
}
_CoprocessorEventsHandler_db = new WeakMap(), _CoprocessorEventsHandler_counterRand = new WeakMap();
//# sourceMappingURL=CoprocessorEventsHandler.js.map