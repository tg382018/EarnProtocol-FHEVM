var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockFhevmInstanceConfig_contractsRepository, _MockFhevmInstanceConfig_gatewayChainId, _MockFhevmInstanceConfig_chainId, _MockFhevmInstanceConfig_verifyingContractAddressDecryption, _MockFhevmInstanceConfig_verifyingContractAddressInputVerification, _MockFhevmInstanceConfig_relayerUrl, _MockFhevmInstanceConfig_networkUrl, _MockFhevmInstanceConfig_relayerProvider, _MockFhevmInstanceConfig_readonlyRunner, _MockFhevmInstanceConfig_kmsSigners, _MockFhevmInstanceConfig_coprocessorSigners;
import { ethers as EthersT } from "ethers";
import constants from "../constants.js";
import { getProviderChainId } from "../ethers/provider.js";
import { defaultWalletsAsMap, walletsFromPrivateKeys } from "../ethers/wallet.js";
import { FhevmError, assertFhevm } from "../utils/error.js";
import { FhevmContractsRepository } from "./contracts/FhevmContractsRepository.js";
import { requestRelayerMetadata } from "./relayer/MockRelayer.js";
export class MockFhevmInstanceConfig {
    //#relayerSignerPrivateKey
    constructor() {
        _MockFhevmInstanceConfig_contractsRepository.set(this, void 0);
        _MockFhevmInstanceConfig_gatewayChainId.set(this, void 0);
        _MockFhevmInstanceConfig_chainId.set(this, void 0);
        _MockFhevmInstanceConfig_verifyingContractAddressDecryption.set(this, void 0);
        _MockFhevmInstanceConfig_verifyingContractAddressInputVerification.set(this, void 0);
        _MockFhevmInstanceConfig_relayerUrl.set(this, void 0);
        _MockFhevmInstanceConfig_networkUrl.set(this, void 0);
        _MockFhevmInstanceConfig_relayerProvider.set(this, void 0);
        _MockFhevmInstanceConfig_readonlyRunner.set(this, void 0);
        // Belongs to a "engine" config. Should be removed
        _MockFhevmInstanceConfig_kmsSigners.set(this, void 0);
        _MockFhevmInstanceConfig_coprocessorSigners.set(this, void 0);
    }
    static async formConfig(config, options) {
        const mockConfig = new MockFhevmInstanceConfig();
        _checkConfigStringProperty(config, "network", "url");
        _checkConfigStringProperty(config, "relayerUrl", "url");
        __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_networkUrl, config.network, "f");
        __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_relayerUrl, config.relayerUrl, "f");
        __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_readonlyRunner, new EthersT.JsonRpcProvider(__classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_networkUrl, "f")), "f");
        __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_relayerProvider, new EthersT.JsonRpcProvider(__classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_relayerUrl, "f")), "f");
        _checkConfigAddressProperty(config, "aclContractAddress");
        _checkConfigAddressProperty(config, "kmsContractAddress");
        _checkConfigAddressProperty(config, "verifyingContractAddressDecryption");
        _checkConfigAddressProperty(config, "verifyingContractAddressInputVerification");
        _checkConfigAddressProperty(config, "inputVerifierContractAddress");
        const relayerMetadata = await requestRelayerMetadata(__classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_relayerProvider, "f"));
        if (relayerMetadata.ACLAddress !== config.aclContractAddress) {
            throw new FhevmError(`ACL address mismatch: the network '${config.network}' is using ACL address ${relayerMetadata.ACLAddress}, but 'FhevmInstanceConfig.aclContractAddress' is set to ${config.aclContractAddress}. Please update the config to match the specified network.`);
        }
        if (relayerMetadata.InputVerifierAddress !== config.inputVerifierContractAddress) {
            throw new FhevmError(`InputVerifier address mismatch: the network '${config.network}' is using InputVerifier address ${relayerMetadata.InputVerifierAddress}, but 'FhevmInstanceConfig.inputVerifierContractAddress' is set to ${config.inputVerifierContractAddress}. Please update the config to match the specified network.`);
        }
        if (relayerMetadata.KMSVerifierAddress !== config.kmsContractAddress) {
            throw new FhevmError(`KMSVerifier address mismatch: the network '${config.network}' is using KMSVerifier address ${relayerMetadata.KMSVerifierAddress}, but 'FhevmInstanceConfig.kmsContractAddress' is set to ${config.kmsContractAddress}. Please update the config to match the specified network.`);
        }
        // Verify!
        const networkChainId = await getProviderChainId(__classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_readonlyRunner, "f"));
        if (networkChainId !== undefined && networkChainId !== null) {
            config.chainId = networkChainId;
        }
        _checkConfigNumberProperty(config, "chainId");
        if (networkChainId !== config.chainId) {
            throw new FhevmError(`Chain ID mismatch: the network '${config.network}' is using chain ID ${networkChainId}, but 'FhevmInstanceConfig.chainId' is set to ${config.chainId}. Please update the config to match the specified network.`);
        }
        _checkConfigNumberProperty(config, "gatewayChainId");
        if (options?.noMetamaskChainSwap === true) {
            // In mock mode, to avoid Metamask chain swap, gatewayChainId and chainId must be the same
            __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_gatewayChainId, networkChainId, "f");
        }
        __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_contractsRepository, await FhevmContractsRepository.create(__classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_readonlyRunner, "f"), config), "f");
        __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_verifyingContractAddressDecryption, config.verifyingContractAddressDecryption, "f");
        __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_verifyingContractAddressInputVerification, config.verifyingContractAddressInputVerification, "f");
        if (__classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_contractsRepository, "f").inputVerifier.address.toLowerCase() !==
            config.inputVerifierContractAddress.toLocaleLowerCase()) {
            throw new FhevmError(`InputVerifier address mismatch: the ACL contract at '${config.aclContractAddress}' on network '${config.network}' (chainId: ${config.chainId}) is using InputVerifier at '${__classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_contractsRepository, "f").inputVerifier.address}', but 'FhevmInstanceConfig.inputVerifierContractAddress' is set to '${config.inputVerifierContractAddress}'. Please update the configuration to match.`);
        }
        // Resolve kms signers wallets
        __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_kmsSigners, _loadSignersCategory({
            categoryName: "KMS",
            default: constants.DEFAULT_KMS_SIGNERS_ACCOUNTS,
            ...(options?.kmsSignersPrivateKeys !== undefined && { privateKeys: options?.kmsSignersPrivateKeys }),
            signersAddresses: __classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_contractsRepository, "f").kmsVerifier.getKmsSignersAddresses(),
            threshold: __classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_contractsRepository, "f").kmsVerifier.getThreshold(),
        }), "f");
        // Resolve coprocessor signers wallets
        __classPrivateFieldSet(mockConfig, _MockFhevmInstanceConfig_coprocessorSigners, _loadSignersCategory({
            categoryName: "Coprocessor",
            default: constants.DEFAULT_COPROCESSOR_SIGNERS_ACCOUNTS,
            ...(options?.coprocessorSignersPrivateKeys !== undefined && {
                privateKeys: options?.coprocessorSignersPrivateKeys,
            }),
            signersAddresses: __classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_contractsRepository, "f").inputVerifier.getCoprocessorSigners(),
            threshold: __classPrivateFieldGet(mockConfig, _MockFhevmInstanceConfig_contractsRepository, "f").inputVerifier.getThreshold(),
        }), "f");
        return mockConfig;
    }
    get readonlyRunner() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_readonlyRunner, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_readonlyRunner, "f");
    }
    get relayerProvider() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_relayerProvider, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_relayerProvider, "f");
    }
    get contractsRepository() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_contractsRepository, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_contractsRepository, "f");
    }
    get network() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_networkUrl, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_networkUrl, "f");
    }
    get relayerUrl() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_relayerUrl, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_relayerUrl, "f");
    }
    get chainId() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_chainId, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_chainId, "f");
    }
    get aclContractAddress() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_contractsRepository, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_contractsRepository, "f").acl.address;
    }
    get kmsContractAddress() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_contractsRepository, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_contractsRepository, "f").kmsVerifier.address;
    }
    get inputVerifierContractAddress() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_contractsRepository, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_contractsRepository, "f").inputVerifier.address;
    }
    get gatewayChainId() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_gatewayChainId, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_gatewayChainId, "f");
    }
    get verifyingContractAddressDecryption() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_verifyingContractAddressDecryption, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_verifyingContractAddressDecryption, "f");
    }
    get verifyingContractAddressInputVerification() {
        assertFhevm(__classPrivateFieldGet(this, _MockFhevmInstanceConfig_verifyingContractAddressInputVerification, "f") !== undefined, "MockFhevmInstanceConfig is not initialized");
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_verifyingContractAddressInputVerification, "f");
    }
    get kmsSigners() {
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_kmsSigners, "f");
    }
    get coprocessorSigners() {
        return __classPrivateFieldGet(this, _MockFhevmInstanceConfig_coprocessorSigners, "f");
    }
}
_MockFhevmInstanceConfig_contractsRepository = new WeakMap(), _MockFhevmInstanceConfig_gatewayChainId = new WeakMap(), _MockFhevmInstanceConfig_chainId = new WeakMap(), _MockFhevmInstanceConfig_verifyingContractAddressDecryption = new WeakMap(), _MockFhevmInstanceConfig_verifyingContractAddressInputVerification = new WeakMap(), _MockFhevmInstanceConfig_relayerUrl = new WeakMap(), _MockFhevmInstanceConfig_networkUrl = new WeakMap(), _MockFhevmInstanceConfig_relayerProvider = new WeakMap(), _MockFhevmInstanceConfig_readonlyRunner = new WeakMap(), _MockFhevmInstanceConfig_kmsSigners = new WeakMap(), _MockFhevmInstanceConfig_coprocessorSigners = new WeakMap();
function _checkConfigAddressProperty(config, propertyName) {
    _checkConfigStringProperty(config, propertyName, "address");
    if (!EthersT.isAddress(config[propertyName])) {
        throw new FhevmError(`Invalid '${propertyName}' entry in FhevmInstanceConfig. Expecting valid a address, got '${config[propertyName]}' instead.`);
    }
}
function _checkConfigStringProperty(config, propertyName, typeName) {
    if (typeof config !== "object" || config === null) {
        throw new FhevmError(`Invalid in FhevmInstanceConfig object.`);
    }
    const p = config[propertyName];
    if (!typeName) {
        typeName = "string";
    }
    if (p === undefined || p === null) {
        throw new FhevmError(`Missing '${propertyName}' entry in FhevmInstanceConfig. Expecting a valid ${typeName}.`);
    }
    if (typeof p !== "string") {
        throw new FhevmError(`Invalid '${propertyName}' entry in FhevmInstanceConfig. Expecting a valid ${typeName}, got '${p}' instead.`);
    }
}
function _checkConfigNumberProperty(config, propertyName, typeName) {
    if (typeof config !== "object" || config === null) {
        throw new FhevmError(`Invalid in FhevmInstanceConfig object.`);
    }
    const p = config[propertyName];
    if (!typeName) {
        typeName = "number";
    }
    if (p === undefined || p === null) {
        throw new FhevmError(`Missing '${propertyName}' entry in FhevmInstanceConfig. Expecting a valid ${typeName}.`);
    }
    if (typeof p !== "number") {
        throw new FhevmError(`Invalid '${propertyName}' entry in FhevmInstanceConfig. Expecting a valid ${typeName}, got '${p}' instead.`);
    }
}
function _loadSignersCategory(signersCategory) {
    let resolvedSigners = [];
    if (signersCategory.privateKeys) {
        const { wallets, ignoredPrivateKeys } = walletsFromPrivateKeys(signersCategory.privateKeys, signersCategory.signersAddresses);
        if (ignoredPrivateKeys.length > 0) {
            throw new FhevmError(`The following private keys do not match any of the expected ${signersCategory.categoryName} signers addresses. Ignored private keys: ${ignoredPrivateKeys.join(", ")}.`);
        }
        resolvedSigners = wallets;
    }
    else {
        // Try with default signers
        const wallets = defaultWalletsAsMap(signersCategory.default.initialIndex, signersCategory.threshold, signersCategory.default.path, signersCategory.default.mnemonic);
        for (let i = 0; i < signersCategory.signersAddresses.length; ++i) {
            const w = wallets.get(signersCategory.signersAddresses[i]);
            if (w) {
                resolvedSigners.push(w);
            }
        }
    }
    if (!resolvedSigners || resolvedSigners.length === 0) {
        throw new FhevmError(`Missing ${signersCategory.categoryName} signers. Please specify the KMS signers private keys.`);
    }
    if (resolvedSigners.length < signersCategory.threshold) {
        throw new FhevmError(`Not enought ${signersCategory.categoryName} signers. A minimum of ${signersCategory.threshold} ${signersCategory.categoryName} signers are expected. ${signersCategory.threshold - signersCategory.signersAddresses.length} private keys are missing.`);
    }
    return resolvedSigners;
}
//# sourceMappingURL=MockFhevmInstanceConfig.js.map