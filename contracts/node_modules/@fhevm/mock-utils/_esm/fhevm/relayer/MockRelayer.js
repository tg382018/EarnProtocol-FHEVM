import { minimalProviderSend } from "../../ethers/provider.js";
import { FHEVM_AWAIT_DECRYPTION_ORACLE, FHEVM_CREATE_DECRYPTION_SIGNATURES, FHEVM_GET_CLEAR_TEXT, RELAYER_METADATA, RELAYER_V1_INPUT_PROOF, RELAYER_V1_PUBLIC_DECRYPT, RELAYER_V1_USER_DECRYPT, } from "./methods.js";
import { assertIsMockRelayerV1InputProofPayload } from "./mock_payloads.js";
import { assertIsRelayerMetadata, assertIsRelayerV1InputProofResponse, assertIsRelayerV1PublicDecryptPayload, assertIsRelayerV1PublicDecryptResponse, assertIsRelayerV1UserDecryptPayload, assertIsRelayerV1UserDecryptResponse, } from "./payloads.js";
// To be changed into a FhevmMockRelayerProvider class
/**
 * Equivalent to const response = await fetch(`${relayerUrl}/v1/input-proof`, options);
 */
export async function requestRelayerV1InputProof(relayerProvider, payload) {
    assertIsMockRelayerV1InputProofPayload(payload);
    const response = await minimalProviderSend(relayerProvider, RELAYER_V1_INPUT_PROOF, [payload]);
    assertIsRelayerV1InputProofResponse(response);
    return response;
}
/**
 * Equivalent to const response = await fetch(`${relayerUrl}/v1/user-decrypt`, options);
 */
export async function requestRelayerV1UserDecrypt(relayerProvider, payload) {
    assertIsRelayerV1UserDecryptPayload(payload);
    const response = await minimalProviderSend(relayerProvider, RELAYER_V1_USER_DECRYPT, [payload]);
    assertIsRelayerV1UserDecryptResponse(response);
    return { response: [response] };
}
/**
 * Equivalent to const response = await fetch(`${relayerUrl}/v1/public-decrypt`, options);
 */
export async function requestRelayerV1PublicDecrypt(relayerProvider, payload) {
    assertIsRelayerV1PublicDecryptPayload(payload);
    const response = await minimalProviderSend(relayerProvider, RELAYER_V1_PUBLIC_DECRYPT, [payload]);
    assertIsRelayerV1PublicDecryptResponse(response);
    return { response: [response] };
}
/**
 * Custom, returns Fhevm addresses expected by the relayer.
 */
export async function requestRelayerMetadata(relayerProvider) {
    const response = await minimalProviderSend(relayerProvider, RELAYER_METADATA, []);
    assertIsRelayerMetadata(response);
    return response;
}
export async function requestFhevmAwaitDecryptionOracle(relayerProvider) {
    return await minimalProviderSend(relayerProvider, FHEVM_AWAIT_DECRYPTION_ORACLE, []);
}
export async function requestFhevmGetClearText(relayerProvider, payload) {
    return await minimalProviderSend(relayerProvider, FHEVM_GET_CLEAR_TEXT, [payload]);
}
export async function requestFhevmCreateDecryptionSignatures(relayerProvider, payload) {
    return await minimalProviderSend(relayerProvider, FHEVM_CREATE_DECRYPTION_SIGNATURES, [payload]);
}
//# sourceMappingURL=MockRelayer.js.map