import { ethers as EthersT } from "ethers";
import constants from "../constants.js";
import { assertIsAddress } from "../utils/address.js";
import { FhevmError } from "../utils/error.js";
import { verifyKeypair } from "../utils/keypair.js";
import { toUIntNumber } from "../utils/math.js";
import { timestampNow } from "../utils/time.js";
import { FhevmHandle } from "./FhevmHandle.js";
export async function userDecryptHandleBytes32(instance, handleContractPairs, user, options) {
    // Verify that contract addresses are well formed.
    _assertIsContractAddressesArray(handleContractPairs);
    // Resolve missing options (instance, keypair etc.)
    const userDecryptArgs = await _resolveUserDecryptOptions(instance, options);
    // extract chainId from instance (FhevmInstance is missing getChainId function)
    const chainId = _getFhevmInstanceChainId(instance);
    // Verify Fhevm handles
    _verifyFhevmHandleContractPairs(handleContractPairs, chainId);
    // Compute signature and list of contract addresses extracted and sorted from the handle/contract pairs
    const { signature, contractAddresses } = await _computeUserSignatureAndContractAddresses(instance, handleContractPairs, user, userDecryptArgs);
    // Prepare final arguments:
    // - user address
    // - array of CtHandleContractPair
    const userAddress = await user.getAddress();
    const handles = handleContractPairs.map((p) => {
        return { handle: p.handleBytes32, contractAddress: p.contractAddress };
    });
    // Call FhevmInstance userDecrypt
    const decryptedHandles = await instance.userDecrypt(handles, userDecryptArgs.keypair.privateKey, userDecryptArgs.keypair.publicKey, signature, contractAddresses, userAddress, userDecryptArgs.startTimestamp, userDecryptArgs.durationDays);
    return decryptedHandles;
}
/**
 * - Creates a new FhevmInstance if needed.
 * - Generates a new FhevmKeypair or checks a given FhevmKeypair passed as argument.
 * - Generates a new FhevmUserDecryptValidity object or checks a given FhevmUserDecryptValidity passed as argument.
 */
async function _resolveUserDecryptOptions(instance, options) {
    let keypair;
    if (options?.keypair !== undefined) {
        keypair = { ...options.keypair };
        verifyKeypair(keypair);
    }
    else {
        keypair = instance.generateKeypair();
    }
    const startTimestamp = options?.validity?.startTimestamp || timestampNow();
    const durationDays = options?.validity?.durationDays || constants.DEFAULT_DURATION_DAYS;
    const startTimestampNumber = toUIntNumber(startTimestamp, "startTimeStamp");
    const durationDaysNumber = toUIntNumber(durationDays, "durationDays");
    return {
        keypair,
        startTimestamp: startTimestampNumber,
        durationDays: durationDaysNumber,
    };
}
async function _computeUserSignatureAndContractAddresses(instance, contractAddresses, user, userDecryptArgs) {
    if (contractAddresses.length === 0) {
        throw new FhevmError("Empty list of contract addresses.");
    }
    // We use a deterministic method for convenience. (in case we need to rebuild the signature).
    const contractAddressesSortUnique = _buildDeterministicContractAddressesList(contractAddresses);
    if (contractAddressesSortUnique.length === 0) {
        throw new FhevmError("Empty list of valid contract addresses.");
    }
    const eip712 = instance.createEIP712(userDecryptArgs.keypair.publicKey, contractAddressesSortUnique, userDecryptArgs.startTimestamp, userDecryptArgs.durationDays);
    const signature = await user.signTypedData(eip712.domain, { UserDecryptRequestVerification: eip712.types.UserDecryptRequestVerification }, eip712.message);
    return {
        signature,
        contractAddresses: contractAddressesSortUnique,
    };
}
function _getFhevmInstanceChainId(instance) {
    const dummyEIP712 = instance.createEIP712("", [EthersT.ZeroAddress], 0, 0);
    return dummyEIP712.message.contractsChainId;
}
function _buildDeterministicContractAddressesList(contractAddresses) {
    const set = new Set();
    // Build a list of unique allowed contact addresses.
    for (let i = 0; i < contractAddresses.length; ++i) {
        const ca = contractAddresses[i];
        let contractAddress;
        if (typeof ca === "string") {
            contractAddress = ca;
        }
        else {
            contractAddress = ca.contractAddress;
        }
        const add = EthersT.getAddress(contractAddress);
        if (!set.has(add)) {
            set.add(add);
        }
    }
    // Sort by alphabetical order, user lowercase comparison
    return [...set].sort((a, b) => {
        const addrA = a.toLowerCase(); // ignore upper and lowercase
        const addrB = b.toLowerCase(); // ignore upper and lowercase
        if (addrA < addrB) {
            return -1;
        }
        if (addrA > addrB) {
            return 1;
        }
        return 0;
    });
}
function _assertIsContractAddressesArray(contractAddresses) {
    if (contractAddresses.length === 0) {
        throw new FhevmError("Empty list of contract addresses.");
    }
    for (let i = 0; i < contractAddresses.length; ++i) {
        const ca = contractAddresses[i];
        let contractAddress;
        if (typeof ca === "string") {
            contractAddress = ca;
        }
        else {
            contractAddress = ca.contractAddress;
        }
        assertIsAddress(contractAddress, "contractAddress");
    }
}
function _verifyFhevmHandleContractPairs(handleContractPairs, chainId) {
    if (handleContractPairs.length === 0) {
        throw new FhevmError("Empty list of handle/contract pairs.");
    }
    for (let i = 0; i < handleContractPairs.length; ++i) {
        const pair = handleContractPairs[i];
        FhevmHandle.verify(pair.handleBytes32, {
            ...(pair.fhevmType !== undefined && { fhevmType: pair.fhevmType }),
            ...(chainId !== undefined && { chainId: chainId }),
        });
        assertIsAddress(pair.contractAddress, "contractAddress");
    }
}
//# sourceMappingURL=userDecrypt.js.map