var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _MockDecryptionOracleDB_map, _MockDecryptionOracle_iterator, _MockDecryptionOracle_handler, _MockDecryptionOracle_readonlyProvider, _MockDecryptionOracle_coprocessor, _MockDecryptionOracle_requestDB, _MockDecryptionOracle_acl, _MockDecryptionOracle_kmsVerifier, _MockDecryptionOracle_kmsSigners;
import { ethers as EthersT } from "ethers";
import { FhevmError, assertFhevm } from "../../utils/error.js";
import { ACL } from "../contracts/ACL.js";
import { KMSVerifier, computeDecryptionSignatures } from "../contracts/KMSVerifier.js";
import { DecryptionOracleEventsHandler } from "./DecryptionOracleEventsHandler.js";
import { DecryptionOracleEventsIterator } from "./DecryptionOracleEventsIterator.js";
import { DecryptionOraclePartialInterface } from "./abi.js";
import { toDecryptionRequestEvent } from "./utils.js";
class MockDecryptionOracleDB {
    constructor() {
        _MockDecryptionOracleDB_map.set(this, new Map());
    }
    static key(event, counterOverride) {
        return `${Number(counterOverride ?? event.counter)}}`;
    }
    tryQuery(event) {
        return __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").get(MockDecryptionOracleDB.key(event));
    }
    delete(event) {
        __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").delete(MockDecryptionOracleDB.key(event));
    }
    setPending(event, evmHasReverted) {
        if (this.has(event) && !evmHasReverted) {
            throw new FhevmError(`Decryption Request counter=${event.counter}, requestID=${event.requestID}, contractCaller=${event.contractCallerAddress} already registered`);
        }
        const entry = {
            event: {
                counter: Number(event.counter),
                requestID: Number(event.requestID),
                contractCallerAddress: event.contractCallerAddress,
                index: event.index,
                blockNumber: event.blockNumber,
                transactionHash: event.transactionHash,
                transactionIndex: event.transactionIndex,
            },
            callbackBlockNumber: -1,
            callbackTransactionHash: undefined,
            callbackReverted: undefined,
            pending: true,
        };
        __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").set(MockDecryptionOracleDB.key(event), entry);
        return entry;
    }
    isPending(event) {
        const entry = __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").get(MockDecryptionOracleDB.key(event));
        if (!entry) {
            return false;
        }
        return entry.pending;
    }
    executed(event) {
        const entry = __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").get(MockDecryptionOracleDB.key(event));
        if (!entry) {
            return false;
        }
        return !entry.pending;
    }
    has(event) {
        return __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").has(MockDecryptionOracleDB.key(event));
    }
}
_MockDecryptionOracleDB_map = new WeakMap();
export class MockDecryptionOracle {
    constructor() {
        _MockDecryptionOracle_iterator.set(this, void 0);
        _MockDecryptionOracle_handler.set(this, void 0);
        _MockDecryptionOracle_readonlyProvider.set(this, void 0);
        _MockDecryptionOracle_coprocessor.set(this, void 0);
        _MockDecryptionOracle_requestDB.set(this, new MockDecryptionOracleDB());
        _MockDecryptionOracle_acl.set(this, void 0);
        _MockDecryptionOracle_kmsVerifier.set(this, void 0);
        _MockDecryptionOracle_kmsSigners.set(this, void 0);
    }
    static async create(readonlyProvider, params) {
        const mdo = new MockDecryptionOracle();
        const db = params.coprocessor.getDB();
        const decryptionOracleContractItf = params.decryptionOracleContractInterface ?? DecryptionOraclePartialInterface;
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_readonlyProvider, readonlyProvider, "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_coprocessor, params.coprocessor, "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_iterator, new DecryptionOracleEventsIterator(decryptionOracleContractItf, params.decryptionOracleContractAddress, readonlyProvider, db.fromBlockNumber), "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_kmsVerifier, await KMSVerifier.create(readonlyProvider, params.kmsVerifierContractAddress), "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_acl, await ACL.create(readonlyProvider, params.aclContractAddress), "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_handler, new DecryptionOracleEventsHandler(db, __classPrivateFieldGet(mdo, _MockDecryptionOracle_kmsVerifier, "f"), params.kmsSigners, params.relayerSigner), "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_kmsSigners, params.kmsSigners, "f");
        return mdo;
    }
    async createDecryptionSignatures(handlesBytes32Hex, clearTextValues, extraData) {
        assertFhevm(__classPrivateFieldGet(this, _MockDecryptionOracle_kmsVerifier, "f") !== undefined, `MockDecryptionOracle not initialized`);
        assertFhevm(__classPrivateFieldGet(this, _MockDecryptionOracle_kmsSigners, "f") !== undefined, `MockDecryptionOracle not initialized`);
        const res = await computeDecryptionSignatures(handlesBytes32Hex, clearTextValues, extraData, EthersT.AbiCoder.defaultAbiCoder(), __classPrivateFieldGet(this, _MockDecryptionOracle_kmsVerifier, "f"), __classPrivateFieldGet(this, _MockDecryptionOracle_kmsSigners, "f"));
        return { decryptedResult: res.decryptedResult, signatures: res.signatures };
    }
    async awaitDecryptionOracle() {
        assertFhevm(__classPrivateFieldGet(this, _MockDecryptionOracle_coprocessor, "f") !== undefined, `MockDecryptionOracle not initialized`);
        assertFhevm(__classPrivateFieldGet(this, _MockDecryptionOracle_iterator, "f") !== undefined, `MockDecryptionOracle not initialized`);
        assertFhevm(__classPrivateFieldGet(this, _MockDecryptionOracle_readonlyProvider, "f") !== undefined, `MockDecryptionOracle not initialized`);
        assertFhevm(__classPrivateFieldGet(this, _MockDecryptionOracle_acl, "f") !== undefined, `MockDecryptionOracle not initialized`);
        assertFhevm(__classPrivateFieldGet(this, _MockDecryptionOracle_handler, "f") !== undefined, `MockDecryptionOracle not initialized`);
        // Required (healthier to do it even if events in empty)
        await __classPrivateFieldGet(this, _MockDecryptionOracle_coprocessor, "f").awaitCoprocessor();
        // Warning test: solidityCoverageRunning
        const { events, evmHasReverted } = await __classPrivateFieldGet(this, _MockDecryptionOracle_iterator, "f").next();
        for (let i = 0; i < events.length; ++i) {
            const dre = toDecryptionRequestEvent(events[i]);
            if (!dre) {
                continue;
            }
            // Should not process an already processed event
            if (__classPrivateFieldGet(this, _MockDecryptionOracle_requestDB, "f").isPending(dre)) {
                throw new FhevmError(`DecryptionRequest requestID=${dre.requestID}, contractCaller=${dre.contractCallerAddress} already being executed.`);
            }
            // First throw if ACL permission failed.
            await __classPrivateFieldGet(this, _MockDecryptionOracle_acl, "f").checkIsAllowedForDecryption(dre.handlesBytes32Hex, __classPrivateFieldGet(this, _MockDecryptionOracle_readonlyProvider, "f"));
            // This is not formally exact. We pass a flag indicating that the evm has reverted to a given
            // snapshot id. This can only occur on dev chains.
            const newEntry = __classPrivateFieldGet(this, _MockDecryptionOracle_requestDB, "f").setPending(dre, evmHasReverted);
            assertFhevm(newEntry.pending);
            assertFhevm(newEntry.callbackBlockNumber === -1);
            assertFhevm(newEntry.callbackReverted === undefined);
            assertFhevm(newEntry.callbackTransactionHash === undefined);
            try {
                const { tx, receipt } = await __classPrivateFieldGet(this, _MockDecryptionOracle_handler, "f").handleEvent(dre);
                newEntry.callbackBlockNumber = receipt?.blockNumber;
                newEntry.callbackReverted = receipt?.status === 0;
                newEntry.callbackTransactionHash = tx.hash;
                newEntry.pending = false;
            }
            catch (e) {
                __classPrivateFieldGet(this, _MockDecryptionOracle_requestDB, "f").delete(dre);
                throw e;
            }
        }
    }
}
_MockDecryptionOracle_iterator = new WeakMap(), _MockDecryptionOracle_handler = new WeakMap(), _MockDecryptionOracle_readonlyProvider = new WeakMap(), _MockDecryptionOracle_coprocessor = new WeakMap(), _MockDecryptionOracle_requestDB = new WeakMap(), _MockDecryptionOracle_acl = new WeakMap(), _MockDecryptionOracle_kmsVerifier = new WeakMap(), _MockDecryptionOracle_kmsSigners = new WeakMap();
//# sourceMappingURL=MockDecryptionOracle.js.map