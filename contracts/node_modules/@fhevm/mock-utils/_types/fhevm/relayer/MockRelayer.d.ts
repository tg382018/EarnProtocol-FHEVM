import { type MinimalProvider } from "../../ethers/provider.js";
import { type MockRelayerV1InputProofPayload } from "./mock_payloads.js";
import type { RelayerMetadata, RelayerV1InputProofResponse, RelayerV1PublicDecryptPayload, RelayerV1PublicDecryptResponse, RelayerV1UserDecryptPayload, RelayerV1UserDecryptResponse } from "./payloads.js";
/**
 * Equivalent to const response = await fetch(`${relayerUrl}/v1/input-proof`, options);
 */
export declare function requestRelayerV1InputProof(relayerProvider: MinimalProvider, payload: MockRelayerV1InputProofPayload): Promise<RelayerV1InputProofResponse>;
/**
 * Equivalent to const response = await fetch(`${relayerUrl}/v1/user-decrypt`, options);
 */
export declare function requestRelayerV1UserDecrypt(relayerProvider: MinimalProvider, payload: RelayerV1UserDecryptPayload): Promise<{
    response: RelayerV1UserDecryptResponse[];
}>;
/**
 * Equivalent to const response = await fetch(`${relayerUrl}/v1/public-decrypt`, options);
 */
export declare function requestRelayerV1PublicDecrypt(relayerProvider: MinimalProvider, payload: RelayerV1PublicDecryptPayload): Promise<{
    response: RelayerV1PublicDecryptResponse[];
}>;
/**
 * Custom, returns Fhevm addresses expected by the relayer.
 */
export declare function requestRelayerMetadata(relayerProvider: MinimalProvider): Promise<RelayerMetadata>;
export declare function requestFhevmAwaitDecryptionOracle(relayerProvider: MinimalProvider): Promise<any>;
export declare function requestFhevmGetClearText(relayerProvider: MinimalProvider, payload: string[]): Promise<any>;
export declare function requestFhevmCreateDecryptionSignatures(relayerProvider: MinimalProvider, payload: {
    handlesBytes32Hex: string[];
    clearTextValuesHex: string[];
    extraData: string;
}): Promise<any>;
//# sourceMappingURL=MockRelayer.d.ts.map