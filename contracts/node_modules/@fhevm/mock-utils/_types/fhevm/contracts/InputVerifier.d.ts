import { ethers as EthersT } from "ethers";
import type { EIP712Domain, EthersEIP712 } from "../../ethers/eip712.js";
import { FhevmCoprocessorContractWrapper } from "./FhevmContractWrapper.js";
export type InputVerifierProperties = {
    signersAddresses?: string[];
    threshold?: number;
    eip712Domain?: EIP712Domain;
};
export declare class InputVerifier extends FhevmCoprocessorContractWrapper {
    #private;
    constructor();
    static create(runner: EthersT.ContractRunner, inputVerifierContractAddress: string, abi?: EthersT.Interface | EthersT.InterfaceAbi, properties?: InputVerifierProperties): Promise<InputVerifier>;
    get readonlyContract(): EthersT.Contract;
    get interface(): EthersT.Interface;
    private _initialize;
    get address(): string;
    get gatewayChainId(): bigint;
    get gatewayInputVerificationAddress(): string;
    get eip712Domain(): EIP712Domain;
    getCoprocessorSigners(): string[];
    getThreshold(): number;
    assertMatchCoprocessorSigners(signers: EthersT.Signer[]): Promise<void>;
    verifySignatures(handlesBytes32List: EthersT.BytesLike[], userAddress: string, contractAddress: string, contractChainId: number, extraData: string, signatures: string[]): void;
    createCiphertextVerificationEIP712(handlesBytes32List: EthersT.BigNumberish[], contractChainId: number, contractAddress: string, userAddress: string, extraData: string): EthersEIP712;
}
export declare function computeInputProofHex(handlesBytes32Hex: string[], coprocessorsSignaturesHex: string[], extraData: string): string;
//# sourceMappingURL=InputVerifier.d.ts.map