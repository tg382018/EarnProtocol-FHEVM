import { ethers as EthersT } from "ethers";
import type { EIP712Domain, EthersEIP712 } from "../../ethers/eip712.js";
import { FhevmCoprocessorContractWrapper } from "./FhevmContractWrapper.js";
export type KMSVerifierProperties = {
    signersAddresses?: string[];
    threshold?: number;
    eip712Domain?: EIP712Domain;
};
export declare class KMSVerifier extends FhevmCoprocessorContractWrapper {
    #private;
    constructor();
    static create(runner: EthersT.ContractRunner, kmsVerifierContractAddress: string, abi?: EthersT.Interface | EthersT.InterfaceAbi, properties?: KMSVerifierProperties): Promise<KMSVerifier>;
    get readonlyContract(): EthersT.Contract;
    get interface(): EthersT.Interface;
    private _initialize;
    get address(): string;
    get gatewayChainId(): bigint;
    get gatewayDecryptionAddress(): string;
    get eip712Domain(): EIP712Domain;
    getKmsSignersAddresses(): string[];
    assertMatchKmsSigners(signers: EthersT.Signer[]): Promise<void>;
    getThreshold(): number;
    createPublicDecryptVerificationEIP712(handlesBytes32List: EthersT.BigNumberish[], decryptedResult: string, extraData: string): EthersEIP712;
}
export declare function computeDecryptionSignatures(handlesBytes32Hex: string[], clearTextValues: (string | bigint | boolean)[], extraData: string, abiCoder: EthersT.AbiCoder, kmsVerifier: KMSVerifier, kmsSigners: EthersT.Signer[]): Promise<{
    signatures: string[];
    types: ReadonlyArray<string | EthersT.ParamType>;
    values: ReadonlyArray<any>;
    decryptedResult: string;
}>;
export declare function computeDecryptionCallbackSignaturesAndCalldata(handlesBytes32Hex: string[], clearTextValuesString: string[], extraData: string, requestID: bigint, callbackSelectorBytes4Hex: string, abiCoder: EthersT.AbiCoder, kmsVerifier: KMSVerifier, kmsSigners: EthersT.Signer[]): Promise<{
    calldata: string;
}>;
//# sourceMappingURL=KMSVerifier.d.ts.map