import { ethers as EthersT } from "ethers";
import type { MinimalProvider } from "../ethers/provider.js";
import type { DecryptedResults, EIP712, FhevmInstance, HandleContractPair, PublicParams } from "../relayer-sdk/types.js";
import { MockRelayerEncryptedInput } from "./MockRelayerEncryptedInput.js";
import { InputVerifier } from "./contracts/InputVerifier.js";
import { KMSVerifier } from "./contracts/KMSVerifier.js";
export type MockFhevmInstanceConfigExtra = {
    relayerProvider: MinimalProvider;
    readonlyEthersProvider: EthersT.Provider;
    inputVerifier: InputVerifier;
    kmsVerifier: KMSVerifier;
};
export type MockFhevmInstanceConfig = {
    verifyingContractAddressDecryption: string;
    verifyingContractAddressInputVerification: string;
    kmsContractAddress: string;
    inputVerifierContractAddress: string;
    aclContractAddress: string;
    chainId: number;
    gatewayChainId: number;
};
export declare class MockFhevmInstance implements FhevmInstance {
    #private;
    private constructor();
    get chainId(): number;
    static create(relayerProvider: MinimalProvider, readonlyEthersProvider: EthersT.Provider, config: MockFhevmInstanceConfig): Promise<MockFhevmInstance>;
    static createEIP712(publicKey: string, contractAddresses: string[], startTimestamp: string | number, durationDays: string | number, verifyingContractAddressDecryption: string, contractsChainId: number): EIP712;
    createEIP712(publicKey: string, contractAddresses: string[], startTimestamp: string | number, durationDays: string | number): EIP712;
    createEncryptedInput(contractAddress: string, userAddress: string): MockRelayerEncryptedInput;
    generateKeypair(): {
        publicKey: string;
        privateKey: string;
    };
    getPublicKey(): {
        publicKeyId: string;
        publicKey: Uint8Array;
    } | null;
    getPublicParams(_bits: keyof PublicParams): {
        publicParams: Uint8Array;
        publicParamsId: string;
    } | null;
    publicDecrypt(handles: (string | Uint8Array)[]): Promise<DecryptedResults>;
    userDecrypt(handles: HandleContractPair[], _privateKey: string, publicKey: string, signature: string, contractAddresses: string[], userAddress: string, startTimestamp: string | number, durationDays: string | number): Promise<DecryptedResults>;
    static verifyUserDecryptSignature(publicKey: string, signature: string, contractAddresses: string[], userAddress: string, startTimestamp: string | number, durationDays: string | number, verifyingContractAddressDecryption: string, contractsChainId: number): Promise<void>;
    static verifyPublicACLPermissions(readonlyEthersProvider: EthersT.Provider, aclContractAddress: string, handles: string[]): Promise<void[]>;
    static verifyUserACLPermissions(readonlyEthersProvider: EthersT.Provider, aclContractAddress: string, handles: HandleContractPair[], userAddress: string): Promise<void[]>;
    static verifyHandleContractAddresses(handles: HandleContractPair[], contractAddresses: string[]): void;
}
//# sourceMappingURL=MockFhevmInstance.d.ts.map