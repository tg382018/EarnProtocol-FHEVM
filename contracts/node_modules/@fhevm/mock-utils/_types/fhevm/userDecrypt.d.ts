import { ethers as EthersT } from "ethers";
import type { DecryptedResults, FhevmInstance } from "../relayer-sdk/types.js";
import type { FhevmType } from "./FhevmType.js";
export type FhevmKeypair = {
    publicKey: string;
    privateKey: string;
};
/**
 * Represents a time-bound validity constraint for a user decryption request.
 *
 * This structure defines a window of time during which a user decryption
 * request is considered valid. It is typically used to ensure that the request
 * cannot be reused or replayed outside of the authorized interval.
 *
 * - `startTimestamp` defines the beginning of the validity window, as a Unix
 *   timestamp in seconds (POSIX time).
 * - `durationDays` defines how long the validity window remains open, measured
 *   in full calendar days.
 *
 * @example
 * const validity: FhevmUserDecryptValidity = {
 *   startTimestamp: Math.floor(Date.now() / 1000), // current time in seconds (POSIX time)
 *   durationDays: 7, // valid for one week
 * };
 */
export type FhevmUserDecryptValidity = {
    /** Start time in seconds since Unix epoch (POSIX time). */
    startTimestamp: EthersT.Numeric;
    /** Duration in days. */
    durationDays: EthersT.Numeric;
};
export type FhevmUserDecryptOptions = {
    instance?: FhevmInstance;
    keypair?: FhevmKeypair;
    validity?: FhevmUserDecryptValidity;
};
export type FhevmPublicDecryptOptions = {
    instance?: FhevmInstance;
};
export declare function userDecryptHandleBytes32(instance: FhevmInstance, handleContractPairs: {
    handleBytes32: string;
    contractAddress: string;
    fhevmType?: FhevmType;
}[], user: EthersT.Signer, options?: Omit<FhevmUserDecryptOptions, "instance">): Promise<DecryptedResults>;
//# sourceMappingURL=userDecrypt.d.ts.map