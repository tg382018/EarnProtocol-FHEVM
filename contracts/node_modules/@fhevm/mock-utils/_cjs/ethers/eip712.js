"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signEIP712 = signEIP712;
exports.multiSignEIP712 = multiSignEIP712;
exports.assertIsEIP712Domain = assertIsEIP712Domain;
exports.isThresholdReached = isThresholdReached;
const ethers_1 = require("ethers");
const error_js_1 = require("../utils/error.js");
const string_js_1 = require("../utils/string.js");
async function signEIP712(signer, domain, types, message) {
    const signature = await signer.signTypedData(domain, types, message);
    const sigRSV = ethers_1.ethers.Signature.from(signature);
    const v = 27 + sigRSV.yParity;
    const r = sigRSV.r;
    const s = sigRSV.s;
    const result = r + (0, string_js_1.removePrefix)(s, "0x") + v.toString(16);
    return result;
}
async function multiSignEIP712(signers, domain, types, message) {
    const signatures = [];
    for (let idx = 0; idx < signers.length; idx++) {
        const signer = signers[idx];
        const signature = await signEIP712(signer, domain, types, message);
        signatures.push(signature);
    }
    return signatures;
}
function assertIsEIP712Domain(eip712Domain, name, expectedDomain) {
    (0, error_js_1.assertFhevm)(Array.isArray(eip712Domain), `Invalid ${name} EIP712 domain`);
    (0, error_js_1.assertFhevm)(eip712Domain.length >= 5, `Invalid ${name} EIP712 domain`);
    (0, error_js_1.assertFhevm)(eip712Domain[1] === expectedDomain.name, `Invalid ${name} EIP712 domain name. Got ${eip712Domain[1]}, expected ${expectedDomain.name}`);
    (0, error_js_1.assertFhevm)(eip712Domain[2] === expectedDomain.version, `Invalid ${name} EIP712 domain name. Got ${eip712Domain[2]}, expected ${expectedDomain.version}`);
    (0, error_js_1.assertFhevm)(eip712Domain[3] === expectedDomain.chainId, `Invalid ${name} EIP712 domain name. Got ${eip712Domain[3]}, expected ${expectedDomain.chainId}`);
    (0, error_js_1.assertFhevm)(eip712Domain[4] === expectedDomain.verifyingContract, `Invalid ${name} EIP712 domain name. Got ${eip712Domain[4]}, expected ${expectedDomain.verifyingContract}`);
}
function isThresholdReached(signersAddress, recoveredAddresses, threshold, signerType) {
    const addressMap = new Map();
    recoveredAddresses.forEach((address, index) => {
        if (addressMap.has(address)) {
            const duplicateValue = address;
            throw new error_js_1.FhevmError(`Duplicate ${signerType} signer address found: ${duplicateValue} appears multiple times in recovered addresses`);
        }
        addressMap.set(address, index);
    });
    for (const address of recoveredAddresses) {
        if (!signersAddress.includes(address)) {
            throw new error_js_1.FhevmError(`Invalid address found: ${address} is not in the list of ${signerType} signers`);
        }
    }
    return recoveredAddresses.length >= threshold;
}
//# sourceMappingURL=eip712.js.map