"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeStorageLocation = computeStorageLocation;
exports.getStorageAt = getStorageAt;
exports.setStorageAt = setStorageAt;
exports.getAddressesFromStorage = getAddressesFromStorage;
exports.getInitializableStorage = getInitializableStorage;
exports.setInitializableStorage = setInitializableStorage;
exports.setOwnableStorage = setOwnableStorage;
const ethers_1 = require("ethers");
const address_js_1 = require("../utils/address.js");
const bytes_js_1 = require("../utils/bytes.js");
const error_js_1 = require("../utils/error.js");
const provider_js_1 = require("./provider.js");
function computeStorageLocation(storageName) {
    const enc = ethers_1.ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [BigInt(ethers_1.ethers.keccak256(ethers_1.ethers.toUtf8Bytes(storageName))) - 1n]);
    return ethers_1.ethers.toBeHex(BigInt(ethers_1.ethers.keccak256(enc)) & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00n, 32);
}
async function getStorageAt(provider, address, index) {
    (0, address_js_1.assertIsAddress)(address);
    const indexParam = ethers_1.ethers.toBeHex(index, 32);
    const data = await (0, provider_js_1.minimalProviderSend)(provider, "eth_getStorageAt", [address, indexParam, "latest"]);
    (0, bytes_js_1.assertIsBytes32String)(data);
    return data;
}
async function setStorageAt(provider, methodName, address, index, valueBytes32) {
    (0, address_js_1.assertIsAddress)(address);
    (0, bytes_js_1.assertIsBytes32String)(valueBytes32);
    if (methodName !== "hardhat_setStorageAt") {
        throw new error_js_1.FhevmError(`Only hardhat_setStorageAt is supported. Got ${methodName} instead.`);
    }
    const indexParam = ethers_1.ethers.toBeHex(index, 32);
    await (0, provider_js_1.minimalProviderSend)(provider, methodName, [address, indexParam, valueBytes32]);
}
async function getAddressesFromStorage(provider, contractAddress, storageLocationBytes32, numAddresses) {
    const addresses = [];
    for (let i = 0; i < numAddresses; ++i) {
        const addr = await getStorageAt(provider, contractAddress, BigInt(storageLocationBytes32) + BigInt(i));
        addresses.push(addr);
    }
    const errorMsg = `The contract at address ${contractAddress} has not been initialized properly.`;
    for (let i = 0; i < numAddresses; ++i) {
        const addr = addresses[i];
        if (typeof addr !== "string" || !ethers_1.ethers.isBytesLike(addr) || addr.length !== 66) {
            throw new error_js_1.FhevmError(errorMsg);
        }
        const hex = ethers_1.ethers.toBeHex(BigInt(addr), 20);
        try {
            addresses[i] = ethers_1.ethers.getAddress(hex);
        }
        catch {
            throw new error_js_1.FhevmError(errorMsg);
        }
    }
    return addresses;
}
async function getInitializableStorage(provider, contractAddress) {
    const storageLocationBytes32 = computeStorageLocation("openzeppelin.storage.Initializable");
    (0, error_js_1.assertFhevm)(storageLocationBytes32 === "0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00", "Wrong 'openzeppelin.storage.Initializable' storage location");
    let data = await getStorageAt(provider, contractAddress, BigInt(storageLocationBytes32) + BigInt(0));
    data = data.replace(/^0x/, "").padStart(64, "0");
    const initializedHex = "0x" + data.slice(-16);
    const initialized = BigInt(initializedHex);
    const initializingByte = parseInt(data.slice(-18, -16), 16);
    const initializing = initializingByte !== 0;
    return { initialized, initializing };
}
async function setInitializableStorage(provider, contractAddress, value) {
    const storageLocationBytes32 = computeStorageLocation("openzeppelin.storage.Initializable");
    (0, error_js_1.assertFhevm)(storageLocationBytes32 === "0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00", "Wrong 'openzeppelin.storage.Initializable' storage location");
    const initializedBytes = ethers_1.ethers.toBeHex(value.initialized, 8);
    const initializingByte = value.initializing ? "0x01" : "0x00";
    const packedHex = initializingByte + initializedBytes.slice(2);
    const paddedSlotValue = ethers_1.ethers.zeroPadValue(packedHex, 32);
    await setStorageAt(provider, "hardhat_setStorageAt", contractAddress, BigInt(storageLocationBytes32) + BigInt(0), paddedSlotValue);
}
async function setOwnableStorage(provider, contractAddress, ownerAddress) {
    const storageLocationBytes32 = computeStorageLocation("openzeppelin.storage.Ownable");
    (0, error_js_1.assertFhevm)(storageLocationBytes32 === "0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300", "Wrong 'openzeppelin.storage.Ownable' storage location");
    const paddedSlotValue = ethers_1.ethers.zeroPadValue(ownerAddress, 32);
    await setStorageAt(provider, "hardhat_setStorageAt", contractAddress, BigInt(storageLocationBytes32) + BigInt(0), paddedSlotValue);
}
//# sourceMappingURL=storage.js.map