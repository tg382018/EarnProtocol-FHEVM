"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FhevmMockProvider_minimalProvider, _FhevmMockProvider_readonlyEthersProvider, _FhevmMockProvider_info, _FhevmMockProvider_savedBlockGasLimit, _FhevmMockProvider_debugFunc;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FhevmMockProvider = exports.FhevmMockProviderType = void 0;
const ethers_1 = require("ethers");
const constants_js_1 = require("../constants.js");
const error_js_1 = require("../utils/error.js");
const string_js_1 = require("../utils/string.js");
const anvil_js_1 = require("./anvil.js");
const hardhat_js_1 = require("./hardhat.js");
const provider_js_1 = require("./provider.js");
var FhevmMockProviderType;
(function (FhevmMockProviderType) {
    FhevmMockProviderType[FhevmMockProviderType["Unknown"] = 0] = "Unknown";
    FhevmMockProviderType[FhevmMockProviderType["Hardhat"] = 1] = "Hardhat";
    FhevmMockProviderType[FhevmMockProviderType["HardhatNode"] = 2] = "HardhatNode";
    FhevmMockProviderType[FhevmMockProviderType["Anvil"] = 3] = "Anvil";
    FhevmMockProviderType[FhevmMockProviderType["SepoliaEthereum"] = 4] = "SepoliaEthereum";
})(FhevmMockProviderType || (exports.FhevmMockProviderType = FhevmMockProviderType = {}));
function fhevmMockProviderTypeToString(value) {
    switch (value) {
        case FhevmMockProviderType.Unknown:
            return "Unknown";
        case FhevmMockProviderType.Hardhat:
            return "Hardhat";
        case FhevmMockProviderType.HardhatNode:
            return "Hardhat Node";
        case FhevmMockProviderType.Anvil:
            return "Anvil";
        case FhevmMockProviderType.SepoliaEthereum:
            return "SepoliaEthereum";
    }
}
class FhevmMockProvider {
    constructor() {
        _FhevmMockProvider_minimalProvider.set(this, void 0);
        _FhevmMockProvider_readonlyEthersProvider.set(this, void 0);
        _FhevmMockProvider_info.set(this, void 0);
        _FhevmMockProvider_savedBlockGasLimit.set(this, void 0);
        _FhevmMockProvider_debugFunc.set(this, void 0);
    }
    static async fromReadonlyProvider(readonlyProvider, networkName, defaultProviderType, defaultChainId, url) {
        return FhevmMockProvider.create(readonlyProvider, readonlyProvider, networkName, defaultProviderType, defaultChainId, url);
    }
    static async create(minimalProvider, readonlyEthersProvider, networkName, defaultProviderType, defaultChainId, url) {
        const info = await _resolveProviderInfo(minimalProvider, networkName, defaultProviderType, defaultChainId, url);
        const p = new FhevmMockProvider();
        __classPrivateFieldSet(p, _FhevmMockProvider_minimalProvider, minimalProvider, "f");
        __classPrivateFieldSet(p, _FhevmMockProvider_info, info, "f");
        if (readonlyEthersProvider === undefined && info.url !== undefined) {
            readonlyEthersProvider = new ethers_1.JsonRpcProvider(info.url);
        }
        __classPrivateFieldSet(p, _FhevmMockProvider_readonlyEthersProvider, readonlyEthersProvider, "f");
        return p;
    }
    setDebugFunc(debugFunc) {
        (0, error_js_1.assertFhevm)(typeof debugFunc === "function");
        __classPrivateFieldSet(this, _FhevmMockProvider_debugFunc, debugFunc, "f");
    }
    get readonlyEthersProvider() {
        if (!__classPrivateFieldGet(this, _FhevmMockProvider_minimalProvider, "f")) {
            throw new error_js_1.FhevmError(`the FhevmMockProvider instance is not initialized.`);
        }
        if (!__classPrivateFieldGet(this, _FhevmMockProvider_readonlyEthersProvider, "f")) {
            throw new error_js_1.FhevmError(`the FhevmMockProvider instance is not able to provide a valid ethers.Provider instance.`);
        }
        return __classPrivateFieldGet(this, _FhevmMockProvider_readonlyEthersProvider, "f");
    }
    get minimalProvider() {
        if (!__classPrivateFieldGet(this, _FhevmMockProvider_minimalProvider, "f")) {
            throw new error_js_1.FhevmError(`the FhevmMockProvider instance is not initialized.`);
        }
        return __classPrivateFieldGet(this, _FhevmMockProvider_minimalProvider, "f");
    }
    get info() {
        if (!__classPrivateFieldGet(this, _FhevmMockProvider_info, "f")) {
            throw new error_js_1.FhevmError(`the FhevmMockProvider instance is not initialized.`);
        }
        return __classPrivateFieldGet(this, _FhevmMockProvider_info, "f");
    }
    get isMock() {
        if (!__classPrivateFieldGet(this, _FhevmMockProvider_info, "f")) {
            throw new error_js_1.FhevmError(`the FhevmMockProvider instance is not initialized.`);
        }
        return (__classPrivateFieldGet(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.Hardhat ||
            __classPrivateFieldGet(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.HardhatNode ||
            __classPrivateFieldGet(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.Anvil);
    }
    get isSepoliaEthereum() {
        if (!__classPrivateFieldGet(this, _FhevmMockProvider_info, "f")) {
            throw new error_js_1.FhevmError(`the FhevmMockProvider instance is not initialized.`);
        }
        return __classPrivateFieldGet(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.SepoliaEthereum;
    }
    get isHardhatWeb3Client() {
        if (!__classPrivateFieldGet(this, _FhevmMockProvider_info, "f")) {
            throw new error_js_1.FhevmError(`the FhevmMockProvider instance is not initialized.`);
        }
        return __classPrivateFieldGet(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.Hardhat || __classPrivateFieldGet(this, _FhevmMockProvider_info, "f").type === FhevmMockProviderType.HardhatNode;
    }
    get chainId() {
        return this.info.chainId;
    }
    async impersonateAddressAndSetBalance(address, balance) {
        if (!this.info.methods.impersonateAccount) {
            throw new error_js_1.FhevmError(`Network ${this.info.networkName} does not support account impersonation`);
        }
        if (!this.info.methods.setBalance) {
            throw new error_js_1.FhevmError(`Network ${this.info.networkName} does not support account setBalance`);
        }
        if (this.info.type === FhevmMockProviderType.Anvil) {
            if (!this.info.url) {
                throw new error_js_1.FhevmError(`Unable to impersonate account. Missing Anvil url.`);
            }
        }
        await this.send(this.info.methods.impersonateAccount, [address]);
        await this.send(this.info.methods.setBalance, [address, ethers_1.ethers.toBeHex(balance)]);
        if (this.info.type === FhevmMockProviderType.Anvil) {
            const jsonRpcProvider = new ethers_1.ethers.JsonRpcProvider(this.info.url);
            jsonRpcProvider.pollingInterval = 100;
            return await jsonRpcProvider.getSigner(address);
        }
        else if (this.isHardhatWeb3Client) {
            return undefined;
        }
        else {
            throw new error_js_1.FhevmError(`Network ${this.info.networkName} does not support account impersonation`);
        }
    }
    async setCodeAt(address, byteCode) {
        const methodName = this.info.methods.setCode;
        if (!methodName) {
            throw new error_js_1.FhevmError(`Network ${this.info.networkName} does not support 'setCode' method.`);
        }
        if (typeof byteCode !== "string") {
            throw new error_js_1.FhevmError(`Invalid contract bytecode.`);
        }
        await this.send(methodName, [address, byteCode]);
    }
    send(method, params) {
        return (0, provider_js_1.minimalProviderSend)(this.minimalProvider, method, params ?? []);
    }
    async getCodeAt(address) {
        const byteCode = await this.send("eth_getCode", [address, "latest"]);
        if (typeof byteCode !== "string") {
            throw new error_js_1.FhevmError(`Unexpected 'eth_getCode' RPC response type.`);
        }
        return byteCode;
    }
    async getBlockNumber() {
        const blockNumber = await this.send("eth_blockNumber");
        return Number(blockNumber);
    }
    async unsetTemporaryMinimumBlockGasLimit() {
        if (!__classPrivateFieldGet(this, _FhevmMockProvider_savedBlockGasLimit, "f")) {
            return;
        }
        try {
            await this.setBlockGasLimit(__classPrivateFieldGet(this, _FhevmMockProvider_savedBlockGasLimit, "f"));
        }
        finally {
            __classPrivateFieldSet(this, _FhevmMockProvider_savedBlockGasLimit, undefined, "f");
        }
    }
    async setTemporaryMinimumBlockGasLimit(minBlockGasLimit) {
        if (__classPrivateFieldGet(this, _FhevmMockProvider_savedBlockGasLimit, "f")) {
            throw new error_js_1.FhevmError(`The minimum block gas limit has already been set.`);
        }
        const currentBlockGasLimit = await this.getBlockGasLimit();
        if (!currentBlockGasLimit) {
            this._debug(`Unable to setup minimum block gas limit.`);
            return undefined;
        }
        if (minBlockGasLimit <= currentBlockGasLimit) {
            return undefined;
        }
        this._debug(`Adjust block gas limit to: ${minBlockGasLimit}. Current block gas limit is too low: ${currentBlockGasLimit}`);
        await this.setBlockGasLimit(minBlockGasLimit);
        __classPrivateFieldSet(this, _FhevmMockProvider_savedBlockGasLimit, currentBlockGasLimit, "f");
    }
    async setBlockGasLimit(blockGasLimit) {
        const blockGasLimitHex = "0x" + blockGasLimit.toString(16);
        await this.send("evm_setBlockGasLimit", [blockGasLimitHex]);
        this._debug(`Call evm_setBlockGasLimit ${blockGasLimit}`);
    }
    async getBlockGasLimit() {
        const res = await this.send("eth_getBlockByNumber", ["latest", false]);
        if (!res) {
            return undefined;
        }
        if (!("gasLimit" in res)) {
            return undefined;
        }
        try {
            return BigInt(res.gasLimit);
        }
        catch {
            return undefined;
        }
    }
    _debug(message) {
        if (__classPrivateFieldGet(this, _FhevmMockProvider_debugFunc, "f")) {
            __classPrivateFieldGet(this, _FhevmMockProvider_debugFunc, "f").call(this, message);
        }
    }
}
exports.FhevmMockProvider = FhevmMockProvider;
_FhevmMockProvider_minimalProvider = new WeakMap(), _FhevmMockProvider_readonlyEthersProvider = new WeakMap(), _FhevmMockProvider_info = new WeakMap(), _FhevmMockProvider_savedBlockGasLimit = new WeakMap(), _FhevmMockProvider_debugFunc = new WeakMap();
async function _resolveProviderInfo(minimalProvider, networkName, defaultProviderType, defaultChainId, url) {
    (0, string_js_1.assertIsString)(networkName, "networkName");
    if (networkName !== "hardhat" &&
        networkName !== "localhost" &&
        defaultChainId === constants_js_1.default.SEPOLIA_ETHEREUM_TESTNET_CHAINID) {
        (0, error_js_1.assertFhevm)(url !== undefined, "Missing sepolia url");
        return {
            type: FhevmMockProviderType.SepoliaEthereum,
            chainId: constants_js_1.default.SEPOLIA_ETHEREUM_TESTNET_CHAINID,
            methods: {},
            url,
            networkName,
            web3ClientVersion: "",
        };
    }
    const p = await _resolveProvider(minimalProvider, defaultProviderType, defaultChainId, url);
    switch (p.type) {
        case FhevmMockProviderType.Unknown: {
            return {
                type: p.type,
                chainId: p.chainId,
                methods: {},
                url,
                networkName,
                web3ClientVersion: p.web3ClientVersion,
            };
        }
        case FhevmMockProviderType.Hardhat:
        case FhevmMockProviderType.HardhatNode: {
            return {
                type: p.type,
                chainId: p.chainId,
                methods: {
                    setBalance: "hardhat_setBalance",
                    setCode: "hardhat_setCode",
                    impersonateAccount: "hardhat_impersonateAccount",
                },
                url,
                networkName,
                web3ClientVersion: p.web3ClientVersion,
            };
        }
        case FhevmMockProviderType.Anvil: {
            return {
                type: p.type,
                chainId: p.chainId,
                methods: {
                    setBalance: "anvil_setBalance",
                    setCode: "anvil_setCode",
                    impersonateAccount: "anvil_impersonateAccount",
                },
                url,
                networkName,
                web3ClientVersion: p.web3ClientVersion,
            };
        }
        default: {
            throw new error_js_1.FhevmError(`Unsuppored FhevmMockProviderType enum value '${p.type}'`);
        }
    }
}
async function _resolveProvider(minimalProvider, defaultProviderType, defaultChainId, url) {
    if (!url) {
        if (defaultProviderType !== FhevmMockProviderType.Hardhat) {
            throw new error_js_1.FhevmError(`Missing provider url`);
        }
        else {
            if (defaultChainId !== 31337) {
                throw new error_js_1.FhevmError(`Unexpected default chainId. Expecting '31337', got '${defaultChainId}' instead.`);
            }
        }
    }
    else {
        if (!URL.canParse(url)) {
            throw new error_js_1.FhevmError(`Invalid provider url '${url}'`);
        }
    }
    const clientRes = await (0, provider_js_1.connectedWeb3Client)(minimalProvider);
    const anvilRes = await (0, anvil_js_1.isAnvilProvider)(minimalProvider);
    if (!anvilRes.couldNotConnect) {
        if (anvilRes.isAnvil) {
            if (defaultProviderType !== undefined && defaultProviderType !== FhevmMockProviderType.Anvil) {
                throw new error_js_1.FhevmError(`Provider type mismatch. Expecting ${fhevmMockProviderTypeToString(defaultProviderType)}, got ${fhevmMockProviderTypeToString(FhevmMockProviderType.Anvil)} instead`);
            }
            if (defaultChainId !== undefined && defaultChainId !== anvilRes.chainId) {
                throw new error_js_1.FhevmError(`Anvil chainId mismatch. Expecting chainId=${defaultChainId}, got ${anvilRes.chainId} instead`);
            }
            if (!clientRes.client) {
                throw new error_js_1.FhevmError(`Unable to retrieve Anvil web3 client version.`);
            }
            return {
                type: FhevmMockProviderType.Anvil,
                chainId: anvilRes.chainId,
                web3ClientVersion: clientRes.client,
            };
        }
    }
    const hhRes = await (0, hardhat_js_1.isHardhatProvider)(minimalProvider);
    if (!hhRes.couldNotConnect) {
        if (hhRes.isHardhat) {
            const providerType = url !== undefined ? FhevmMockProviderType.HardhatNode : FhevmMockProviderType.Hardhat;
            if (defaultProviderType !== undefined && defaultProviderType !== providerType) {
                throw new error_js_1.FhevmError(`Provider type mismatch. Expecting ${fhevmMockProviderTypeToString(defaultProviderType)}, got ${fhevmMockProviderTypeToString(providerType)} instead`);
            }
            if (defaultChainId !== undefined && defaultChainId !== hhRes.chainId) {
                throw new error_js_1.FhevmError(`Hardhat chainId mismatch. Expecting chainId=${defaultChainId}, got ${hhRes.chainId} instead`);
            }
            if (!clientRes.client) {
                throw new error_js_1.FhevmError(`Unable to retrieve Hardhat web3 client version.`);
            }
            return {
                type: providerType,
                chainId: hhRes.chainId,
                web3ClientVersion: clientRes.client,
            };
        }
    }
    if (!clientRes.couldNotConnect) {
        const chainId = await (0, provider_js_1.connectedChainId)(minimalProvider);
        if (chainId === undefined) {
            throw new error_js_1.FhevmError(`Unable to query provider chaindId`);
        }
        if (defaultProviderType !== undefined && defaultProviderType !== FhevmMockProviderType.Unknown) {
            throw new error_js_1.FhevmError(`Provider type mismatch. Expecting ${fhevmMockProviderTypeToString(defaultProviderType)}, got ${fhevmMockProviderTypeToString(FhevmMockProviderType.Unknown)} instead`);
        }
        if (defaultChainId !== undefined && defaultChainId !== chainId) {
            throw new error_js_1.FhevmError(`Provider chainId mismatch. Expecting chainId=${defaultChainId}, got ${chainId} instead`);
        }
        if (!clientRes.client) {
            throw new error_js_1.FhevmError(`Unable to retrieve provider web3 client version.`);
        }
        return { type: FhevmMockProviderType.Unknown, chainId, web3ClientVersion: clientRes.client };
    }
    if (defaultProviderType === undefined) {
        throw new error_js_1.FhevmError(`Resolve provider failed. Missing default provider type.`);
    }
    if (defaultChainId === undefined) {
        throw new error_js_1.FhevmError(`Resolve provider failed. Missing default provider chainId.`);
    }
    return { type: defaultProviderType, chainId: defaultChainId, web3ClientVersion: undefined };
}
//# sourceMappingURL=FhevmMockProvider.js.map