"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_UINT512 = exports.MAX_UINT256 = exports.MAX_UINT160 = exports.MAX_UINT128 = exports.MAX_UINT64 = exports.MAX_UINT32 = exports.MAX_UINT16 = exports.MAX_UINT8 = void 0;
exports.toUIntNumber = toUIntNumber;
exports.isInt = isInt;
exports.isUInt = isUInt;
exports.isEvenUInt = isEvenUInt;
exports.boolToBigInt = boolToBigInt;
exports.bitwiseNotUIntBits = bitwiseNotUIntBits;
exports.getMaxBigInt = getMaxBigInt;
exports.log2BigInt = log2BigInt;
exports.getRandomBigInt = getRandomBigInt;
exports.assertIsUintNumber = assertIsUintNumber;
exports.assertIsBigUint8 = assertIsBigUint8;
exports.assertIsBigUint16 = assertIsBigUint16;
exports.assertIsBigUint32 = assertIsBigUint32;
exports.assertIsBigUint64 = assertIsBigUint64;
exports.assertIsBigUint128 = assertIsBigUint128;
exports.assertIsBigUint160 = assertIsBigUint160;
exports.assertIsBigUint256 = assertIsBigUint256;
exports.assertIsBigUint512 = assertIsBigUint512;
exports.assertIsBigUint1024 = assertIsBigUint1024;
exports.assertIsBigUint2048 = assertIsBigUint2048;
exports.assertIsBoolean = assertIsBoolean;
exports.assertIsNumber = assertIsNumber;
const ethers_1 = require("ethers");
const error_js_1 = require("./error.js");
exports.MAX_UINT8 = 0xffn;
exports.MAX_UINT16 = 0xffffn;
exports.MAX_UINT32 = 0xffffffffn;
exports.MAX_UINT64 = 0xffffffffffffffffn;
exports.MAX_UINT128 = 0xffffffffffffffffffffffffffffffffn;
exports.MAX_UINT160 = 0xffffffffffffffffffffffffffffffffffffffffn;
exports.MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;
exports.MAX_UINT512 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;
function toUIntNumber(value, name) {
    try {
        const bn = ethers_1.ethers.getUint(value, name);
        return ethers_1.ethers.getNumber(bn);
    }
    catch {
        throw new error_js_1.FhevmError(`${name} is not a positive integer`);
    }
}
function isInt(value) {
    if (typeof value === "bigint") {
        return true;
    }
    if (typeof value === "number") {
        return Number.isInteger(value);
    }
    return false;
}
function isUInt(value) {
    if (!isInt(value)) {
        return false;
    }
    return value >= 0;
}
function isEvenUInt(value) {
    if (!isUInt(value)) {
        return false;
    }
    return typeof value === "bigint" ? value % 2n === 0n : value % 2 === 0;
}
function boolToBigInt(value) {
    if (value === null || value === undefined) {
        throw new error_js_1.FhevmError("Missing value");
    }
    let zeroOrOne = 0n;
    if (typeof value === "bigint") {
        if (value !== 1n && value !== 0n) {
            throw new error_js_1.FhevmError("The value must be 1 or 0.");
        }
        zeroOrOne = value;
    }
    else if (typeof value === "number") {
        if (value !== 1 && value !== 0) {
            throw new error_js_1.FhevmError("The value must be 1 or 0.");
        }
        zeroOrOne = value === 0 ? 0n : 1n;
    }
    else if (typeof value === "boolean") {
        zeroOrOne = value === true ? 1n : 0n;
    }
    else {
        throw new error_js_1.FhevmError("The value must be a boolean, a number or a bigint.");
    }
    return zeroOrOne;
}
function bitwiseNotUIntBits(value, numBits) {
    if (typeof value !== "bigint") {
        throw new error_js_1.FhevmError("The input value must be a BigInt.");
    }
    if (!isUInt(numBits)) {
        throw new error_js_1.FhevmError("The numBits parameter must be a positive integer.");
    }
    const BIT_MASK = (BigInt(1) << BigInt(numBits)) - BigInt(1);
    return ~value & BIT_MASK;
}
function getMaxBigInt(bitLength) {
    if (!isUInt(bitLength)) {
        throw new error_js_1.FhevmError(`Invalid bitLength argument (${bitLength}), expecting a positive integer value.`);
    }
    return (1n << BigInt(bitLength)) - 1n;
}
function log2BigInt(x) {
    const n = x.toString(2).length - 1;
    return x <= 0n ? 0n : BigInt(n);
}
function getRandomBigInt(numBits) {
    if (numBits <= 0) {
        throw new TypeError("Number of bits must be greater than 0");
    }
    const numBytes = Math.ceil(numBits / 8);
    const randomBytes = ethers_1.ethers.randomBytes(numBytes);
    let randomBigInt = BigInt(0);
    for (let i = 0; i < numBytes; i++) {
        randomBigInt = (randomBigInt << BigInt(8)) | BigInt(randomBytes[i]);
    }
    const mask = (BigInt(1) << BigInt(numBits)) - BigInt(1);
    randomBigInt = randomBigInt & mask;
    return randomBigInt;
}
function assertIsUintNumber(value, valueName) {
    (0, error_js_1.assertFhevm)(typeof value === "number", `${valueName ?? "value"} is not of type number, got ${typeof value} instead`);
    (0, error_js_1.assertFhevm)(isUInt(value), `${valueName ?? "value"} is not an uint, got ${typeof value} instead`);
}
function assertIsBigUint8(value, valueName) {
    _assertIsBigUint(value, 8, exports.MAX_UINT8, valueName);
}
function assertIsBigUint16(value, valueName) {
    _assertIsBigUint(value, 16, exports.MAX_UINT16, valueName);
}
function assertIsBigUint32(value, valueName) {
    _assertIsBigUint(value, 32, exports.MAX_UINT32, valueName);
}
function assertIsBigUint64(value, valueName) {
    _assertIsBigUint(value, 64, exports.MAX_UINT64, valueName);
}
function assertIsBigUint128(value, valueName) {
    _assertIsBigUint(value, 128, exports.MAX_UINT128, valueName);
}
function assertIsBigUint160(value, valueName) {
    _assertIsBigUint(value, 128, exports.MAX_UINT160, valueName);
}
function assertIsBigUint256(value, valueName) {
    _assertIsBigUint(value, 256, exports.MAX_UINT256, valueName);
}
function assertIsBigUint512(value, valueName) {
    _assertIsBigUint(value, 512, exports.MAX_UINT512, valueName);
}
function assertIsBigUint1024(value, valueName) {
    _assertIsBigUint(value, 1024, getMaxBigInt(1024), valueName);
}
function assertIsBigUint2048(value, valueName) {
    _assertIsBigUint(value, 2048, getMaxBigInt(2048), valueName);
}
function _assertIsBigUint(value, bitLen, max, valueName) {
    (0, error_js_1.assertFhevm)(typeof value === "bigint", `${valueName ?? "value"} is not of type bigint, got ${typeof value} instead`);
    (0, error_js_1.assertFhevm)(value >= 0 && value <= max, `${valueName ?? "value"} is larger than uint${bitLen} maximum value, got ${value} > ${max}`);
}
function assertIsBoolean(value, valueName) {
    (0, error_js_1.assertFhevm)(typeof value === "boolean", `${valueName ?? "value"} is not of type boolean, got ${typeof value} instead`);
}
function assertIsNumber(value, valueName) {
    (0, error_js_1.assertFhevm)(typeof value === "number", `${valueName ?? "value"} is not of type number, got ${typeof value} instead`);
}
//# sourceMappingURL=math.js.map