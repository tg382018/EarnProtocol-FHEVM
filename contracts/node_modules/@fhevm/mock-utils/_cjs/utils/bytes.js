"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertIsUint8Array = assertIsUint8Array;
exports.assertIsBytesLike = assertIsBytesLike;
exports.assertIsBytes32String = assertIsBytes32String;
exports.assertIsBytesString = assertIsBytesString;
exports.assertIsBytes1 = assertIsBytes1;
exports.assertIsBytes8 = assertIsBytes8;
exports.assertIsBytes20 = assertIsBytes20;
exports.assertIsBytes32 = assertIsBytes32;
exports.assertIsBytes = assertIsBytes;
exports.bytesToBigInt = bytesToBigInt;
exports.uintToBytes = uintToBytes;
exports.concatBytes = concatBytes;
const ethers_1 = require("ethers");
const error_js_1 = require("./error.js");
const string_js_1 = require("./string.js");
function assertIsUint8Array(value, valueName) {
    (0, error_js_1.assertFhevm)(value instanceof Uint8Array, `${valueName ?? "value"} is not of type Uint8Array`);
}
function assertIsBytesLike(value, valueName) {
    (0, error_js_1.assertFhevm)(ethers_1.ethers.isBytesLike(value), `${valueName ?? "value"} is not bytes-like (expected a hex string or Uint8Array)`);
}
function assertIsBytes32String(value, valueName) {
    assertIsBytesString(value, 32, valueName);
}
function assertIsBytesString(value, width, valueName) {
    (0, string_js_1.assertIsString)(value, valueName);
    if (width === undefined) {
        (0, error_js_1.assertFhevm)(ethers_1.ethers.isBytesLike(value), `${valueName ?? "value"} : ${value} is not a valid bytes string`);
    }
    else {
        (0, error_js_1.assertFhevm)(value === ethers_1.ethers.toBeHex(value, width), `${valueName ?? "value"} : ${value} is not a valid bytes${width} string`);
    }
}
function assertIsBytes1(value, valueName) {
    assertIsBytes(value, 1, valueName);
}
function assertIsBytes8(value, valueName) {
    assertIsBytes(value, 8, valueName);
}
function assertIsBytes20(value, valueName) {
    assertIsBytes(value, 20, valueName);
}
function assertIsBytes32(value, valueName) {
    assertIsBytes(value, 32, valueName);
}
function assertIsBytes(value, width, valueName) {
    assertIsUint8Array(value, valueName);
    if (width === undefined) {
        (0, error_js_1.assertFhevm)(ethers_1.ethers.isBytesLike(value), `${valueName ?? "value"} : ${value} is not a valid bytes string`);
    }
    else {
        (0, error_js_1.assertFhevm)(value.length === width, `${valueName ?? "value"} : ${value} is not a valid bytes${width} Uint8Array. Expecting length ${width}, got ${value.length} instead`);
    }
}
function bytesToBigInt(byteArray) {
    if (!byteArray || byteArray.length === 0) {
        return BigInt(0);
    }
    return ethers_1.ethers.toBigInt(byteArray);
}
function uintToBytes(value, width) {
    return ethers_1.ethers.getBytes(ethers_1.ethers.toBeHex(value, width));
}
function concatBytes(...arrays) {
    const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
//# sourceMappingURL=bytes.js.map