"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.userDecryptHandleBytes32 = userDecryptHandleBytes32;
const ethers_1 = require("ethers");
const constants_js_1 = require("../constants.js");
const address_js_1 = require("../utils/address.js");
const error_js_1 = require("../utils/error.js");
const keypair_js_1 = require("../utils/keypair.js");
const math_js_1 = require("../utils/math.js");
const time_js_1 = require("../utils/time.js");
const FhevmHandle_js_1 = require("./FhevmHandle.js");
async function userDecryptHandleBytes32(instance, handleContractPairs, user, options) {
    _assertIsContractAddressesArray(handleContractPairs);
    const userDecryptArgs = await _resolveUserDecryptOptions(instance, options);
    const chainId = _getFhevmInstanceChainId(instance);
    _verifyFhevmHandleContractPairs(handleContractPairs, chainId);
    const { signature, contractAddresses } = await _computeUserSignatureAndContractAddresses(instance, handleContractPairs, user, userDecryptArgs);
    const userAddress = await user.getAddress();
    const handles = handleContractPairs.map((p) => {
        return { handle: p.handleBytes32, contractAddress: p.contractAddress };
    });
    const decryptedHandles = await instance.userDecrypt(handles, userDecryptArgs.keypair.privateKey, userDecryptArgs.keypair.publicKey, signature, contractAddresses, userAddress, userDecryptArgs.startTimestamp, userDecryptArgs.durationDays);
    return decryptedHandles;
}
async function _resolveUserDecryptOptions(instance, options) {
    let keypair;
    if (options?.keypair !== undefined) {
        keypair = { ...options.keypair };
        (0, keypair_js_1.verifyKeypair)(keypair);
    }
    else {
        keypair = instance.generateKeypair();
    }
    const startTimestamp = options?.validity?.startTimestamp || (0, time_js_1.timestampNow)();
    const durationDays = options?.validity?.durationDays || constants_js_1.default.DEFAULT_DURATION_DAYS;
    const startTimestampNumber = (0, math_js_1.toUIntNumber)(startTimestamp, "startTimeStamp");
    const durationDaysNumber = (0, math_js_1.toUIntNumber)(durationDays, "durationDays");
    return {
        keypair,
        startTimestamp: startTimestampNumber,
        durationDays: durationDaysNumber,
    };
}
async function _computeUserSignatureAndContractAddresses(instance, contractAddresses, user, userDecryptArgs) {
    if (contractAddresses.length === 0) {
        throw new error_js_1.FhevmError("Empty list of contract addresses.");
    }
    const contractAddressesSortUnique = _buildDeterministicContractAddressesList(contractAddresses);
    if (contractAddressesSortUnique.length === 0) {
        throw new error_js_1.FhevmError("Empty list of valid contract addresses.");
    }
    const eip712 = instance.createEIP712(userDecryptArgs.keypair.publicKey, contractAddressesSortUnique, userDecryptArgs.startTimestamp, userDecryptArgs.durationDays);
    const signature = await user.signTypedData(eip712.domain, { UserDecryptRequestVerification: eip712.types.UserDecryptRequestVerification }, eip712.message);
    return {
        signature,
        contractAddresses: contractAddressesSortUnique,
    };
}
function _getFhevmInstanceChainId(instance) {
    const dummyEIP712 = instance.createEIP712("", [ethers_1.ethers.ZeroAddress], 0, 0);
    return dummyEIP712.message.contractsChainId;
}
function _buildDeterministicContractAddressesList(contractAddresses) {
    const set = new Set();
    for (let i = 0; i < contractAddresses.length; ++i) {
        const ca = contractAddresses[i];
        let contractAddress;
        if (typeof ca === "string") {
            contractAddress = ca;
        }
        else {
            contractAddress = ca.contractAddress;
        }
        const add = ethers_1.ethers.getAddress(contractAddress);
        if (!set.has(add)) {
            set.add(add);
        }
    }
    return [...set].sort((a, b) => {
        const addrA = a.toLowerCase();
        const addrB = b.toLowerCase();
        if (addrA < addrB) {
            return -1;
        }
        if (addrA > addrB) {
            return 1;
        }
        return 0;
    });
}
function _assertIsContractAddressesArray(contractAddresses) {
    if (contractAddresses.length === 0) {
        throw new error_js_1.FhevmError("Empty list of contract addresses.");
    }
    for (let i = 0; i < contractAddresses.length; ++i) {
        const ca = contractAddresses[i];
        let contractAddress;
        if (typeof ca === "string") {
            contractAddress = ca;
        }
        else {
            contractAddress = ca.contractAddress;
        }
        (0, address_js_1.assertIsAddress)(contractAddress, "contractAddress");
    }
}
function _verifyFhevmHandleContractPairs(handleContractPairs, chainId) {
    if (handleContractPairs.length === 0) {
        throw new error_js_1.FhevmError("Empty list of handle/contract pairs.");
    }
    for (let i = 0; i < handleContractPairs.length; ++i) {
        const pair = handleContractPairs[i];
        FhevmHandle_js_1.FhevmHandle.verify(pair.handleBytes32, {
            ...(pair.fhevmType !== undefined && { fhevmType: pair.fhevmType }),
            ...(chainId !== undefined && { chainId: chainId }),
        });
        (0, address_js_1.assertIsAddress)(pair.contractAddress, "contractAddress");
    }
}
//# sourceMappingURL=userDecrypt.js.map