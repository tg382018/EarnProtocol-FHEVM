"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InputVerifier_inputVerifierReadonlyContract, _InputVerifier_inputVerifierContractAddress, _InputVerifier_signersAddresses, _InputVerifier_threshold, _InputVerifier_eip712Domain;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputVerifier = void 0;
exports.computeInputProofHex = computeInputProofHex;
const ethers_1 = require("ethers");
const constants_js_1 = require("../../constants.js");
const eip712_js_1 = require("../../ethers/eip712.js");
const address_js_1 = require("../../utils/address.js");
const bytes_js_1 = require("../../utils/bytes.js");
const error_js_1 = require("../../utils/error.js");
const hex_js_1 = require("../../utils/hex.js");
const math_js_1 = require("../../utils/math.js");
const string_js_1 = require("../../utils/string.js");
const FhevmContractWrapper_js_1 = require("./FhevmContractWrapper.js");
const InputVerifier_itf_js_1 = require("./interfaces/InputVerifier.itf.js");
class InputVerifier extends FhevmContractWrapper_js_1.FhevmCoprocessorContractWrapper {
    constructor() {
        super("InputVerifier");
        _InputVerifier_inputVerifierReadonlyContract.set(this, void 0);
        _InputVerifier_inputVerifierContractAddress.set(this, void 0);
        _InputVerifier_signersAddresses.set(this, void 0);
        _InputVerifier_threshold.set(this, void 0);
        _InputVerifier_eip712Domain.set(this, void 0);
    }
    static async create(runner, inputVerifierContractAddress, abi, properties) {
        (0, address_js_1.assertIsAddress)(inputVerifierContractAddress, "inputVerifierContractAddress");
        const inputVerifier = new InputVerifier();
        __classPrivateFieldSet(inputVerifier, _InputVerifier_inputVerifierContractAddress, inputVerifierContractAddress, "f");
        __classPrivateFieldSet(inputVerifier, _InputVerifier_inputVerifierReadonlyContract, new ethers_1.ethers.Contract(inputVerifierContractAddress, abi ?? InputVerifier_itf_js_1.InputVerifierPartialInterface, runner), "f");
        __classPrivateFieldSet(inputVerifier, _InputVerifier_eip712Domain, properties?.eip712Domain, "f");
        __classPrivateFieldSet(inputVerifier, _InputVerifier_signersAddresses, properties?.signersAddresses, "f");
        __classPrivateFieldSet(inputVerifier, _InputVerifier_threshold, properties?.threshold, "f");
        await inputVerifier._initialize();
        return inputVerifier;
    }
    get readonlyContract() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f") !== undefined, `InputVerifier wrapper is not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f");
    }
    get interface() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f") !== undefined, `InputVerifier wrapper is not yet initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f").interface;
    }
    async _initialize() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f") !== undefined, `InputVerifier wrapper is not initialized`);
        if (!__classPrivateFieldGet(this, _InputVerifier_signersAddresses, "f")) {
            const signers = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f").getCoprocessorSigners();
            __classPrivateFieldSet(this, _InputVerifier_signersAddresses, signers, "f");
        }
        (0, address_js_1.assertIsAddressArray)(__classPrivateFieldGet(this, _InputVerifier_signersAddresses, "f"));
        if (__classPrivateFieldGet(this, _InputVerifier_threshold, "f") === undefined) {
            const threshold = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f").getThreshold();
            (0, math_js_1.assertIsBigUint8)(threshold);
            __classPrivateFieldSet(this, _InputVerifier_threshold, Number(threshold), "f");
        }
        if (__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") === undefined) {
            const eip712Domain = await __classPrivateFieldGet(this, _InputVerifier_inputVerifierReadonlyContract, "f").eip712Domain();
            (0, error_js_1.assertFhevm)(eip712Domain.length === 7);
            (0, string_js_1.assertIsString)(eip712Domain[0], "eip712Domain[0]");
            (0, string_js_1.assertIsString)(eip712Domain[1], "eip712Domain[1]");
            (0, string_js_1.assertIsString)(eip712Domain[2], "eip712Domain[2]");
            (0, math_js_1.assertIsBigUint256)(eip712Domain[3], "eip712Domain[3]");
            (0, address_js_1.assertIsAddress)(eip712Domain[4], "eip712Domain[4]");
            (0, bytes_js_1.assertIsBytes32String)(eip712Domain[5], "eip712Domain[5]");
            (0, error_js_1.assertFhevm)(Array.isArray(eip712Domain[6]) && eip712Domain[6].length === 0, "eip712Domain[6]");
            __classPrivateFieldSet(this, _InputVerifier_eip712Domain, {
                fields: Number(BigInt(eip712Domain[0])),
                name: eip712Domain[1],
                version: eip712Domain[2],
                chainId: eip712Domain[3],
                verifyingContract: eip712Domain[4],
                salt: eip712Domain[5],
            }, "f");
        }
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").fields === Number(0x0f));
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").salt === ethers_1.ethers.ZeroHash);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").name === constants_js_1.default.INPUT_VERIFICATION_EIP712.domain.name);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").version === constants_js_1.default.INPUT_VERIFICATION_EIP712.domain.version);
    }
    get address() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_inputVerifierContractAddress, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_inputVerifierContractAddress, "f");
    }
    get gatewayChainId() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").chainId;
    }
    get gatewayInputVerificationAddress() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f").verifyingContract;
    }
    get eip712Domain() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_eip712Domain, "f");
    }
    getCoprocessorSigners() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_signersAddresses, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_signersAddresses, "f");
    }
    getThreshold() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _InputVerifier_threshold, "f") !== undefined, `InputVerifier wrapper not initialized`);
        return __classPrivateFieldGet(this, _InputVerifier_threshold, "f");
    }
    async assertMatchCoprocessorSigners(signers) {
        const addresses = this.getCoprocessorSigners();
        (0, error_js_1.assertIsArray)(signers, "signers");
        (0, error_js_1.assertFhevm)(signers.length === addresses.length, "signers.length === addresses.length");
        for (let i = 0; i < addresses.length; ++i) {
            const s = await signers[i].getAddress();
            (0, error_js_1.assertFhevm)(addresses[i] === s, `addresses[${i}] === await signers[${i}].getAddress()`);
        }
    }
    verifySignatures(handlesBytes32List, userAddress, contractAddress, contractChainId, extraData, signatures) {
        (0, error_js_1.assertIsArray)(signatures);
        const domain = this.eip712Domain;
        const recoveredAddresses = signatures.map((signature) => {
            const sig = (0, string_js_1.ensure0x)(signature);
            const recoveredAddress = ethers_1.ethers.verifyTypedData({
                name: domain.name,
                version: domain.version,
                chainId: domain.chainId,
                verifyingContract: domain.verifyingContract,
            }, constants_js_1.default.INPUT_VERIFICATION_EIP712.types, {
                ctHandles: handlesBytes32List,
                userAddress,
                contractAddress,
                contractChainId,
                extraData,
            }, sig);
            return recoveredAddress;
        });
        if (!(0, eip712_js_1.isThresholdReached)(this.getCoprocessorSigners(), recoveredAddresses, this.getThreshold(), "coprocessor")) {
            throw new error_js_1.FhevmError("Coprocessor signers threshold is not reached");
        }
    }
    createCiphertextVerificationEIP712(handlesBytes32List, contractChainId, contractAddress, userAddress, extraData) {
        (0, address_js_1.assertIsAddress)(userAddress, "userAddress");
        (0, address_js_1.assertIsAddress)(contractAddress, "contractAddress");
        const domain = this.eip712Domain;
        const eip712 = {
            domain: {
                chainId: domain.chainId,
                name: domain.name,
                version: domain.version,
                verifyingContract: domain.verifyingContract,
            },
            types: constants_js_1.default.INPUT_VERIFICATION_EIP712.types,
            message: {
                ctHandles: handlesBytes32List.map((handle) => ethers_1.ethers.zeroPadValue(ethers_1.ethers.toBeHex(handle), 32)),
                userAddress: userAddress,
                contractAddress: contractAddress,
                contractChainId: contractChainId,
                extraData,
            },
        };
        return eip712;
    }
}
exports.InputVerifier = InputVerifier;
_InputVerifier_inputVerifierReadonlyContract = new WeakMap(), _InputVerifier_inputVerifierContractAddress = new WeakMap(), _InputVerifier_signersAddresses = new WeakMap(), _InputVerifier_threshold = new WeakMap(), _InputVerifier_eip712Domain = new WeakMap();
function computeInputProofHex(handlesBytes32Hex, coprocessorsSignaturesHex, extraData) {
    const numHandles = handlesBytes32Hex.length;
    const numCoprocessorSigners = coprocessorsSignaturesHex.length;
    const numHandlesHexByte1 = (0, hex_js_1.numberToHexNoPrefix)(numHandles);
    (0, error_js_1.assertFhevm)(numHandlesHexByte1.length === 2);
    const numCoprocessorSignersHexByte1 = (0, hex_js_1.numberToHexNoPrefix)(numCoprocessorSigners);
    (0, error_js_1.assertFhevm)(numCoprocessorSignersHexByte1.length === 2);
    let inputProofHex = "0x" + numHandlesHexByte1 + numCoprocessorSignersHexByte1;
    for (let i = 0; i < numHandles; ++i) {
        const handlesBytes32HexNoPrefix = (0, string_js_1.removePrefix)(handlesBytes32Hex[i], "0x");
        (0, error_js_1.assertFhevm)(handlesBytes32HexNoPrefix.length === 2 * 32);
        inputProofHex += handlesBytes32HexNoPrefix;
    }
    coprocessorsSignaturesHex.map((signatureHex) => {
        const signatureBytes65HexNoPrefix = (0, string_js_1.removePrefix)(signatureHex, "0x");
        if (signatureBytes65HexNoPrefix.length !== 2 * 65) {
            throw new error_js_1.FhevmError(`Invalid coprocessor signature: ${signatureBytes65HexNoPrefix}. Invalid length.`);
        }
        inputProofHex += signatureBytes65HexNoPrefix;
    });
    inputProofHex = ethers_1.ethers.concat([inputProofHex, extraData]);
    return inputProofHex;
}
//# sourceMappingURL=InputVerifier.js.map