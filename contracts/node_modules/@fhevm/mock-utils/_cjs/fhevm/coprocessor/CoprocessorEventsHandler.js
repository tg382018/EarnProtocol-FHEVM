"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CoprocessorEventsHandler_db, _CoprocessorEventsHandler_counterRand;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoprocessorEventsHandler = void 0;
const event_js_1 = require("../../ethers/event.js");
const error_js_1 = require("../../utils/error.js");
const math_js_1 = require("../../utils/math.js");
const FhevmHandle_js_1 = require("../FhevmHandle.js");
class CoprocessorEventsHandler {
    constructor(db) {
        _CoprocessorEventsHandler_db.set(this, void 0);
        _CoprocessorEventsHandler_counterRand.set(this, void 0);
        __classPrivateFieldSet(this, _CoprocessorEventsHandler_db, db, "f");
        __classPrivateFieldSet(this, _CoprocessorEventsHandler_counterRand, 0, "f");
    }
    get counterRand() {
        return __classPrivateFieldGet(this, _CoprocessorEventsHandler_counterRand, "f");
    }
    async handleEvent(coprocessorEvent) {
        var _a;
        (0, error_js_1.assertFhevm)(coprocessorEvent.blockNumber >= __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").fromBlockNumber, "coprocessorEvent.blockNumber < this.#db.fromBlockNumber");
        if (coprocessorEvent.eventName === "VerifyCiphertext") {
            await this.verifyCipherText(coprocessorEvent.args);
        }
        else {
            const res = await this.executeCoprocessorEvent(coprocessorEvent);
            if (res) {
                await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").insertHandleBytes32(res.resultBytes32, res.clearText, {
                    index: coprocessorEvent.index,
                    blockNumber: coprocessorEvent.blockNumber,
                    transactionHash: coprocessorEvent.transactionHash,
                }, res.replace !== undefined ? { replace: res.replace } : undefined);
                if (coprocessorEvent.eventName === "FheRandBounded" || coprocessorEvent.eventName === "FheRand") {
                    __classPrivateFieldSet(this, _CoprocessorEventsHandler_counterRand, (_a = __classPrivateFieldGet(this, _CoprocessorEventsHandler_counterRand, "f"), _a++, _a), "f");
                }
            }
        }
    }
    async executeCoprocessorEvent(event) {
        switch (event.eventName) {
            case "TrivialEncrypt": {
                const ptUint256 = event.args[1];
                const fheType = event.args[2];
                const resultBytes32 = event.args[3];
                (0, event_js_1.assertEventArgIsBigUint256)(ptUint256, "TrivialEncrypt", 1);
                (0, event_js_1.assertEventArgIsBigUint256)(fheType, "TrivialEncrypt", 2);
                (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, "TrivialEncrypt", 3);
                return {
                    resultBytes32,
                    clearText: ptUint256,
                };
            }
            case "TrivialEncryptBytes": {
                const ptBytes = event.args[1];
                const resultBytes32 = event.args[3];
                (0, event_js_1.assertEventArgIsBytesString)(ptBytes, "TrivialEncryptBytes", 1);
                (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, "TrivialEncrypt", 3);
                return {
                    resultBytes32,
                    clearText: ptBytes,
                };
            }
            case "FheAdd": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt + binaryOp.clearTextRhsBigInt;
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheSub": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt - binaryOp.clearTextRhsBigInt;
                if (clearText < 0n)
                    clearText = clearText + 2n ** binaryOp.clearTextBitLength;
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheMul": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt * binaryOp.clearTextRhsBigInt;
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheDiv": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                if (!binaryOp.scalar) {
                    throw new Error("Non-scalar div not implemented yet");
                }
                const clearText = binaryOp.clearTextLhsBigInt / binaryOp.clearTextRhsBigInt;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheRem": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                if (!binaryOp.scalar) {
                    throw new Error("Non-scalar rem not implemented yet");
                }
                const clearText = binaryOp.clearTextLhsBigInt % binaryOp.clearTextRhsBigInt;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheBitAnd": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt & binaryOp.clearTextRhsBigInt;
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheBitOr": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt | binaryOp.clearTextRhsBigInt;
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheBitXor": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt ^ binaryOp.clearTextRhsBigInt;
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheShl": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt << binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheShr": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                let clearText = binaryOp.clearTextLhsBigInt >> binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheRotl": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const shift = binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
                let clearText = (binaryOp.clearTextLhsBigInt << shift) |
                    (binaryOp.clearTextLhsBigInt >> (binaryOp.clearTextBitLength - shift));
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheRotr": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const shift = binaryOp.clearTextRhsBigInt % binaryOp.clearTextBitLength;
                let clearText = (binaryOp.clearTextLhsBigInt >> shift) |
                    (binaryOp.clearTextLhsBigInt << (binaryOp.clearTextBitLength - shift));
                clearText = clearText % 2n ** binaryOp.clearTextBitLength;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheEq": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheEqBytes": {
                const binaryOp = await this.parseBinaryBytesOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheNe": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt === binaryOp.clearTextRhsBigInt ? 0n : 1n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheNeBytes": {
                const binaryOp = await this.parseBinaryBytesOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt !== binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheGe": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt >= binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheGt": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt > binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheLe": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt <= binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheLt": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt < binaryOp.clearTextRhsBigInt ? 1n : 0n;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheMin": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt < binaryOp.clearTextRhsBigInt
                    ? binaryOp.clearTextLhsBigInt
                    : binaryOp.clearTextRhsBigInt;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheMax": {
                const binaryOp = await this.parseBinaryOpEvent(event);
                const clearText = binaryOp.clearTextLhsBigInt > binaryOp.clearTextRhsBigInt
                    ? binaryOp.clearTextLhsBigInt
                    : binaryOp.clearTextRhsBigInt;
                return {
                    resultBytes32: binaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheNot": {
                const unaryOp = await this.parseUnaryOpEvent(event);
                const clearText = (0, math_js_1.bitwiseNotUIntBits)(unaryOp.clearTextBigInt, unaryOp.clearTextBitLength);
                return {
                    resultBytes32: unaryOp.resultBytes32,
                    clearText,
                };
            }
            case "FheNeg": {
                const unaryOp = await this.parseUnaryOpEvent(event);
                let clearText = (0, math_js_1.bitwiseNotUIntBits)(unaryOp.clearTextBigInt, unaryOp.clearTextBitLength);
                clearText = (clearText + 1n) % 2n ** unaryOp.clearTextBitLength;
                return {
                    resultBytes32: unaryOp.resultBytes32,
                    clearText,
                };
            }
            case "Cast": {
                const ctBytes32 = event.args[1];
                const toTypeUint8 = event.args[2];
                const resultBytes32 = event.args[3];
                (0, event_js_1.assertEventArgIsBytes32String)(ctBytes32, event.eventName, 1);
                (0, event_js_1.assertEventArgIsBigUint8)(toTypeUint8, event.eventName, 2);
                (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, event.eventName, 3);
                const resultFhevmHandle = FhevmHandle_js_1.FhevmHandle.fromBytes32Hex(resultBytes32);
                const resultType = resultFhevmHandle.fheType;
                const clearTextBitLength = BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength);
                (0, error_js_1.assertFhevm)(BigInt(resultType) === toTypeUint8, `Cast type mismatch, (resultType:${resultType}) !== (toTypeUint8:${toTypeUint8})`);
                const ct = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ctBytes32)).clearTextHex);
                const clearText = ct % 2n ** clearTextBitLength;
                return {
                    resultBytes32,
                    clearText,
                };
            }
            case "FheIfThenElse": {
                const controlBytes32 = event.args[1];
                const ifTrueBytes32 = event.args[2];
                const ifFalseBytes32 = event.args[3];
                const resultBytes32 = event.args[4];
                (0, event_js_1.assertEventArgIsBytes32String)(controlBytes32, event.eventName, 1);
                (0, event_js_1.assertEventArgIsBytes32String)(ifTrueBytes32, event.eventName, 2);
                (0, event_js_1.assertEventArgIsBytes32String)(ifFalseBytes32, event.eventName, 3);
                (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, event.eventName, 4);
                const control = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(controlBytes32)).clearTextHex);
                const ifTrue = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ifTrueBytes32)).clearTextHex);
                const ifFalse = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ifFalseBytes32)).clearTextHex);
                (0, error_js_1.assertFhevm)(control === 0n || control === 1n, `Unexpected FheIfThenElse control value. Got ${control}, expecting 0 or 1`);
                const clearText = control === 1n ? ifTrue : ifFalse;
                return {
                    resultBytes32,
                    clearText,
                };
            }
            case "FheRand": {
                const randTypeUint8 = event.args[1];
                const seedBytes16 = event.args[2];
                const resultBytes32 = event.args[3];
                (0, event_js_1.assertEventArgIsBigUint8)(randTypeUint8, event.eventName, 1);
                (0, event_js_1.assertEventArgIsBytes16String)(seedBytes16, event.eventName, 2);
                (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, event.eventName, 3);
                const resultFhevmHandle = FhevmHandle_js_1.FhevmHandle.fromBytes32Hex(resultBytes32);
                const resultType = resultFhevmHandle.fheType;
                const clearTextBitLength = resultFhevmHandle.fhevmTypeInfo.clearTextBitLength;
                (0, error_js_1.assertFhevm)(BigInt(resultType) === randTypeUint8, `Rand type mismatch, (resultType:${resultType}) !== (randTypeUint8:${randTypeUint8})`);
                const clearText = (0, math_js_1.getRandomBigInt)(clearTextBitLength);
                return {
                    resultBytes32,
                    clearText,
                    replace: true,
                };
            }
            case "FheRandBounded": {
                const upperBoundUint256 = event.args[1];
                const randTypeUint8 = event.args[2];
                const seedBytes16 = event.args[3];
                const resultBytes32 = event.args[4];
                (0, event_js_1.assertEventArgIsBigUint256)(upperBoundUint256, event.eventName, 1);
                (0, event_js_1.assertEventArgIsBigUint8)(randTypeUint8, event.eventName, 2);
                (0, event_js_1.assertEventArgIsBytes16String)(seedBytes16, event.eventName, 3);
                (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, event.eventName, 4);
                const resultFhevmHandle = FhevmHandle_js_1.FhevmHandle.fromBytes32Hex(resultBytes32);
                const resultType = resultFhevmHandle.fheType;
                (0, error_js_1.assertFhevm)(BigInt(resultType) === randTypeUint8, `Rand type mismatch, (resultType:${resultType}) !== (randTypeUint8:${randTypeUint8})`);
                const clearText = (0, math_js_1.getRandomBigInt)(Number((0, math_js_1.log2BigInt)(upperBoundUint256)));
                return {
                    resultBytes32,
                    clearText,
                    replace: true,
                };
            }
        }
        throw new error_js_1.FhevmError(`Unknown fhevm coprocessor event: ${event.eventName}`);
    }
    async verifyCipherText(eventArgs) {
        const inputHandleBytes32 = eventArgs[1];
        const userAddress = eventArgs[2];
        const inputProofBytes = eventArgs[3];
        const fheType = eventArgs[4];
        const resultBytes32 = eventArgs[5];
        (0, event_js_1.assertEventArgIsBytes32String)(inputHandleBytes32, "VerifyCipherText", 1);
        (0, event_js_1.assertEventArgIsAddress)(userAddress, "VerifyCipherText", 2);
        (0, event_js_1.assertEventArgIsBytesString)(inputProofBytes, "VerifyCipherText", 3);
        (0, event_js_1.assertEventArgIsBigUint256)(fheType, "VerifyCipherText", 4);
        (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, "VerifyCipherText", 5);
        (0, error_js_1.assertFhevm)(inputHandleBytes32 === resultBytes32, `VerifyCipherText: inputHandleBytes32=${inputHandleBytes32} differs from resultBytes32=${resultBytes32}`);
        try {
            await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(inputHandleBytes32);
        }
        catch {
            throw new error_js_1.FhevmError(`User input was not found in DB inputHandle=${inputHandleBytes32}`);
        }
    }
    async parseUnaryOpEvent(event) {
        const ctBytes32 = event.args[1];
        const resultBytes32 = event.args[2];
        (0, event_js_1.assertEventArgIsBytes32String)(ctBytes32, event.eventName, 1);
        (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, event.eventName, 2);
        const resultFhevmHandle = FhevmHandle_js_1.FhevmHandle.fromBytes32Hex(resultBytes32);
        const clearTextBigInt = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(ctBytes32)).clearTextHex);
        return {
            resultBytes32,
            clearTextBigInt,
            clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength),
        };
    }
    async parseBinaryOpEvent(event) {
        const lhsBytes32 = event.args[1];
        const rhsBytes32 = event.args[2];
        const scalarBytes1 = event.args[3];
        const resultBytes32 = event.args[4];
        (0, event_js_1.assertEventArgIsBytes32String)(lhsBytes32, event.eventName, 1);
        (0, event_js_1.assertEventArgIsBytes32String)(rhsBytes32, event.eventName, 2);
        (0, event_js_1.assertEventArgIsBytes1String)(scalarBytes1, event.eventName, 3);
        (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, event.eventName, 4);
        const resultFhevmHandle = FhevmHandle_js_1.FhevmHandle.fromBytes32Hex(resultBytes32);
        const scalar = scalarBytes1 === "0x01";
        const clearTextLhsBigInt = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(lhsBytes32)).clearTextHex);
        const clearTextRhsBigInt = scalar
            ? BigInt(rhsBytes32)
            : BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(rhsBytes32)).clearTextHex);
        return {
            resultBytes32,
            clearTextLhsBigInt,
            clearTextRhsBigInt,
            scalar,
            clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength),
        };
    }
    async parseBinaryBytesOpEvent(event) {
        const lhsBytes32 = event.args[1];
        const rhsBytes = event.args[2];
        const scalarBytes1 = event.args[3];
        const resultBytes32 = event.args[4];
        (0, event_js_1.assertEventArgIsBytes32String)(lhsBytes32, event.eventName, 1);
        (0, event_js_1.assertEventArgIsBytesString)(rhsBytes, event.eventName, 2);
        (0, event_js_1.assertEventArgIsBytes1String)(scalarBytes1, event.eventName, 3);
        (0, event_js_1.assertEventArgIsBytes32String)(resultBytes32, event.eventName, 4);
        const resultFhevmHandle = FhevmHandle_js_1.FhevmHandle.fromBytes32Hex(resultBytes32);
        const scalar = scalarBytes1 === "0x01";
        const clearTextLhsBigInt = BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(lhsBytes32)).clearTextHex);
        const clearTextRhsBigInt = scalar
            ? BigInt(rhsBytes)
            : BigInt((await __classPrivateFieldGet(this, _CoprocessorEventsHandler_db, "f").queryHandleBytes32(rhsBytes)).clearTextHex);
        return {
            resultBytes32,
            clearTextLhsBigInt,
            clearTextRhsBigInt,
            scalar,
            clearTextBitLength: BigInt(resultFhevmHandle.fhevmTypeInfo.clearTextBitLength),
        };
    }
}
exports.CoprocessorEventsHandler = CoprocessorEventsHandler;
_CoprocessorEventsHandler_db = new WeakMap(), _CoprocessorEventsHandler_counterRand = new WeakMap();
//# sourceMappingURL=CoprocessorEventsHandler.js.map