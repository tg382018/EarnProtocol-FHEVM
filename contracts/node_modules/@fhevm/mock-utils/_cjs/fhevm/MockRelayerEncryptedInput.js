"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MockRelayerEncryptedInput_clearTextValues, _MockRelayerEncryptedInput_fhevmTypes, _MockRelayerEncryptedInput_fheTypes, _MockRelayerEncryptedInput_totalFheBits, _MockRelayerEncryptedInput_contractChainId, _MockRelayerEncryptedInput_contractAddress, _MockRelayerEncryptedInput_userAddress, _MockRelayerEncryptedInput_relayerProvider, _MockRelayerEncryptedInput_aclContractAddress, _MockRelayerEncryptedInput_inputVerifier;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRelayerEncryptedInput = void 0;
const ethers_1 = require("ethers");
const constants_js_1 = require("../constants.js");
const bytes_js_1 = require("../utils/bytes.js");
const error_js_1 = require("../utils/error.js");
const math_js_1 = require("../utils/math.js");
const FheType_js_1 = require("./FheType.js");
const FhevmHandle_js_1 = require("./FhevmHandle.js");
const FhevmType_js_1 = require("./FhevmType.js");
const InputVerifier_js_1 = require("./contracts/InputVerifier.js");
const relayer = require("./relayer/index.js");
class MockRelayerEncryptedInput {
    constructor(relayerProvider, contractChainId, contractAddress, userAddress, aclContractAddress, inputVerifier) {
        _MockRelayerEncryptedInput_clearTextValues.set(this, []);
        _MockRelayerEncryptedInput_fhevmTypes.set(this, []);
        _MockRelayerEncryptedInput_fheTypes.set(this, []);
        _MockRelayerEncryptedInput_totalFheBits.set(this, 0);
        _MockRelayerEncryptedInput_contractChainId.set(this, void 0);
        _MockRelayerEncryptedInput_contractAddress.set(this, void 0);
        _MockRelayerEncryptedInput_userAddress.set(this, void 0);
        _MockRelayerEncryptedInput_relayerProvider.set(this, void 0);
        _MockRelayerEncryptedInput_aclContractAddress.set(this, void 0);
        _MockRelayerEncryptedInput_inputVerifier.set(this, void 0);
        if (BigInt(contractChainId) > math_js_1.MAX_UINT64) {
            throw new Error("ChainId exceeds maximum allowed value (8 bytes)");
        }
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_relayerProvider, relayerProvider, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_contractChainId, contractChainId, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_contractAddress, contractAddress, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_userAddress, userAddress, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_aclContractAddress, aclContractAddress, "f");
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_inputVerifier, inputVerifier, "f");
    }
    get userAddress() {
        return __classPrivateFieldGet(this, _MockRelayerEncryptedInput_userAddress, "f");
    }
    get contractAddress() {
        return __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractAddress, "f");
    }
    _checkAddFheBits(fheBitLen) {
        (0, error_js_1.assertFhevm)(fheBitLen >= 0);
        if (__classPrivateFieldGet(this, _MockRelayerEncryptedInput_totalFheBits, "f") + fheBitLen > MockRelayerEncryptedInput.MAX_FHE_BITS) {
            throw Error("Packing more than 2048 bits in a single input ciphertext is unsupported");
        }
        if (__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length + 1 > MockRelayerEncryptedInput.MAX_VAR_COUNT) {
            throw Error("Packing more than 256 variables in a single input ciphertext is unsupported");
        }
    }
    _addClearTextValueFheBitsPair(clearTextValue, fhevmType) {
        const fheType = (0, FhevmType_js_1.FhevmTypeToFheType)(fhevmType);
        const fheBitLen = (0, FheType_js_1.getFheTypeBitLength)(fheType);
        this._checkAddFheBits(fheBitLen);
        __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fhevmTypes, "f").push(fhevmType);
        __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fheTypes, "f").push(fheType);
        __classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").push(clearTextValue);
        __classPrivateFieldSet(this, _MockRelayerEncryptedInput_totalFheBits, __classPrivateFieldGet(this, _MockRelayerEncryptedInput_totalFheBits, "f") + fheBitLen, "f");
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length <= MockRelayerEncryptedInput.MAX_VAR_COUNT);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_totalFheBits, "f") <= MockRelayerEncryptedInput.MAX_FHE_BITS);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length === __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fheTypes, "f").length);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length === __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fhevmTypes, "f").length);
    }
    _addBytes(clearTextValue, fhevmType) {
        (0, error_js_1.assertFhevm)((0, FhevmType_js_1.isFhevmEbytes)(fhevmType));
        const fhevmTypeInfo = (0, FhevmType_js_1.getFhevmTypeInfo)(fhevmType);
        const fheBitLen = (0, FheType_js_1.getFheTypeBitLength)(fhevmTypeInfo.fheType);
        const clearTextBitLen = fhevmTypeInfo.clearTextBitLength;
        (0, error_js_1.assertFhevm)(clearTextBitLen === fheBitLen);
        (0, error_js_1.assertFhevm)(fheBitLen % 8 === 0);
        const fheByteLen = fheBitLen / 8;
        if (clearTextValue.length > fheByteLen) {
            throw new error_js_1.FhevmError(`Uncorrect length of input Uint8Array, should be ${fheByteLen} for an ${fhevmTypeInfo.name}`);
        }
        const clearTextValueBigInt = ethers_1.ethers.toBigInt(clearTextValue);
        const maxClearTextValueBigInt = (0, math_js_1.getMaxBigInt)(clearTextBitLen);
        (0, error_js_1.assertFhevm)(clearTextValue.length * 8 === fheBitLen);
        (0, error_js_1.assertFhevm)(clearTextValueBigInt <= maxClearTextValueBigInt);
        this._addClearTextValueFheBitsPair(clearTextValueBigInt, fhevmType);
        return this;
    }
    _addUint(clearTextValue, fhevmzType) {
        (0, error_js_1.assertFhevm)((0, FhevmType_js_1.isFhevmEuint)(fhevmzType));
        const fhevmTypeInfo = (0, FhevmType_js_1.getFhevmTypeInfo)(fhevmzType);
        const clearTextBitLen = fhevmTypeInfo.clearTextBitLength;
        if (clearTextValue < 0) {
            throw new error_js_1.FhevmError(`Invalid unsigned integer value ${clearTextValue}`);
        }
        const clearTextValueBigInt = BigInt(clearTextValue);
        const maxClearTextValueBigInt = (0, math_js_1.getMaxBigInt)(clearTextBitLen);
        if (clearTextValueBigInt > maxClearTextValueBigInt) {
            throw new error_js_1.FhevmError(`Invalid ${fhevmTypeInfo.solidityTypeName} value: ${clearTextValue}, it exceeds the maximum allowed value of ${maxClearTextValueBigInt}.`);
        }
        this._addClearTextValueFheBitsPair(clearTextValueBigInt, fhevmzType);
        return this;
    }
    addBool(value) {
        const zeroOrOneBigInt = (0, math_js_1.boolToBigInt)(value);
        this._addClearTextValueFheBitsPair(zeroOrOneBigInt, FhevmType_js_1.FhevmType.ebool);
        return this;
    }
    add8(value) {
        return this._addUint(value, FhevmType_js_1.FhevmType.euint8);
    }
    add16(value) {
        return this._addUint(value, FhevmType_js_1.FhevmType.euint16);
    }
    add32(value) {
        return this._addUint(value, FhevmType_js_1.FhevmType.euint32);
    }
    add64(value) {
        return this._addUint(value, FhevmType_js_1.FhevmType.euint64);
    }
    add128(value) {
        return this._addUint(value, FhevmType_js_1.FhevmType.euint128);
    }
    addAddress(value) {
        if (!ethers_1.ethers.isAddress(value)) {
            throw new Error("Invalid address value: ${value}.");
        }
        const clearTextValue = ethers_1.ethers.getAddress(value);
        this._addClearTextValueFheBitsPair(clearTextValue, FhevmType_js_1.FhevmType.eaddress);
        return this;
    }
    add256(value) {
        return this._addUint(value, FhevmType_js_1.FhevmType.euint256);
    }
    addBytes64(value) {
        return this._addBytes(value, FhevmType_js_1.FhevmType.ebytes64);
    }
    addBytes128(value) {
        return this._addBytes(value, FhevmType_js_1.FhevmType.ebytes128);
    }
    addBytes256(value) {
        return this._addBytes(value, FhevmType_js_1.FhevmType.ebytes256);
    }
    _toMockFhevmRelayerV1InputProofPayload(extraData) {
        const numHandles = __classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f").length;
        const clearTextValuesBigIntHex = [];
        const clearTextValuesBigInt = [];
        const rand32BufferList = [];
        const metadatas = [];
        for (let i = 0; i < numHandles; ++i) {
            const clearTextValueBigInt = BigInt(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_clearTextValues, "f")[i]);
            clearTextValuesBigInt.push(clearTextValueBigInt);
            clearTextValuesBigIntHex.push(ethers_1.ethers.toBeHex(clearTextValueBigInt));
            rand32BufferList.push(ethers_1.ethers.randomBytes(32));
            metadatas.push({
                blockNumber: 0,
                index: 0,
                transactionHash: ethers_1.ethers.ZeroHash,
            });
        }
        const mockCiphertextWithInputVerification = MockRelayerEncryptedInput._computeMockCiphertextWithZKProof(clearTextValuesBigInt, __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fheTypes, "f"), rand32BufferList);
        const mockData = {
            clearTextValuesBigIntHex,
            metadatas,
            fheTypes: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fheTypes, "f"),
            fhevmTypes: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fhevmTypes, "f"),
            aclContractAddress: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_aclContractAddress, "f"),
            random32List: rand32BufferList.map(ethers_1.ethers.hexlify),
        };
        const mockPayload = {
            contractAddress: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractAddress, "f"),
            userAddress: __classPrivateFieldGet(this, _MockRelayerEncryptedInput_userAddress, "f"),
            ciphertextWithInputVerification: ethers_1.ethers.hexlify(mockCiphertextWithInputVerification),
            contractChainId: "0x" + __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractChainId, "f").toString(16),
            extraData,
            mockData,
        };
        return mockPayload;
    }
    static _computeMockCiphertextWithZKProof(clearTextValuesBigInt, fheTypes, rand32BufferList) {
        let encrypted = new Uint8Array(0);
        const numHandles = clearTextValuesBigInt.length;
        (0, error_js_1.assertFhevm)(rand32BufferList.length === numHandles);
        (0, error_js_1.assertFhevm)(fheTypes.length === numHandles);
        for (let i = 0; i < numHandles; ++i) {
            const clearTextValueBigInt = clearTextValuesBigInt[i];
            const fheByteLen = (0, FheType_js_1.getFheTypeByteLength)(fheTypes[i]);
            const fheType1Byte = new Uint8Array([fheTypes[i]]);
            const clearTextValueXXBytes = (0, bytes_js_1.uintToBytes)(clearTextValueBigInt, fheByteLen);
            const rand32Buffer = rand32BufferList[i];
            encrypted = (0, bytes_js_1.concatBytes)(encrypted, fheType1Byte, clearTextValueXXBytes, rand32Buffer);
        }
        return ethers_1.ethers.getBytes(ethers_1.ethers.keccak256(encrypted));
    }
    async encrypt() {
        const extraData = "0x00";
        const payload = this._toMockFhevmRelayerV1InputProofPayload(extraData);
        const mockCiphertextWithZKProof = ethers_1.ethers.getBytes(payload.ciphertextWithInputVerification);
        const response = await relayer.requestRelayerV1InputProof(__classPrivateFieldGet(this, _MockRelayerEncryptedInput_relayerProvider, "f"), payload);
        const handlesBytes32List = FhevmHandle_js_1.FhevmHandle.computeHandles(mockCiphertextWithZKProof, __classPrivateFieldGet(this, _MockRelayerEncryptedInput_fhevmTypes, "f"), __classPrivateFieldGet(this, _MockRelayerEncryptedInput_aclContractAddress, "f"), __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractChainId, "f"), constants_js_1.default.FHEVM_HANDLE_VERSION);
        __classPrivateFieldGet(this, _MockRelayerEncryptedInput_inputVerifier, "f").verifySignatures(handlesBytes32List, __classPrivateFieldGet(this, _MockRelayerEncryptedInput_userAddress, "f"), __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractAddress, "f"), __classPrivateFieldGet(this, _MockRelayerEncryptedInput_contractChainId, "f"), extraData, response.signatures);
        const inputProofHex = (0, InputVerifier_js_1.computeInputProofHex)(response.handles, response.signatures, extraData);
        return {
            handles: handlesBytes32List,
            inputProof: ethers_1.ethers.toBeArray(inputProofHex),
        };
    }
    getBits() {
        throw new error_js_1.FhevmError("ZKInput interface method: Not supported in mock mode");
    }
}
exports.MockRelayerEncryptedInput = MockRelayerEncryptedInput;
_MockRelayerEncryptedInput_clearTextValues = new WeakMap(), _MockRelayerEncryptedInput_fhevmTypes = new WeakMap(), _MockRelayerEncryptedInput_fheTypes = new WeakMap(), _MockRelayerEncryptedInput_totalFheBits = new WeakMap(), _MockRelayerEncryptedInput_contractChainId = new WeakMap(), _MockRelayerEncryptedInput_contractAddress = new WeakMap(), _MockRelayerEncryptedInput_userAddress = new WeakMap(), _MockRelayerEncryptedInput_relayerProvider = new WeakMap(), _MockRelayerEncryptedInput_aclContractAddress = new WeakMap(), _MockRelayerEncryptedInput_inputVerifier = new WeakMap();
Object.defineProperty(MockRelayerEncryptedInput, "MAX_FHE_BITS", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 2048
});
Object.defineProperty(MockRelayerEncryptedInput, "MAX_VAR_COUNT", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 256
});
//# sourceMappingURL=MockRelayerEncryptedInput.js.map