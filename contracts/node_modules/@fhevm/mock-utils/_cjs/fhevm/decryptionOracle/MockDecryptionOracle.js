"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _MockDecryptionOracleDB_map, _MockDecryptionOracle_iterator, _MockDecryptionOracle_handler, _MockDecryptionOracle_readonlyProvider, _MockDecryptionOracle_coprocessor, _MockDecryptionOracle_requestDB, _MockDecryptionOracle_acl, _MockDecryptionOracle_kmsVerifier, _MockDecryptionOracle_kmsSigners;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockDecryptionOracle = void 0;
const ethers_1 = require("ethers");
const error_js_1 = require("../../utils/error.js");
const ACL_js_1 = require("../contracts/ACL.js");
const KMSVerifier_js_1 = require("../contracts/KMSVerifier.js");
const DecryptionOracleEventsHandler_js_1 = require("./DecryptionOracleEventsHandler.js");
const DecryptionOracleEventsIterator_js_1 = require("./DecryptionOracleEventsIterator.js");
const abi_js_1 = require("./abi.js");
const utils_js_1 = require("./utils.js");
class MockDecryptionOracleDB {
    constructor() {
        _MockDecryptionOracleDB_map.set(this, new Map());
    }
    static key(event, counterOverride) {
        return `${Number(counterOverride ?? event.counter)}}`;
    }
    tryQuery(event) {
        return __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").get(MockDecryptionOracleDB.key(event));
    }
    delete(event) {
        __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").delete(MockDecryptionOracleDB.key(event));
    }
    setPending(event, evmHasReverted) {
        if (this.has(event) && !evmHasReverted) {
            throw new error_js_1.FhevmError(`Decryption Request counter=${event.counter}, requestID=${event.requestID}, contractCaller=${event.contractCallerAddress} already registered`);
        }
        const entry = {
            event: {
                counter: Number(event.counter),
                requestID: Number(event.requestID),
                contractCallerAddress: event.contractCallerAddress,
                index: event.index,
                blockNumber: event.blockNumber,
                transactionHash: event.transactionHash,
                transactionIndex: event.transactionIndex,
            },
            callbackBlockNumber: -1,
            callbackTransactionHash: undefined,
            callbackReverted: undefined,
            pending: true,
        };
        __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").set(MockDecryptionOracleDB.key(event), entry);
        return entry;
    }
    isPending(event) {
        const entry = __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").get(MockDecryptionOracleDB.key(event));
        if (!entry) {
            return false;
        }
        return entry.pending;
    }
    executed(event) {
        const entry = __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").get(MockDecryptionOracleDB.key(event));
        if (!entry) {
            return false;
        }
        return !entry.pending;
    }
    has(event) {
        return __classPrivateFieldGet(this, _MockDecryptionOracleDB_map, "f").has(MockDecryptionOracleDB.key(event));
    }
}
_MockDecryptionOracleDB_map = new WeakMap();
class MockDecryptionOracle {
    constructor() {
        _MockDecryptionOracle_iterator.set(this, void 0);
        _MockDecryptionOracle_handler.set(this, void 0);
        _MockDecryptionOracle_readonlyProvider.set(this, void 0);
        _MockDecryptionOracle_coprocessor.set(this, void 0);
        _MockDecryptionOracle_requestDB.set(this, new MockDecryptionOracleDB());
        _MockDecryptionOracle_acl.set(this, void 0);
        _MockDecryptionOracle_kmsVerifier.set(this, void 0);
        _MockDecryptionOracle_kmsSigners.set(this, void 0);
    }
    static async create(readonlyProvider, params) {
        const mdo = new MockDecryptionOracle();
        const db = params.coprocessor.getDB();
        const decryptionOracleContractItf = params.decryptionOracleContractInterface ?? abi_js_1.DecryptionOraclePartialInterface;
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_readonlyProvider, readonlyProvider, "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_coprocessor, params.coprocessor, "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_iterator, new DecryptionOracleEventsIterator_js_1.DecryptionOracleEventsIterator(decryptionOracleContractItf, params.decryptionOracleContractAddress, readonlyProvider, db.fromBlockNumber), "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_kmsVerifier, await KMSVerifier_js_1.KMSVerifier.create(readonlyProvider, params.kmsVerifierContractAddress), "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_acl, await ACL_js_1.ACL.create(readonlyProvider, params.aclContractAddress), "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_handler, new DecryptionOracleEventsHandler_js_1.DecryptionOracleEventsHandler(db, __classPrivateFieldGet(mdo, _MockDecryptionOracle_kmsVerifier, "f"), params.kmsSigners, params.relayerSigner), "f");
        __classPrivateFieldSet(mdo, _MockDecryptionOracle_kmsSigners, params.kmsSigners, "f");
        return mdo;
    }
    async createDecryptionSignatures(handlesBytes32Hex, clearTextValues, extraData) {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockDecryptionOracle_kmsVerifier, "f") !== undefined, `MockDecryptionOracle not initialized`);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockDecryptionOracle_kmsSigners, "f") !== undefined, `MockDecryptionOracle not initialized`);
        const res = await (0, KMSVerifier_js_1.computeDecryptionSignatures)(handlesBytes32Hex, clearTextValues, extraData, ethers_1.ethers.AbiCoder.defaultAbiCoder(), __classPrivateFieldGet(this, _MockDecryptionOracle_kmsVerifier, "f"), __classPrivateFieldGet(this, _MockDecryptionOracle_kmsSigners, "f"));
        return { decryptedResult: res.decryptedResult, signatures: res.signatures };
    }
    async awaitDecryptionOracle() {
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockDecryptionOracle_coprocessor, "f") !== undefined, `MockDecryptionOracle not initialized`);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockDecryptionOracle_iterator, "f") !== undefined, `MockDecryptionOracle not initialized`);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockDecryptionOracle_readonlyProvider, "f") !== undefined, `MockDecryptionOracle not initialized`);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockDecryptionOracle_acl, "f") !== undefined, `MockDecryptionOracle not initialized`);
        (0, error_js_1.assertFhevm)(__classPrivateFieldGet(this, _MockDecryptionOracle_handler, "f") !== undefined, `MockDecryptionOracle not initialized`);
        await __classPrivateFieldGet(this, _MockDecryptionOracle_coprocessor, "f").awaitCoprocessor();
        const { events, evmHasReverted } = await __classPrivateFieldGet(this, _MockDecryptionOracle_iterator, "f").next();
        for (let i = 0; i < events.length; ++i) {
            const dre = (0, utils_js_1.toDecryptionRequestEvent)(events[i]);
            if (!dre) {
                continue;
            }
            if (__classPrivateFieldGet(this, _MockDecryptionOracle_requestDB, "f").isPending(dre)) {
                throw new error_js_1.FhevmError(`DecryptionRequest requestID=${dre.requestID}, contractCaller=${dre.contractCallerAddress} already being executed.`);
            }
            await __classPrivateFieldGet(this, _MockDecryptionOracle_acl, "f").checkIsAllowedForDecryption(dre.handlesBytes32Hex, __classPrivateFieldGet(this, _MockDecryptionOracle_readonlyProvider, "f"));
            const newEntry = __classPrivateFieldGet(this, _MockDecryptionOracle_requestDB, "f").setPending(dre, evmHasReverted);
            (0, error_js_1.assertFhevm)(newEntry.pending);
            (0, error_js_1.assertFhevm)(newEntry.callbackBlockNumber === -1);
            (0, error_js_1.assertFhevm)(newEntry.callbackReverted === undefined);
            (0, error_js_1.assertFhevm)(newEntry.callbackTransactionHash === undefined);
            try {
                const { tx, receipt } = await __classPrivateFieldGet(this, _MockDecryptionOracle_handler, "f").handleEvent(dre);
                newEntry.callbackBlockNumber = receipt?.blockNumber;
                newEntry.callbackReverted = receipt?.status === 0;
                newEntry.callbackTransactionHash = tx.hash;
                newEntry.pending = false;
            }
            catch (e) {
                __classPrivateFieldGet(this, _MockDecryptionOracle_requestDB, "f").delete(dre);
                throw e;
            }
        }
    }
}
exports.MockDecryptionOracle = MockDecryptionOracle;
_MockDecryptionOracle_iterator = new WeakMap(), _MockDecryptionOracle_handler = new WeakMap(), _MockDecryptionOracle_readonlyProvider = new WeakMap(), _MockDecryptionOracle_coprocessor = new WeakMap(), _MockDecryptionOracle_requestDB = new WeakMap(), _MockDecryptionOracle_acl = new WeakMap(), _MockDecryptionOracle_kmsVerifier = new WeakMap(), _MockDecryptionOracle_kmsSigners = new WeakMap();
//# sourceMappingURL=MockDecryptionOracle.js.map