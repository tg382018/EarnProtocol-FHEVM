"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDecryptionOracleEvents = getDecryptionOracleEvents;
exports.toDecryptionRequestEvent = toDecryptionRequestEvent;
exports.parseDecryptionRequestEventsFromLogs = parseDecryptionRequestEventsFromLogs;
const event_js_1 = require("../../ethers/event.js");
const error_js_1 = require("../../utils/error.js");
const DecryptionOracleEvents_js_1 = require("./DecryptionOracleEvents.js");
const abi_js_1 = require("./abi.js");
async function getDecryptionOracleEvents(decryptionOracleContractInterface, decryptionOracleContractAddress, readonlyProvider, options) {
    let currentBlockNumber = -1;
    let toBlock;
    if (options.toBlockNumber !== undefined) {
        toBlock = options.toBlockNumber;
    }
    else {
        currentBlockNumber = await readonlyProvider.getBlockNumber();
        toBlock = currentBlockNumber;
    }
    let fromBlock;
    if (options.fromBlockNumber !== undefined) {
        fromBlock = options.fromBlockNumber;
    }
    else {
        fromBlock = toBlock;
    }
    if (fromBlock > toBlock) {
        throw new error_js_1.FhevmError(`Invalid block filter fromBlock=${fromBlock} toBlock=${toBlock}`);
    }
    const eventDecryptionFragment = decryptionOracleContractInterface.getEvent("DecryptionRequest");
    if (!eventDecryptionFragment) {
        throw new error_js_1.FhevmError(`Unknown "DecryptionRequest" event`);
    }
    const topics = decryptionOracleContractInterface.encodeFilterTopics(eventDecryptionFragment, []);
    const filter = {
        address: decryptionOracleContractAddress,
        fromBlock,
        toBlock,
        topics,
    };
    const logs = await readonlyProvider.getLogs(filter);
    const cursor = new event_js_1.BlockLogCursor(-1);
    const events = logs
        .map((log) => {
        try {
            cursor.updateForward(log.blockNumber, log.index);
            const parsedLog = decryptionOracleContractInterface.parseLog(log);
            if (!(0, DecryptionOracleEvents_js_1.isDecryptionOracleEventName)(parsedLog.name)) {
                return null;
            }
            if (log.blockNumber === fromBlock) {
                if (options.fromBlockLogIndex !== undefined) {
                    if (log.index < options.fromBlockLogIndex) {
                        return null;
                    }
                }
            }
            const evt = {
                eventName: parsedLog.name,
                args: parsedLog.args,
                index: log.index,
                blockNumber: log.blockNumber,
                transactionHash: log.transactionHash,
                transactionIndex: log.transactionIndex,
            };
            return evt;
        }
        catch {
            return null;
        }
    })
        .filter((event) => event !== null);
    return { events, cursor };
}
function toDecryptionRequestEvent(e) {
    if (e.eventName !== "DecryptionRequest") {
        return null;
    }
    const counter = e.args[0];
    const requestID = e.args[1];
    const handlesBytes32Hex = e.args[2];
    const contractCallerAddress = e.args[3];
    const callbackSelectorBytes4Hex = e.args[4];
    (0, event_js_1.assertEventArgIsBigUint256)(counter, "DecryptionRequest", 0);
    (0, event_js_1.assertEventArgIsBigUint256)(requestID, "DecryptionRequest", 1);
    (0, error_js_1.assertFhevm)(handlesBytes32Hex.length > 0);
    (0, event_js_1.assertEventArgIsBytes32String)(handlesBytes32Hex[0], "DecryptionRequest", 2);
    (0, event_js_1.assertEventArgIsAddress)(contractCallerAddress, "DecryptionRequest", 3);
    (0, event_js_1.assertEventArgIsBytes4String)(callbackSelectorBytes4Hex, "DecryptionRequest", 4);
    const evt = {
        blockNumber: e.blockNumber,
        index: e.index,
        transactionHash: e.transactionHash,
        transactionIndex: e.transactionIndex,
        counter,
        requestID,
        handlesBytes32Hex,
        contractCallerAddress,
        callbackSelectorBytes4Hex,
    };
    return evt;
}
function parseDecryptionRequestEventsFromLogs(logs) {
    if (!logs) {
        return [];
    }
    const events = [];
    for (const log of logs) {
        const event = abi_js_1.DecryptionOraclePartialInterface.parseLog(log);
        if (!event) {
            continue;
        }
        if (!(0, DecryptionOracleEvents_js_1.isDecryptionOracleEventName)(event.name)) {
            continue;
        }
        const doe = {
            eventName: event.name,
            args: event.args,
            blockNumber: log.blockNumber,
            index: log.index,
            transactionHash: log.transactionHash,
            transactionIndex: log.transactionIndex,
        };
        const e = toDecryptionRequestEvent(doe);
        if (!e) {
            continue;
        }
        events.push(e);
    }
    return events;
}
//# sourceMappingURL=utils.js.map