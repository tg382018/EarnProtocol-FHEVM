"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FhevmHandle_hash21, _FhevmHandle_chainId, _FhevmHandle_fhevmType, _FhevmHandle_fheType, _FhevmHandle_version, _FhevmHandle_computed, _FhevmHandle_index;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FhevmHandle = void 0;
const ethers_1 = require("ethers");
const constants_js_1 = require("../constants.js");
const address_js_1 = require("../utils/address.js");
const bytes_js_1 = require("../utils/bytes.js");
const error_js_1 = require("../utils/error.js");
const math_js_1 = require("../utils/math.js");
const FheType_js_1 = require("./FheType.js");
const FhevmType_js_1 = require("./FhevmType.js");
class FhevmHandle {
    constructor(hash21, chainId, fhevmType, fheType, version, computed, index) {
        _FhevmHandle_hash21.set(this, void 0);
        _FhevmHandle_chainId.set(this, void 0);
        _FhevmHandle_fhevmType.set(this, void 0);
        _FhevmHandle_fheType.set(this, void 0);
        _FhevmHandle_version.set(this, void 0);
        _FhevmHandle_computed.set(this, void 0);
        _FhevmHandle_index.set(this, void 0);
        __classPrivateFieldSet(this, _FhevmHandle_hash21, hash21, "f");
        __classPrivateFieldSet(this, _FhevmHandle_chainId, chainId, "f");
        __classPrivateFieldSet(this, _FhevmHandle_fhevmType, fhevmType, "f");
        __classPrivateFieldSet(this, _FhevmHandle_fheType, fheType, "f");
        __classPrivateFieldSet(this, _FhevmHandle_version, version, "f");
        __classPrivateFieldSet(this, _FhevmHandle_computed, computed, "f");
        if (index !== undefined) {
            __classPrivateFieldSet(this, _FhevmHandle_index, index, "f");
        }
    }
    get hash21() {
        return __classPrivateFieldGet(this, _FhevmHandle_hash21, "f");
    }
    get chainId() {
        return __classPrivateFieldGet(this, _FhevmHandle_chainId, "f");
    }
    get fhevmType() {
        return __classPrivateFieldGet(this, _FhevmHandle_fhevmType, "f");
    }
    get fheType() {
        return __classPrivateFieldGet(this, _FhevmHandle_fheType, "f");
    }
    get version() {
        return __classPrivateFieldGet(this, _FhevmHandle_version, "f");
    }
    get computed() {
        return __classPrivateFieldGet(this, _FhevmHandle_computed, "f");
    }
    get index() {
        return __classPrivateFieldGet(this, _FhevmHandle_index, "f");
    }
    get fhevmTypeInfo() {
        return (0, FhevmType_js_1.getFhevmTypeInfo)(__classPrivateFieldGet(this, _FhevmHandle_fhevmType, "f"));
    }
    get fheTypeInfo() {
        return (0, FheType_js_1.getFheTypeInfo)(__classPrivateFieldGet(this, _FhevmHandle_fheType, "f"));
    }
    static fromBytes32Hex(handleBytes32Hex) {
        (0, error_js_1.assertFhevm)(typeof handleBytes32Hex === "string", `handle argument type mismatch. Got a ${typeof handleBytes32Hex}, expecting a string.`);
        if (!ethers_1.ethers.isHexString(handleBytes32Hex, 32)) {
            throw new error_js_1.FhevmError(`Invalid handle ${handleBytes32Hex}, handle length sould be 66`);
        }
        const hash21 = handleBytes32Hex.slice(0, 44);
        const handleIndexHex = handleBytes32Hex.slice(44, 46);
        let handleIndex = 0;
        try {
            handleIndex = (0, math_js_1.toUIntNumber)("0x" + handleIndexHex);
        }
        catch {
            throw new error_js_1.FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 21 does not contain a valid index`);
        }
        const computed = handleIndex === 255;
        const handleChainIdHex = handleBytes32Hex.slice(46, 62);
        let chainId = 0;
        try {
            chainId = (0, math_js_1.toUIntNumber)("0x" + handleChainIdHex);
        }
        catch {
            throw new error_js_1.FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 22-29 does not contain a valid chainId`);
        }
        const handleTypeHex = handleBytes32Hex.slice(62, 64);
        let fheType = undefined;
        let fhevmType = undefined;
        try {
            const t = (0, math_js_1.toUIntNumber)("0x" + handleTypeHex);
            fheType = t;
            fhevmType = t;
        }
        catch {
            throw new error_js_1.FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 30 does not contain the a valid (got 0x${handleTypeHex}).`);
        }
        (0, FheType_js_1.checkFheType)(fheType);
        (0, FhevmType_js_1.checkFhevmType)(fhevmType);
        const handleVersionHex = handleBytes32Hex.slice(64, 66);
        let version = 0;
        try {
            version = (0, math_js_1.toUIntNumber)("0x" + handleVersionHex);
        }
        catch {
            throw new error_js_1.FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 31 does not contain a valid version number.`);
        }
        if (version !== constants_js_1.default.FHEVM_HANDLE_VERSION) {
            throw new error_js_1.FhevmError(`Invalid handle ${handleBytes32Hex}, Byte 31 does not contain the expected version=${constants_js_1.default.FHEVM_HANDLE_VERSION}, got ${version} instead`);
        }
        const fhevmHandle = new FhevmHandle(hash21, chainId, fhevmType, fheType, version, computed, handleIndex < 255 ? handleIndex : undefined);
        return fhevmHandle;
    }
    static verify(handleBytes32, expected) {
        (0, bytes_js_1.assertIsBytes32String)(handleBytes32, "handleBytes32");
        if (handleBytes32 === ethers_1.ethers.ZeroHash) {
            throw new error_js_1.FhevmError("Handle is not initialized");
        }
        const fhevmHandle = FhevmHandle.fromBytes32Hex(handleBytes32);
        if (expected?.chainId !== undefined) {
            if (fhevmHandle.chainId !== expected.chainId) {
                throw new error_js_1.FhevmError(`Chain ID mismatch for handle ${handleBytes32}, expected ${expected.chainId}, but got ${fhevmHandle.chainId} instead.`);
            }
        }
        if (expected?.fhevmType !== undefined) {
            if (fhevmHandle.fhevmType !== expected.fhevmType) {
                const fhevmTypeInfo = fhevmHandle.fhevmTypeInfo;
                const expectedFhevmTypeInfo = (0, FhevmType_js_1.getFhevmTypeInfo)(expected.fhevmType);
                throw new error_js_1.FhevmError(`Type mismatch for handle '${handleBytes32}': expected '${expectedFhevmTypeInfo.name}', but got '${fhevmTypeInfo.name}' instead.`);
            }
        }
        if (expected?.fheType !== undefined) {
            if (fhevmHandle.fheType !== expected.fheType) {
                const fheTypeInfo = fhevmHandle.fheTypeInfo;
                const expectedFheTypeInfo = (0, FheType_js_1.getFheTypeInfo)(expected.fheType);
                throw new error_js_1.FhevmError(`Type mismatch for handle '${handleBytes32}': expected '${expectedFheTypeInfo.type}', but got '${fheTypeInfo.type}' instead.`);
            }
        }
        return fhevmHandle;
    }
    toHandleBytes32() {
        (0, error_js_1.assertFhevm)(Number(__classPrivateFieldGet(this, _FhevmHandle_fheType, "f")) === Number(__classPrivateFieldGet(this, _FhevmHandle_fhevmType, "f")));
        (0, error_js_1.assertFhevm)((__classPrivateFieldGet(this, _FhevmHandle_index, "f") === undefined && __classPrivateFieldGet(this, _FhevmHandle_computed, "f")) ||
            (__classPrivateFieldGet(this, _FhevmHandle_index, "f") !== undefined && __classPrivateFieldGet(this, _FhevmHandle_index, "f") < 255 && !__classPrivateFieldGet(this, _FhevmHandle_computed, "f")));
        const chainId32Bytes = (0, bytes_js_1.uintToBytes)(__classPrivateFieldGet(this, _FhevmHandle_chainId, "f"), 32);
        const chainId8Bytes = chainId32Bytes.subarray(24, 32);
        (0, error_js_1.assertFhevm)(chainId32Bytes.length === 32);
        (0, error_js_1.assertFhevm)(chainId8Bytes.length === 8);
        const handleHash = ethers_1.ethers.getBytes(__classPrivateFieldGet(this, _FhevmHandle_hash21, "f"));
        const handleBytes32AsBytes = new Uint8Array(32);
        handleBytes32AsBytes.set(handleHash, 0);
        handleBytes32AsBytes[21] = __classPrivateFieldGet(this, _FhevmHandle_index, "f") === undefined ? 255 : __classPrivateFieldGet(this, _FhevmHandle_index, "f");
        handleBytes32AsBytes.set(chainId8Bytes, 22);
        handleBytes32AsBytes[30] = __classPrivateFieldGet(this, _FhevmHandle_fheType, "f");
        handleBytes32AsBytes[31] = __classPrivateFieldGet(this, _FhevmHandle_version, "f");
        return handleBytes32AsBytes;
    }
    toHandleBytes32Hex() {
        return ethers_1.ethers.hexlify(this.toHandleBytes32());
    }
    static createInputHandle(blobHashBytes32, aclAddress, chainId, fhevmType, ciphertextVersion, index) {
        const hash21 = FhevmHandle._computeInputHash21(blobHashBytes32, aclAddress, chainId, index);
        return new FhevmHandle(hash21, chainId, fhevmType, fhevmType, ciphertextVersion, false, index);
    }
    static _computeInputHash21(blobHashBytes32, aclAddress, chainId, index) {
        (0, bytes_js_1.assertIsBytes32)(blobHashBytes32, "blobHash");
        (0, address_js_1.assertIsAddress)(aclAddress, "aclAddress");
        (0, math_js_1.assertIsNumber)(index, "index");
        (0, math_js_1.assertIsNumber)(chainId, "chainId");
        const encryptionIndex1Byte = new Uint8Array([index]);
        const aclContractAddress20Bytes = (0, address_js_1.addressToBytes)(aclAddress, "ACL address");
        const chainId32Bytes = (0, bytes_js_1.uintToBytes)(chainId, 32);
        (0, bytes_js_1.assertIsBytes1)(encryptionIndex1Byte);
        (0, bytes_js_1.assertIsBytes20)(aclContractAddress20Bytes);
        (0, bytes_js_1.assertIsBytes32)(chainId32Bytes);
        return ethers_1.ethers.keccak256((0, bytes_js_1.concatBytes)(blobHashBytes32, encryptionIndex1Byte, aclContractAddress20Bytes, chainId32Bytes));
    }
    static computeHandlesHex(ciphertextWithZKProof, fhevmTypes, aclContractAddress, chainId, ciphertextVersion) {
        const handlesAsBytes = FhevmHandle.computeHandles(ciphertextWithZKProof, fhevmTypes, aclContractAddress, chainId, ciphertextVersion);
        return handlesAsBytes.map(ethers_1.ethers.hexlify);
    }
    static computeHandles(ciphertextWithZKProof, fhevmTypes, aclContractAddress, chainId, ciphertextVersion) {
        if (BigInt(chainId) > math_js_1.MAX_UINT64) {
            throw new error_js_1.FhevmError("ChainId exceeds maximum allowed value (8 bytes)");
        }
        const blobHashBytes32Hex = ethers_1.ethers.keccak256(ciphertextWithZKProof);
        const blobHashBytes32 = ethers_1.ethers.getBytes(blobHashBytes32Hex);
        (0, error_js_1.assertFhevm)(blobHashBytes32.length === 32);
        const handles = fhevmTypes.map((fhevmType, encryptionIndex) => {
            const fhevmHandle = FhevmHandle.createInputHandle(blobHashBytes32, aclContractAddress, chainId, fhevmType, ciphertextVersion, encryptionIndex);
            return fhevmHandle.toHandleBytes32();
        });
        return handles;
    }
}
exports.FhevmHandle = FhevmHandle;
_FhevmHandle_hash21 = new WeakMap(), _FhevmHandle_chainId = new WeakMap(), _FhevmHandle_fhevmType = new WeakMap(), _FhevmHandle_fheType = new WeakMap(), _FhevmHandle_version = new WeakMap(), _FhevmHandle_computed = new WeakMap(), _FhevmHandle_index = new WeakMap();
//# sourceMappingURL=FhevmHandle.js.map