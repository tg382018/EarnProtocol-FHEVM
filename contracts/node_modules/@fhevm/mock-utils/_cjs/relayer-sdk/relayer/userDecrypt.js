"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkDeadlineValidity = checkDeadlineValidity;
exports.buildUserDecryptedResult = buildUserDecryptedResult;
exports.checkMaxContractAddresses = checkMaxContractAddresses;
const ethers_1 = require("ethers");
const error_js_1 = require("../../utils/error.js");
const MAX_USER_DECRYPT_CONTRACT_ADDRESSES = 10;
const MAX_USER_DECRYPT_DURATION_DAYS = 365n;
function checkDeadlineValidity(startTimestamp, durationDays) {
    if (durationDays === BigInt(0)) {
        throw new error_js_1.FhevmError("durationDays is null");
    }
    if (durationDays > MAX_USER_DECRYPT_DURATION_DAYS) {
        throw new error_js_1.FhevmError(`durationDays is above max duration of ${MAX_USER_DECRYPT_DURATION_DAYS}`);
    }
    const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));
    if (startTimestamp > currentTimestamp) {
        throw new error_js_1.FhevmError("startTimestamp is set in the future");
    }
    const durationInSeconds = durationDays * BigInt(86400);
    if (startTimestamp + durationInSeconds < currentTimestamp) {
        throw new error_js_1.FhevmError("User decrypt request has expired");
    }
}
function formatAccordingToType(decryptedBigInt, type) {
    if (type === 0) {
        return decryptedBigInt === BigInt(1);
    }
    else if (type === 7) {
        return ethers_1.ethers.getAddress("0x" + decryptedBigInt.toString(16).padStart(40, "0"));
    }
    else if (type === 9) {
        return "0x" + decryptedBigInt.toString(16).padStart(128, "0");
    }
    else if (type === 10) {
        return "0x" + decryptedBigInt.toString(16).padStart(256, "0");
    }
    else if (type === 11) {
        return "0x" + decryptedBigInt.toString(16).padStart(512, "0");
    }
    return decryptedBigInt;
}
function buildUserDecryptedResult(handles, listBigIntDecryptions) {
    let typesList = [];
    for (const handle of handles) {
        const hexPair = handle.slice(-4, -2).toLowerCase();
        const typeDiscriminant = parseInt(hexPair, 16);
        typesList.push(typeDiscriminant);
    }
    let results = {};
    handles.forEach((handle, idx) => (results[handle] = formatAccordingToType(listBigIntDecryptions[idx], typesList[idx])));
    return results;
}
function checkMaxContractAddresses(contractAddresses) {
    const contractAddressesLength = contractAddresses.length;
    if (contractAddressesLength === 0) {
        throw new error_js_1.FhevmError("contractAddresses is empty");
    }
    if (contractAddressesLength > MAX_USER_DECRYPT_CONTRACT_ADDRESSES) {
        throw new error_js_1.FhevmError(`contractAddresses max length of ${MAX_USER_DECRYPT_CONTRACT_ADDRESSES} exceeded`);
    }
}
//# sourceMappingURL=userDecrypt.js.map