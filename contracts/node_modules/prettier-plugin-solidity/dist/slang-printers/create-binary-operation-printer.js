import { NonterminalKind, TerminalKind } from '@nomicfoundation/slang/cst';
import { doc } from 'prettier';
import { isBinaryOperation } from '../slang-utils/is-binary-operation.js';
const { group, line } = doc.builders;
function rightOperandPrint(node, path, print, options) {
    const rightOperand = options.experimentalOperatorPosition === 'end'
        ? [` ${node.operator}`, line, path.call(print, 'rightOperand')]
        : [line, `${node.operator} `, path.call(print, 'rightOperand')];
    // If there's only a single binary expression, we want to create a group in
    // order to avoid having a small right part like -1 be on its own line.
    const leftOperand = node.leftOperand.variant;
    const grandparentNode = path.grandparent;
    const shouldGroup = (leftOperand.kind === TerminalKind.Identifier ||
        !isBinaryOperation(leftOperand)) &&
        (!isBinaryOperation(grandparentNode) ||
            grandparentNode.kind === NonterminalKind.AssignmentExpression);
    return shouldGroup ? group(rightOperand) : rightOperand;
}
export const createBinaryOperationPrinter = (groupRulesBuilder, indentRulesBuilder) => (node, path, print, options) => {
    const groupRules = groupRulesBuilder(path);
    const indentRules = indentRulesBuilder(path, options);
    return groupRules([
        path.call(print, 'leftOperand'),
        indentRules(rightOperandPrint(node, path, print, options))
    ]);
};
//# sourceMappingURL=create-binary-operation-printer.js.map